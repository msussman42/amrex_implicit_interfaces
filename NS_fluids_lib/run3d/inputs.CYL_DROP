# -----------------------------------------
# General problem settings
# -----------------------------------------



ns.probtype=7001
ns.material_type=0 0 999
ns.num_materials=3
ns.num_species_var=0
ns.FSI_flag=0 0 1
ns.ncomp_sum_int_user1=9 
ns.ncomp_sum_int_user2=3 

# -----------------------------------------
# Space and time domain
# -----------------------------------------
max_step  = 100000    # maximum number of timesteps
stop_time = 1000.0    # maximum time value

geometry.coord_sys   = 0              # 0 => cart, 1 => RZ
#geometry.prob_lo     =-1.5 -1.5 -1.4 
#geometry.prob_hi     = 1.5  1.5  1.6  
geometry.prob_lo     =-6.0 -6.0 -6.0 
geometry.prob_hi     = 6.0  6.0  6.0  
#geometry.prob_lo     =-3.0 -3.0 -6.0 
#geometry.prob_hi     = 3.0  3.0  6.0  
geometry.is_periodic = 1 1 0


# -----------------------------------------
# I/O
# -----------------------------------------
amr.check_int       = 100     # number of timesteps between checkpoints
amr.check_file      = chk     # root name of checkpoint file
amr.plot_int        = 10      # number of timesteps between plots
amr.plot_file       = plt     # root name of VisIr plot file
amr.grid_log        = grdlog  # name of grid logging file
#amr.restart        = chk0000200
#amr.trace          = 1
amr.file_name_digits= 7
ns.sum_interval     = 100     # timesteps between computing statistics
ns.v=0
mg.verbose = 0
cg.verbose = 0
# set above to 2 for maximum verbosity

# -----------------------------------------
# Space and time discretization and AMR
# -----------------------------------------
# number of grid points on level=0
#amr.n_cell          = 256 256 384
#amr.n_cell          = 256 256 320
amr.n_cell          = 32 32 32
#amr.n_cell          = 128 128 256
amr.max_level       = 2
#ns.fixed_dt        = 5.0e-5   # hardwire dt
ns.cfl              = 0.5      # cfl number for hyperbolic system
ns.init_shrink      = 1.0      # scale back initial timestep
ns.change_max       = 1.01      # scale back initial timestep
ns.dt_cutoff        = 1.0e-10  # level 0 timestep below which we halt
# 0=take into account sound speed only at t=0 if compressible
# 1=always take into account sound speed
# 2=never take into account sound speed
ns.shock_timestep   = 2 2 2

amr.regrid_int      = 1        # how often to regrid
amr.n_error_buf     = 2 2 2   # number of buffer cells in error est
amr.grid_eff        = 0.9 #what constitutes efficient grid(smaller=>less boxes)
amr.blocking_factor = 8 8 4    # block factor in grid generation

amr.max_grid_size   = 32

ns.vorterr=0.0 0.0 0.0        # AMR based on vorticity

# -----------------------------------------
# Physical parameter
# -----------------------------------------
ns.visc_coef        = 1.0 # coef of viscosity
ns.gravity          = 9.8E-03
ns.gravity_dir      = 3
ns.invert_gravity   = 0

ns.advbot  =-1.0 # drop velocity
ns.adv_dir = 3   # Direction of the drop       
ns.output_drop_distribution=1

ns.denconst      = 1.0000E+03 1.1270E+00 1.0000E+03
ns.viscconst     = 6.5000E-01 1.9180E-02 6.5000E-01
ns.heatviscconst = 0.0 0.0 0.0
# sigma_12 = 22.0  (gas/liquid)
# sigma_13 = 97.0  (liquid/solid)
# sigma_23 = 75.7  (gas/solid)
# theta=86.61 degree
# theta_1 (the angle between the gamma_12 and gamma_13 interfaces):
#  Young's condition:
#  sigma_12 * cos(theta_1)+sigma_13 = sigma_23
#  cos(theta_1)=(sigma_23-sigma_13)/sigma_12
#  sigma_23-sigma_13=sigma_12 cos(theta_1)
#  sigma_23=sigma_12 cos(theta_1) + sigma_13
#  if cos(theta_1)<0 => set sigma_13=sigma_12
#  otherwise
#  if cos(theta_1)>0 => set sigma_23=sigma_12

# set theta=150  cos(theta)=-0.866
#                       12       13        23
ns.tension       = 7.2000E+01 7.2000E+01  9.648
#ns.tension       = 2.2000E+01 2.2000e+1  0.2948E+1 
#ns.tension       = 2.2000E+01 0.2948 2.2000E+01
#ns.tension       = 2.2000E+01 7.5700E+01 9.7000E+01
ns.stiffCP       = 4.1785E+03 1.0070E+03 4.1785E+03
ns.tempconst     = 293.0 293.0 293.0

# parameter for validation
# 0=default,  1=mesh validation
ns.axis_dir=2
ns.xblob6=0.0       # 2b length of one side of the hole
ns.yblob6=1.62       # d  thread diameter
# Droplet 
ns.xblob=0.0 
ns.yblob=0.0
ns.zblob=2.1
ns.radblob=1.27
# Number of threads (and corresponding files)
ns.xblob2=12.0

# internal grid box
# assuming [xblob3,yblob3]:[xblob4,yblob4] is the repeating pattern
ns.xblob3= 0.0
ns.xblob4= 1.5
ns.yblob3= 0.0
ns.yblob4= 1.5
ns.zblob3=-0.75
ns.zblob4= 0.75

# internal grid mesh size
ns.xblob5= 96.0
ns.yblob5= 96.0
ns.zblob5= 96.0
# ns.xblob5= 32.0
# ns.yblob5= 32.0
# ns.zblob5= 32.0

# max thread level set value
ns.radblob3=2.0 # Larger distance to low point of the thread


ns.pressure_error_cutoff=0.0 0.0 0.0
ns.denfact=1.0
ns.velfact=0.0
ns.adv_vel = 0.0 # not used
ns.twall=0.0
ns.rgasinlet=0.0
ns.vinletgas=0.0
# -----------------------------------------
# Boundary conditions
# -----------------------------------------
ns.lo_bc          = 0 0 2
ns.hi_bc          = 0 0 5
ns.viscosity_lo_bc = 0 0 2
ns.viscosity_hi_bc = 0 0 5

# >>>>>>>>>>>>>  BC FLAGS <<<<<<<<<<<<<<<<
# 0 = Interior           3 = Symmetry
# 1 = Inflow             4 = SlipWall
# 2 = Outflow            5 = NoSlipWall



# -----------------------------------------
# Algorithm parameters
# -----------------------------------------

# multigrid class
mg.nu_f = 40
mg.nu_0 = 1   # 1 - v-cycle 2 - w-cycle

ns.multilevel_maxcycle=200
ns.multilevel_restart_period=25
cg.restart_period=25
cg.maxiter = 200

mg.bot_atol = 1.0e-5 #1.0e-8 double 1.0e-5 single
mg.rtol_b = -0.01
Lp.v = 1

ns.continuous_mof=0
ns.FD_curv_interp=1
#ns.EILE_flag=-1 #Weymouth and Yue
ns.EILE_flag=1 #EILE
ns.projection_pressure_scale=1.0
#ns.show_mem=1
ns.MOFITERMAX=10
ns.mof_decision_tree_learning=125000 # default: 40000
ns.MOFITERMAX_AFTER_PREDICT=2
ns.truncate_thickness=2.0

ns.minimum_relative_error=1.0e-18
ns.initial_cg_cycles=10
ns.initial_project_cycles=3
ns.initial_viscosity_cycles=1
ns.initial_thermal_cycles=1
ns.project_solver_type=0 # 0MGPCG 1PCG 2 MINV=I
# 0=GSRB 1=ICRB 2=ILU
Lp.smooth_type=2
Lp.bottom_smooth_type=2
mac.mac_tol=1.0e-4 # 1.0e-8 double 1.0e-4 single
mac.mac_abs_tol = 1.0e-4 # 1.0e-8 double 1.0e-4 single


# select single or double precision of FAB output data
#        default is whatever precision code is compiled with.
#fab.precision = FLOAT     # output in FLOAT or DOUBLE
fab.precision = DOUBLE    # output in FLOAT or DOUBLE
