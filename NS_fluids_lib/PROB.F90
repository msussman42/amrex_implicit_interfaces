#undef BL_LANG_CC
#define BL_LANG_FORT

#include "AMReX_REAL.H"
#include "AMReX_CONSTANTS.H"
#include "AMReX_SPACE.H"
#include "AMReX_BC_TYPES.H"
#include "AMReX_ArrayLim.H"

#include "PROB_F.H"
#include "LEVEL_F.H"

#if (AMREX_SPACEDIM==3)
#define SDIM 3
#elif (AMREX_SPACEDIM==2)
#define SDIM 2
#else  
print *,"dimension bust"
stop
#endif

#define maxnumline 10

#define GRADHTOL (0.01)
#define MARCO 0

#define NR_MAX 60
#define NS_MAX NR_MAX*NR_MAX


! new random number generator
      module randomNG
        IMPLICIT NONE
        private
        public::rng_t, rng_seed, rng_uniform

        ! Dimension of the state
        integer, parameter :: ns = 4

        ! Default seed vector
        integer, parameter, dimension(ns) :: default_seed &
             = (/ 521288629, 362436069, 16163801, 1131199299 /)

        ! A data type for storing the state of the RNG
        type :: rng_t
           integer, dimension(ns) :: state =default_seed
        end type rng_t

      contains

        ! Seeds the RNG using a single
        ! integer and a default seed
        ! vector.
        subroutine rng_seed(self,seed)
          type(rng_t), intent(inout) :: self
          integer, intent(in) :: seed
          self%state(1) = seed
          self%state(2:ns) = default_seed(2:ns)
        end subroutine rng_seed


        ! Draws a uniform real number on [0,1].
        function rng_uniform(self) result(u)
          type(rng_t), intent(inout) :: self
          real :: u
          integer :: imz

          imz = self%state(1) - self%state(3)

          if (imz < 0) imz = imz + 2147483579

          self%state(1) = self%state(2)
          self%state(2) = self%state(3)
          self%state(3) = imz
          self%state(4) = 69069 * self%state(4) + 101390424             
          imz = imz + self%state(4)
          u = 0.5d0 + 0.23283064d-9 * imz
        end function rng_uniform

      end module randomNG



      module probf90_module
      use probcommon_module_types
      use probcommon_module

      contains

      subroutine get_nwrite(plot_sdim,nwrite)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T plot_sdim,nwrite,nmat,nten
      INTEGER_T nparts,nparts_def
      INTEGER_T im

      if (num_materials_vel.ne.1) then
       print *,"num_materials_vel invalid"
       stop
      endif

      if ((plot_sdim.ne.2).and.(plot_sdim.ne.3)) then
       print *,"plot_sdim invalid"
       stop
      endif

      nmat=num_materials
      nten=( (nmat-1)*(nmat-1)+nmat-1 )/2

      nparts=0
      do im=1,nmat
       if (is_lag_part(nmat,im).eq.1) then
        nparts=nparts+1
       else if (is_lag_part(nmat,im).eq.0) then
        ! do nothing
       else
        print *,"is_lag_part(nmat,im) invalid"
        stop
       endif
      enddo !im=1..nmat

      if ((nparts.lt.0).or.(nparts.gt.nmat)) then
       print *,"nparts invalid in get_nwrite"
       stop
      endif
      nparts_def=nparts
      if (nparts_def.eq.0) then
       nparts_def=1
      endif
      if ((nparts_def.lt.1).or.(nparts_def.ge.nmat)) then
       print *,"nparts_def invalid"
       stop
      endif

      nwrite= &
       plot_sdim+num_materials_vel*plot_sdim+ & ! xpos,vel
       5*num_materials_vel+ & !pmg,peos,div,divdat,mach
       nmat+nmat+ & ! vfrac,ls
       nmat*plot_sdim+ & ! ls slope
       nmat*num_state_material+ & ! den 
       num_materials_viscoelastic*FORT_NUM_TENSOR_TYPE+ &
       SDIM+ &
       nmat+ & ! visc
       5*nmat  ! trace vars and vorticity

      return
      end subroutine get_nwrite

      subroutine dumpstring_headers(plot_sdim)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T, intent(in) :: plot_sdim
      character*80 Varname
      character*2 specstr
      character*2 matstr
      character*2 matstropp
      INTEGER_T ih,im,ispec,imls,im_opp,dir,i,nmat,nten
      INTEGER_T nparts,nparts_def,partid

      if ((plot_sdim.ne.2).and.(plot_sdim.ne.3)) then
       print *,"plot_sdim invalid"
       stop
      endif
      if (num_materials_vel.ne.1) then
       print *,"num_materials_vel invalid"
       stop
      endif

      nmat=num_materials
      nten=( (nmat-1)*(nmat-1)+nmat-1 )/2

      nparts=0
      do im=1,nmat
       if (is_lag_part(nmat,im).eq.1) then
        nparts=nparts+1
       else if (is_lag_part(nmat,im).eq.0) then
        ! do nothing
       else
        print *,"is_lag_part(nmat,im) invalid dumpstring_headers"
        stop
       endif
      enddo !im=1..nmat

      if ((nparts.lt.0).or.(nparts.gt.nmat)) then
       print *,"nparts invalid dumpstring_headers"
       stop
      endif
      nparts_def=nparts
      if (nparts_def.eq.0) then
       nparts_def=1
      endif
      if ((nparts_def.lt.1).or.(nparts_def.gt.nmat)) then
       print *,"nparts_def invalid dumpstring_headers2"
       stop
      endif

      Varname='X'
      call dumpstring(Varname)
      Varname='Y'
      call dumpstring(Varname)

      if (plot_sdim.eq.3) then
       Varname='Z'
       call dumpstring(Varname)
      endif

      do im=1,num_materials_vel

       write(matstr,'(I2)') im
       do i=1,2
        if (matstr(i:i).eq.' ') then
         matstr(i:i)='0'
        endif
       enddo

       ih=1
       Varname='U'
       ih=ih+1
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)

       ih=1
       Varname='V'
       ih=ih+1
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)

       if (plot_sdim.eq.3) then
        ih=1
        Varname='W'
        ih=ih+1
        do i=1,2
         Varname(ih:ih)=matstr(i:i)
         ih=ih+1
        enddo
        call dumpstring(Varname)
       endif

      enddo ! im=1..num_materials_vel 

       ! multigrid pressure
      do im=1,num_materials_vel

       write(matstr,'(I2)') im
       do i=1,2
        if (matstr(i:i).eq.' ') then
         matstr(i:i)='0'
        endif
       enddo

       ih=1
       Varname='P'
       ih=ih+1
       Varname(ih:ih)='M'
       ih=ih+1
       Varname(ih:ih)='G'
       ih=ih+1
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)
      enddo ! im=1..num_materials_vel 

      do im=1,num_materials_vel

       write(matstr,'(I2)') im
       do i=1,2
        if (matstr(i:i).eq.' ') then
         matstr(i:i)='0'
        endif
       enddo
       ih=1
       Varname='P'
       ih=ih+1
       Varname(ih:ih)='E'
       ih=ih+1
       Varname(ih:ih)='O'
       ih=ih+1
       Varname(ih:ih)='S'
       ih=ih+1
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)
      enddo ! im=1..num_materials_vel 

      do im=1,num_materials_vel

       write(matstr,'(I2)') im
       do i=1,2
        if (matstr(i:i).eq.' ') then
         matstr(i:i)='0'
        endif
       enddo
       ih=1
       Varname='D'
       ih=ih+1
       Varname(ih:ih)='I'
       ih=ih+1
       Varname(ih:ih)='V'
       ih=ih+1
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)
      enddo ! im=1..num_materials_vel 

      do im=1,num_materials_vel

       write(matstr,'(I2)') im
       do i=1,2
        if (matstr(i:i).eq.' ') then
         matstr(i:i)='0'
        endif
       enddo
       ih=1
       Varname='D'
       ih=ih+1
       Varname(ih:ih)='I'
       ih=ih+1
       Varname(ih:ih)='V'
       ih=ih+1
       Varname(ih:ih)='D'
       ih=ih+1
       Varname(ih:ih)='T'
       ih=ih+1
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)
      enddo ! im=1..num_materials_vel 

      do im=1,num_materials_vel

       write(matstr,'(I2)') im
       do i=1,2
        if (matstr(i:i).eq.' ') then
         matstr(i:i)='0'
        endif
       enddo
       ih=1
       Varname='M'
       ih=ih+1
       Varname(ih:ih)='C'
       ih=ih+1
       Varname(ih:ih)='H'
       ih=ih+1
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)
      enddo ! im=1..num_materials_vel 

       !VFRACS 
      do im=1,nmat

       write(matstr,'(I2)') im
       do i=1,2
        if (matstr(i:i).eq.' ') then
         matstr(i:i)='0'
        endif
       enddo

       ih=1
       Varname='F'
       ih=ih+1
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)
      enddo  ! im (volume fractions)

        ! levelset
      do imls=1,nmat
       im=imls
       im_opp=imls

       write(matstr,'(I2)') im
       do i=1,2
        if (matstr(i:i).eq.' ') then
         matstr(i:i)='0'
        endif
       enddo
       write(matstropp,'(I2)') im_opp
       do i=1,2
        if (matstropp(i:i).eq.' ') then
         matstropp(i:i)='0'
        endif
       enddo

       ih=1
       Varname='L'
       ih=ih+1
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       do i=1,2
        Varname(ih:ih)=matstropp(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)
      enddo  ! imls (levelset variables)

       ! levelset normals
      do imls=1,nmat
       im=imls
       im_opp=imls

       write(matstr,'(I2)') im
       do i=1,2
        if (matstr(i:i).eq.' ') then
         matstr(i:i)='0'
        endif
       enddo
       write(matstropp,'(I2)') im_opp
       do i=1,2
        if (matstropp(i:i).eq.' ') then
         matstropp(i:i)='0'
        endif
       enddo

       do dir=1,plot_sdim
        ih=1
        Varname='N'
        ih=ih+1
        if (dir.eq.1) then
         Varname(ih:ih)='X'
        else if (dir.eq.2) then
         Varname(ih:ih)='Y'
        else if ((dir.eq.3).and.(plot_sdim.eq.3)) then
         Varname(ih:ih)='Z'
        else
         print *,"dir invalid dumpstring_headers"
         stop
        endif
        ih=ih+1

        do i=1,2
         Varname(ih:ih)=matstr(i:i)
         ih=ih+1
        enddo
        do i=1,2
         Varname(ih:ih)=matstropp(i:i)
         ih=ih+1
        enddo
        call dumpstring(Varname)
       enddo  ! dir
      enddo  ! imls (levelset normal variables)

       ! density, temperature, mass fractions
      do im=1,nmat

       write(matstr,'(I2)') im
       do i=1,2
        if (matstr(i:i).eq.' ') then
         matstr(i:i)='0'
        endif
       enddo

        ! density
       ih=1
       Varname='D'
       ih=ih+1
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)

        ! temperature
       ih=1
       Varname='T'
       ih=ih+1
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)

       do ispec=1,num_species_var

        write(specstr,'(I2)') ispec
        do i=1,2
         if (specstr(i:i).eq.' ') then
          specstr(i:i)='0'
         endif
        enddo

        ih=1
        Varname='S'
        ih=ih+1
        do i=1,2
         Varname(ih:ih)=specstr(i:i)
         ih=ih+1
        enddo
        Varname(ih:ih)='-'
        ih=ih+1
        do i=1,2
         Varname(ih:ih)=matstr(i:i)
         ih=ih+1
        enddo
        call dumpstring(Varname)
   
       enddo  ! ispec

      enddo  ! im (state variables)

      do partid=1,num_materials_viscoelastic
       im=fort_im_elastic_map(partid)+1
       if ((im.ge.1).and.(im.le.nmat)) then
        write(matstr,'(I2)') im
        do i=1,2
         if (matstr(i:i).eq.' ') then
          matstr(i:i)='0'
         endif
        enddo

        do ispec=1,FORT_NUM_TENSOR_TYPE

         write(specstr,'(I2)') ispec
         do i=1,2
          if (specstr(i:i).eq.' ') then
           specstr(i:i)='0'
          endif
         enddo

         ih=1
         Varname='CT'
         ih=ih+2
         do i=1,2
          Varname(ih:ih)=specstr(i:i)
          ih=ih+1
         enddo
         Varname(ih:ih)='-'
         ih=ih+1
         do i=1,2
          Varname(ih:ih)=matstr(i:i)
          ih=ih+1
         enddo
         call dumpstring(Varname)

        enddo  ! ispec=1..num_tensor_type
       else
        print *,"im invalid60"
        stop
       endif
      enddo ! partid=1..num_materials_viscoelastic 

      Varname='XDISPLACE'
      call dumpstring(Varname)
      Varname='YDISPLACE'
      call dumpstring(Varname)
      if (SDIM.eq.3) then
       Varname='ZDISPLACE'
       call dumpstring(Varname)
      endif

       ! viscosity
      do im=1,nmat
       write(matstr,'(I2)') im
       do i=1,2
        if (matstr(i:i).eq.' ') then
         matstr(i:i)='0'
        endif
       enddo

       ih=1
       Varname='MU'
       ih=ih+2
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)
      enddo  ! im (viscosity variables)

       ! gamma_dot, TR(A), TR(A)*shear thinning factor, TR(A)*thin*f(A),
       ! vorticity
      do im=1,nmat
       write(matstr,'(I2)') im
       do i=1,2
        if (matstr(i:i).eq.' ') then
         matstr(i:i)='0'
        endif
       enddo

       ih=1
       Varname='DT'
       ih=ih+2
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)

       ih=1
       Varname='TR'
       ih=ih+2
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)

       ih=1
       Varname='TRT'
       ih=ih+3
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)

       ih=1
       Varname='TRTF'
       ih=ih+4
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)

       ih=1
       Varname='VORT'
       ih=ih+4
       do i=1,2
        Varname(ih:ih)=matstr(i:i)
        ih=ih+1
       enddo
       call dumpstring(Varname)

      enddo  ! im (trace variables)

      return
      end subroutine dumpstring_headers


      subroutine get_mach_number(tessellate, &
        vel,den,vof,mach,nmat)
      use MOF_routines_module
      use global_utility_module
      IMPLICIT NONE
 
      INTEGER_T, intent(in) :: tessellate
      INTEGER_T, intent(in) :: nmat
      REAL_T, intent(in) :: vel(num_materials_vel*(SDIM+1))
      REAL_T, intent(in) :: den(nmat*num_state_material)
      REAL_T, intent(in) :: vof(nmat)
      REAL_T, intent(out) :: mach(num_materials_vel)
      INTEGER_T dir
      REAL_T UMACH_local
      REAL_T test_vel
      REAL_T USOUND_local
      REAL_T den_local
      REAL_T temp_local
      REAL_T energy_local
      INTEGER_T im_primary,im
      INTEGER_T ispec
      REAL_T :: massfrac_parm(num_species_var+1)

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif
      if (num_materials_vel.ne.1) then
       print *,"num_materials_vel invalid"
       stop
      endif

      if (tessellate.eq.0) then
       call get_primary_material_VFRAC(vof,nmat,im_primary,4)
      else if (tessellate.eq.1) then
       im_primary=0
       do im=1,nmat
        if (im_primary.eq.0) then
         im_primary=im
        else if (vof(im).gt.vof(im_primary)) then
         im_primary=im
        endif
       enddo ! im 
      else
       print *,"tessellate invalid"
       stop
      endif
     
      if ((im_primary.lt.1).or.(im_primary.gt.nmat)) then
       print *,"im_primary invalid"
       stop
      endif
 
      UMACH_local=zero
      do dir=1,SDIM
       test_vel=vel(dir)
       UMACH_local=max(UMACH_local,abs(test_vel))
      enddo ! dir

      if (is_rigid(nmat,im_primary).eq.1) then

       USOUND_local=1.0D+20  ! these materials do not compress

      else if (is_rigid(nmat,im_primary).eq.0) then

       if (fort_material_type(im_primary).eq.0) then
        USOUND_local=1.0D+20  ! these materials do not compress
       else if ((fort_material_type(im_primary).ge.1).and. &
                (fort_material_type(im_primary).le.fort_max_num_eos)) then
        den_local=den((im_primary-1)*num_state_material+1)
        temp_local=den((im_primary-1)*num_state_material+2)

        call init_massfrac_parm(den_local,massfrac_parm,im_primary)
        do ispec=1,num_species_var
         massfrac_parm(ispec)=den((im_primary-1)*num_state_material+2+ispec)
        enddo

        call INTERNAL_material(den_local,massfrac_parm, &
         temp_local,energy_local, &
         fort_material_type(im_primary),im_primary)
        call SOUNDSQR_material(den_local,massfrac_parm, &
         energy_local, &
         USOUND_local, &
         fort_material_type(im_primary),im_primary)
        USOUND_local=sqrt(USOUND_local)
        if (USOUND_local.le.zero) then
         print *,"USOUND_local invalid"
         stop
        endif
       else 
        print *,"fort_material_type(im_primary) invalid"
        stop
       endif
      else
       print *,"is_rigid invalid"
       stop
      endif
      mach(1)=UMACH_local/USOUND_local

      return
      end subroutine get_mach_number 

      subroutine SEM_VISC_SANITY(caller_id,dt,xsten,nhalf, &
         flux_in,dir,velcomp,use_dt,use_HO,project_option,bfact, &
         enable_spectral,constant_viscosity)
      IMPLICIT NONE

      INTEGER_T, intent(in) :: caller_id
      INTEGER_T, intent(in) :: nhalf
      INTEGER_T, intent(in) :: dir
      INTEGER_T, intent(in) :: velcomp
      INTEGER_T, intent(in) :: use_dt
      INTEGER_T, intent(in) :: use_HO
      INTEGER_T, intent(in) :: project_option
      INTEGER_T, intent(in) :: bfact
      INTEGER_T, intent(in) :: enable_spectral
      INTEGER_T, intent(in) :: constant_viscosity
      REAL_T, intent(in) :: xsten(-nhalf:nhalf,SDIM)
      REAL_T, intent(in) :: dt
      REAL_T, intent(in) :: flux_in
      REAL_T :: x,y,z
      REAL_T :: f_sinx,f_siny,f_cosx,f_cosy
      REAL_T :: ux(SDIM),uy(SDIM),uxx(SDIM)
      REAL_T :: flux_exact
      REAL_T :: flux_exact_tensor
      REAL_T :: flux_err,flux_tol

      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)

      if (bfact.ge.1) then
       ! do nothing
      else
       print *,"bfact invalid200"
       stop
      endif

      if (dt.gt.zero) then
       ! do nothing
      else
       print *,"dt invalid SEM_VISC_SANITY"
       stop
      endif
      if (nhalf.ge.1) then
       ! do nothing
      else
       print *,"nhalf invalid SEM_VISC_SANITY"
       stop
      endif
      if (abs(x)+abs(y)+abs(z).le.1.0D+21) then
       ! do nothing
      else
       print *,"x,y,z overflow in SEM_VISC_SANITY"
       stop
      endif
      if (abs(flux_in).le.1.0D+20) then
       ! do nothing
      else
       print *,"flux_in overflow SEM_VISC_SANITY"
       print *,"caller_id=",caller_id
       print *,"dt=",dt
       print *,"dir=",dir
       print *,"flux_in=",flux_in
       print *,"velcomp=",velcomp
       print *,"use_dt=",use_dt
       print *,"use_HO=",use_HO
       print *,"project_option=",project_option
       print *,"bfact=",bfact
       print *,"enable_spectral=",enable_spectral
       print *,"constant_viscosity=",constant_viscosity
       stop
      endif
      if ((dir.eq.-1).or. &
          (dir.eq.1).or. &
          (dir.eq.2).or. &
          (dir.eq.SDIM)) then
       ! do nothing
      else 
       print *,"dir invalid in SEM_VISC_SANITY"
       stop
      endif
      if ((use_HO.eq.0).or.(use_HO.eq.1)) then
       ! do nothing
      else
       print *,"use_HO invalid"
       stop
      endif

      if ((enable_spectral.eq.1).or. &
          (enable_spectral.eq.2)) then
       ! do nothing (HO space)
      else if ((enable_spectral.eq.0).or. &
               (enable_spectral.eq.3)) then
       ! do nothing (LO space)
      else
       print *,"enable_spectral invalid"
       stop
      endif

      if ((constant_viscosity.eq.0).or.(constant_viscosity.eq.1)) then
       if (dir.eq.-1) then
        if (constant_viscosity.eq.1) then
         ! do nothing
        else
         print *,"constant_viscosity invalid"
         stop
        endif
       else if ((dir.ge.1).and.(dir.le.SDIM)) then
        ! do nothing
       else
        print *,"dir invalid"
        stop
       endif
      else
       print *,"constant_viscosity invalid"
       stop
      endif

      if ((velcomp.ge.1).and.(velcomp.le.SDIM)) then
       ! do nothing
      else
       print *,"velcomp invalid"
       stop
      endif
      if ((use_dt.eq.0).or.(use_dt.eq.1)) then
       ! do nothing
      else
       print *,"use_dt invalid in SEM_VISC_SANITY"
       stop
      endif

      if ((project_option.eq.0).or. &
          (project_option.eq.1).or. &
          (project_option.eq.10).or. &
          (project_option.eq.11).or. &
          (project_option.eq.12).or. & ! pressure extrapolation
          (project_option.eq.13).or. &
          (project_option.eq.3).or. &
          (project_option.eq.2).or. &
          ((project_option.ge.100).and. &
           (project_option.lt.100+num_species_var))) then
         ! do nothing
      else
       print *,"project_option invalid in SEM_VISC_SANITY"
       stop
      endif

      if (1.eq.0) then
       if ((probtype.eq.26).and. &
           (axis_dir.eq.11).and. &
           (project_option.eq.3).and. &
           (SDIM.eq.2)) then
         ! u=-f_sinx * f_cosy
         ! v=f_cosx  * f_siny
        f_sinx=sin(two*Pi*x)
        f_siny=sin(two*Pi*y)
        f_cosx=cos(two*Pi*x)
        f_cosy=cos(two*Pi*y)
        ux(1)=-two*Pi*f_cosx*f_cosy
        uy(1)=two*Pi*f_sinx*f_siny
        ux(2)=-two*Pi*f_sinx*f_siny
        uy(2)=two*Pi*f_cosx*f_cosy
        uxx(1)=eight*(Pi**2)*f_sinx*f_cosy
        uxx(2)=-eight*(Pi**2)*f_cosx*f_siny
          ! 2D=( 2 ux     uy+vx
          !      uy+vx    2 vy  )
        if (dir.eq.1) then
         flux_exact=ux(velcomp)
         if (velcomp.eq.1) then
          flux_exact_tensor=two*ux(velcomp)
         else if (velcomp.eq.2) then
          flux_exact_tensor=ux(2)+uy(1)
         else
          print *,"velcomp invalid"
          stop
         endif
        else if (dir.eq.2) then
         flux_exact=uy(velcomp)
         if (velcomp.eq.2) then
          flux_exact_tensor=two*uy(velcomp)
         else if (velcomp.eq.1) then
          flux_exact_tensor=ux(2)+uy(1)
         else
          print *,"velcomp invalid"
          stop
         endif
        else if (dir.eq.-1) then
         flux_exact=uxx(velcomp)
         flux_exact_tensor=flux_exact
        else
         print *,"dir invalid"
         stop
        endif
        if (use_dt.eq.0) then
         ! do nothing
        else if (use_dt.eq.1) then
         flux_exact=-dt*fort_viscconst(1)*flux_exact
         flux_exact_tensor=-dt*fort_viscconst(1)*flux_exact_tensor
        else
         print *,"use_dt invalid"
         stop
        endif
        if ((caller_id.eq.2).or. &
            (caller_id.eq.3).or. &
            (caller_id.eq.4).or. &
            (caller_id.eq.5)) then
         if (constant_viscosity.eq.1) then
          flux_err=abs(flux_exact-flux_in)
         else if (constant_viscosity.eq.0) then
          flux_err=abs(flux_exact_tensor-flux_in)
         else
          print *,"constant_viscosity invalid"
          stop
         endif
        else
         flux_err=abs(flux_exact-flux_in)
        endif

        print *,"caller_id, dir, velcomp, use_dt ", &
         caller_id,dir,velcomp,use_dt
        print *,"dt,x,y,z,visc ",dt,x,y,z,fort_viscconst(1)
        print *,"flux_in, flux_exact, flux_err ", &
         flux_in,flux_exact,flux_err
        if ((bfact.eq.1).or. &
            (use_HO.eq.0).or. &
            (enable_spectral.eq.0).or. &
            (enable_spectral.eq.3)) then
         flux_tol=1.0D-2
        else if (bfact.eq.2) then
         flux_tol=1.0D-2
        else if (bfact.eq.4) then
         flux_tol=1.0D-2
        else if (bfact.eq.8) then
         flux_tol=1.0D-4
        else if (bfact.eq.16) then
         flux_tol=1.0D-5
        else
         print *,"bfact invalid200"
         stop
        endif

        if (flux_err.gt.flux_tol) then
         print *,"flux_err too large: err,tol ",flux_err,flux_tol
         stop
        endif
       endif
      endif

      return
      end subroutine SEM_VISC_SANITY


      subroutine SEM_VISC_SANITY_CC(caller_id,dt,CC,MSKDV,MSKRES,MDOT, &
        VOLTERM,project_option,xsten,nhalf,velcomp)
      IMPLICIT NONE

      INTEGER_T, intent(in) :: caller_id
      INTEGER_T, intent(in) :: nhalf
      INTEGER_T, intent(in) :: velcomp
      INTEGER_T, intent(in) :: project_option
      REAL_T, intent(in) :: xsten(-nhalf:nhalf,SDIM)
      REAL_T, intent(in) :: dt
      REAL_T, intent(in) :: CC
      REAL_T, intent(in) :: MSKDV
      REAL_T, intent(in) :: MSKRES
      REAL_T, intent(in) :: MDOT
      REAL_T, intent(in) :: VOLTERM
      REAL_T :: VOLTERM_check
      REAL_T :: CC_check
      INTEGER_T :: dir

      if (dt.gt.zero) then
       ! do nothing
      else
       print *,"dt invalid SEM_VISC_SANITY_CC:",dt
       stop
      endif
      if (nhalf.ge.1) then
       ! do nothing
      else
       print *,"nhalf invalid SEM_VISC_SANITY_CC:",nhalf
       stop
      endif
      if ((velcomp.ge.1).and.(velcomp.le.SDIM)) then
       ! do nothing
      else
       print *,"velcomp invalid SEM_VISC_SANITY_CC:",velcomp
       stop
      endif
      if ((project_option.eq.0).or. &
          (project_option.eq.1).or. &
          (project_option.eq.10).or. &
          (project_option.eq.11).or. &
          (project_option.eq.12).or. & ! pressure extrapolation
          (project_option.eq.13).or. &
          (project_option.eq.3).or. &
          (project_option.eq.2).or. &
          ((project_option.ge.100).and. &
           (project_option.lt.100+num_species_var))) then
         ! do nothing
      else
       print *,"project_option invalid in SEM_VISC_SANITY_CC"
       stop
      endif
      if (CC.ge.zero) then
       ! do nothing
      else
       print *,"CC invalid in SEM_VISC_SANITY_CC:",CC
       stop
      endif
      if ((MSKDV.eq.zero).or.(MSKDV.eq.one)) then
       ! do nothing
      else
       print *,"MSKDV invalid: SEM_VISC_SANITY_CC:",MSKDV
       stop
      endif
      if ((MSKRES.eq.zero).or.(MSKRES.eq.one)) then
       ! do nothing
      else
       print *,"MSKRES invalid: SEM_VISC_SANITY_CC:",MSKRES
       stop
      endif
      if (abs(MDOT).le.1.0D+20) then
       ! do nothing
      else
       print *,"MDOT overflow: SEM_VISC_SANITY_CC:",MDOT
       stop
      endif
      if (VOLTERM.gt.zero) then
       ! do nothing
      else
       print *,"VOLTERM invalid: SEM_VISC_SANITY_CC:",VOLTERM
       stop
      endif

      if (1.eq.0) then
       if ((probtype.eq.26).and. &
           (axis_dir.eq.11).and. &
           (fort_viscconst(1).gt.zero).and. &
           (SDIM.eq.2)) then
         ! u=-f_sinx * f_cosy
         ! v=f_cosx  * f_siny
        VOLTERM_check=one
        do dir=1,SDIM
         VOLTERM_check=VOLTERM_check*(xsten(1,dir)-xsten(-1,dir))
        enddo
        if (abs(VOLTERM-VOLTERM_check).le.1.0D-10*VOLTERM_check) then
         ! do nothing
        else
         print *,"VOLTERM invalid"
         stop
        endif
        if (project_option.eq.3) then
         CC_check=VOLTERM/dt
         if (abs(CC-CC_check).le.1.0D-10*CC_check) then
          ! do nothing
         else
          print *,"CC invalid"
          stop
         endif
         if ((MSKDV.eq.one).and. &
             (MSKRES.eq.one)) then
          ! do nothing
         else
          print *,"MSKDV or MSKRES invalid"
          print *,"MSKDV= ",MSKDV
          print *,"MSKRES= ",MSKRES
          stop
         endif
        endif

       endif

      endif

      return
      end subroutine SEM_VISC_SANITY_CC


      subroutine get_flux_factor(operator_id,im1,im2,coef)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T operator_id,im1,im2,imspec,nmat
      REAL_T coef,k1,k2

      nmat=num_materials

      if (operator_id.eq.1) then
       print *,"stokes flow not ready yet"
       stop
      else if (operator_id.eq.0) then
       k1=get_user_heatviscconst(im1)
       k2=get_user_heatviscconst(im2)
      else if ((operator_id.ge.100).and. &
               (operator_id.lt.100+num_species_var)) then
       imspec=operator_id-100+1
       k1=fort_speciesviscconst((imspec-1)*nmat+im1)
       k2=fort_speciesviscconst((imspec-1)*nmat+im2)
      else
       print *,"operator_id invalid"
       stop
      endif
      if ((k1.lt.zero).or.(k2.lt.zero)) then
       print *,"coefficient invalid"
       stop
      else if ((k1.eq.zero).or.(k2.eq.zero)) then
       coef=zero
       print *,"zero diffusivity not allowed!"
       print *,"make the diffusivity a very small number"
       print *,"no object is a perfect conductor"
       stop
      else
       coef=two*k1*k2/(k1+k2)
      endif

      return
      end subroutine get_flux_factor


       ! called from init_icemask (GODUNOV_3D.F90) and
       !             tagexpansion (GODUNOV_3D.F90)
       ! input: LS, latent_heat, distribute_from_target
       ! output: icemask,icefacecut,im,im_opp,ireverse
      subroutine get_icemask( &
        xtarget, &
        time, &
        dx,bfact, &
        icemask, &
        icefacecut, &
        im,im_opp, &
        ireverse, &
        LS, &
        latent_heat, &
        distribute_from_target, &
        nmat,nten)
      use global_utility_module
      use MOF_routines_module
      IMPLICIT NONE

      REAL_T, intent(in) :: xtarget(SDIM)
      REAL_T, intent(in) :: time
      INTEGER_T, intent(in) :: nmat
      INTEGER_T, intent(in) :: nten
      INTEGER_T nten_test
      INTEGER_T, intent(out) :: im
      INTEGER_T, intent(out) :: im_opp
      INTEGER_T, intent(out) :: ireverse
      INTEGER_T, intent(in) :: bfact
      REAL_T, intent(in) :: dx(SDIM)
      REAL_T, intent(out) :: icemask
      REAL_T, intent(out) :: icefacecut
      REAL_T, intent(in) :: LS(nmat)
      REAL_T, intent(in) :: latent_heat(2*nten)
      INTEGER_T, intent(in) :: distribute_from_target(2*nten)

      REAL_T H_ICE,H_WATER
      REAL_T eps_thick
      REAL_T dxmaxLS
      REAL_T dist_mask_override
      INTEGER_T im_primary
      INTEGER_T im_secondary
      INTEGER_T im_tertiary
      INTEGER_T im_ice
      INTEGER_T im_FSI_rigid
      INTEGER_T im_dest,im_source
      INTEGER_T iten
      REAL_T LL(0:1)

      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif

      if ((ICEFACECUT_EPS.ge.zero).and. &
          (ICEFACECUT_EPS.le.0.1)) then
       ! do nothing
      else 
       print *,"ICEFACECUT_EPS out of range"
       stop
      endif

      if ((FORT_MUSHY_THICK.ge.one).and. &
          (FORT_MUSHY_THICK.le.four)) then
       ! do nothing
      else
       print *,"MUSHY_THICK invalid"
       stop
      endif

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif
      nten_test=( (nmat-1)*(nmat-1)+nmat-1 )/2
      if (nten_test.ne.nten) then
       print *,"nten invalid get_icemask nten, nten_test ",nten,nten_test
       stop
      endif

      call get_dxmaxLS(dx,bfact,dxmaxLS)

      eps_thick=FORT_MUSHY_THICK*dxmaxLS
      if (SDIM.eq.2) then
       eps_thick=eps_thick*sqrt(two)
      else if (SDIM.eq.3) then
       eps_thick=eps_thick*sqrt(three)
      else
       print *,"dimension bust"
       stop
      endif

        ! we are in "get_icemask"

      call get_primary_material(LS,nmat,im_primary)
      call get_secondary_material(LS,nmat,im_primary,im_secondary)

      if ((im_secondary.ge.1).and. &
          (im_secondary.le.nmat)) then
       call get_tertiary_material(LS,nmat, &
         im_primary,im_secondary,im_tertiary)
      else
       print *,"im_secondary invalid"
       stop
      endif
      if ((im_tertiary.ge.0).and.(im_tertiary.le.nmat)) then
       ! do nothing
      else
       print *,"im_tertiary invalid"
       stop
      endif

      if (im_primary.eq.im_secondary) then
       print *,"im_primary.eq.im_secondary"
       stop
      else if (im_primary.eq.im_tertiary) then
       print *,"im_primary.eq.im_tertiary"
       stop
      else if (im_primary.lt.im_secondary) then
       im=im_primary
       im_opp=im_secondary
      else if (im_primary.gt.im_secondary) then
       im_opp=im_primary
       im=im_secondary
      else
       print *,"im_primary or im_secondary invalid"
       stop
      endif

      call get_iten(im,im_opp,iten,nmat)
      do ireverse=0,1
       LL(ireverse)=latent_heat(iten+ireverse*nten)
      enddo

      if ((is_ice(nmat,im).eq.0).and. &
          (is_ice(nmat,im_opp).eq.0)) then
       im_ice=0
      else if ((is_ice(nmat,im).eq.1).and. &
               (is_ice(nmat,im_opp).eq.0)) then
       im_ice=im
      else if ((is_ice(nmat,im).eq.0).and. &
               (is_ice(nmat,im_opp).eq.1)) then
       im_ice=im_opp
      else if ((is_ice(nmat,im).eq.1).and. &
               (is_ice(nmat,im_opp).eq.1)) then
       im_ice=im_primary
      else
       print *,"is_ice invalid"
       stop
      endif
     
      if ((is_FSI_rigid(nmat,im).eq.0).and. &
          (is_FSI_rigid(nmat,im_opp).eq.0)) then
       im_FSI_rigid=0
      else if ((is_FSI_rigid(nmat,im).eq.1).and. &
               (is_FSI_rigid(nmat,im_opp).eq.0)) then
       im_FSI_rigid=im
      else if ((is_FSI_rigid(nmat,im).eq.0).and. &
               (is_FSI_rigid(nmat,im_opp).eq.1)) then
       im_FSI_rigid=im_opp
      else if ((is_FSI_rigid(nmat,im).eq.1).and. &
               (is_FSI_rigid(nmat,im_opp).eq.1)) then
       im_FSI_rigid=im_primary
      else
       print *,"is_FSI_rigid invalid"
       stop
      endif

      if (im_FSI_rigid.eq.im_primary) then

       ireverse=-1
       icemask=zero
       icefacecut=ICEFACECUT_EPS

      else if ((im_FSI_rigid.ge.0).and. &
               (im_FSI_rigid.le.nmat).and. &
               (im_FSI_rigid.ne.im_primary)) then

        ! either the primary or secondary material is "ice"
       if ((im_ice.ge.1).and.(im_ice.le.nmat)) then 

        if ((LL(0).eq.zero).and.(LL(1).eq.zero)) then
         if ((im_tertiary.ge.1).and. &
             (im_tertiary.le.nmat)) then
          if (is_rigid(nmat,im_tertiary).eq.0) then
           if (is_FSI_rigid(nmat,im_tertiary).eq.0) then
            if (is_ice(nmat,im_tertiary).eq.0) then
             if (im_ice.lt.im_tertiary) then
              im=im_ice
              im_opp=im_tertiary
             else if (im_ice.gt.im_tertiary) then
              im_opp=im_ice
              im=im_tertiary
             else
              print *,"im_ice or im_tertiary invalid"
              stop
             endif
             call get_iten(im,im_opp,iten,nmat)
             do ireverse=0,1
              LL(ireverse)=latent_heat(iten+ireverse*nten)
             enddo
            else if (is_ice(nmat,im_tertiary).eq.1) then
             ! do nothing
            else
             print *,"is_ice(nmat,im_tertiary) invalid"
             stop
            endif
           else if (is_FSI_rigid(nmat,im_tertiary).eq.1) then
            ! do nothing
           else
            print *,"is_FSI_rigid(nmat,im_tertiary) invalid"
            stop
           endif
          else
           print *,"is_rigid(nmat,im_tertiary) invalid"
           stop
          endif
         else if (im_tertiary.eq.0) then
          ! do nothing
         else
          print *,"im_tertiary invalid"
          stop
         endif
        else if ((LL(0).ne.zero).or.(LL(1).ne.zero)) then
         ! do nothing
        else
         print *,"LL invalid"
         stop
        endif

        if ((LL(0).eq.zero).and.(LL(1).eq.zero)) then
         ireverse=-1
         if (is_ice(nmat,im_primary).eq.1) then
          icemask=zero
          icefacecut=ICEFACECUT_EPS
         else if (is_ice(nmat,im_primary).eq.0) then
          icemask=one
          icefacecut=one
         else
          print *,"is_ice(nmat,im_primary) invalid"
          stop
         endif
        else if ((LL(0).ne.zero).and.(LL(1).eq.zero)) then
         ireverse=0
         im_source=im
         im_dest=im_opp
        else if ((LL(0).eq.zero).and.(LL(1).ne.zero)) then
         ireverse=1
         im_source=im_opp
         im_dest=im
        else if ((LL(0).ne.zero).and.(LL(1).ne.zero)) then
         if (LS(im).ge.LS(im_opp)) then
          ireverse=0
          im_source=im
          im_dest=im_opp
         else if (LS(im_opp).ge.LS(im)) then
          ireverse=1
          im_source=im_opp
          im_dest=im
         else
          print *,"im_primary invalid"
          stop
         endif
        else
         print *,"LL invalid"
         stop
        endif
   
        if (ireverse.eq.-1) then
         ! do nothing
        else if ((ireverse.eq.0).or. &
                 (ireverse.eq.1)) then

         if (im_ice.eq.im_dest) then  ! freezing

          if (distribute_from_target(iten+nten*ireverse).eq.0) then
           ! do nothing
          else if (distribute_from_target(iten+nten*ireverse).eq.1) then
           eps_thick=zero
          else
           print *,"distribute_from_target(iten+nten*ireverse) bad"
           stop
          endif

          ! dist_mask_override>0 in the substrate. (dest is ice)  this routine
          ! tells one whether to force mask=0
          call icemask_override(xtarget,im_source,im_dest,dist_mask_override)
          if (dist_mask_override.ge.-eps_thick) then
           if ((dist_mask_override.ge.zero).or. &
               (im_dest.eq.im_primary)) then
            icemask=zero  ! mask off this cell.
           else
            icemask=one   ! do nothing
           endif
          else
           ! icemask=0 in the bulk ice regions
           ! icemask=1 in the bulk liquid regions
           ! icemask=0 in the ice regions away from liquid.
           ! icemask=1 otherwise
           H_ICE=hs(LS(im_ice),eps_thick)
           H_WATER=hs(LS(im_source),eps_thick)
           icemask=one-H_ICE
           if (H_ICE.gt.zero) then
            icemask=icemask*H_WATER
           endif
          endif

         else if (im_ice.eq.im_source) then ! melting

          if (distribute_from_target(iten+nten*ireverse).eq.0) then
           eps_thick=zero
          else if (distribute_from_target(iten+nten*ireverse).eq.1) then
           ! do nothing
          else
           print *,"distribute_from_target(iten+nten*ireverse) bad"
           stop
          endif

          H_ICE=hs(LS(im_ice),eps_thick)
          H_WATER=hs(LS(im_dest),eps_thick)
          icemask=one-H_ICE
          if (H_ICE.gt.zero) then
           icemask=icemask*H_WATER
          endif

         else
          print *,"im_ice invalid"
          stop
         endif

         if (icemask.le.-VOFTOL) then
          print *,"icemask underflow"
          stop
         else if ((icemask.ge.-VOFTOL).and.(icemask.le.zero)) then
          icemask=zero
         else if ((icemask.ge.zero).and.(icemask.le.one)) then
          ! do nothing
         else if ((icemask.ge.one).and.(icemask.lt.one+VOFTOL)) then
          icemask=one
         else
          print *,"icemask overflow"
          stop
         endif

         if (im_ice.eq.im_dest) then ! freezing
          if (dist_mask_override.ge.zero) then ! in a substrate
           icefacecut=zero
          else if ((icemask+ICEFACECUT_EPS.gt.zero).and. &
                   (icemask+ICEFACECUT_EPS.lt.one)) then
           icefacecut=icemask+ICEFACECUT_EPS
          else if (icemask+ICEFACECUT_EPS.ge.one) then
           icefacecut=one
          else
           print *,"icemask invalid"
           stop
          endif
         else if (im_ice.eq.im_source) then ! melting
 
          if ((icemask+ICEFACECUT_EPS.gt.zero).and. &
              (icemask+ICEFACECUT_EPS.lt.one)) then
           icefacecut=icemask+ICEFACECUT_EPS
          else if (icemask+ICEFACECUT_EPS.ge.one) then
           icefacecut=one
          else
           print *,"icemask invalid"
           stop
          endif

         else
          print *,"im_ice invalid"
          stop
         endif

        else
         print *,"ireverse invalid"
         stop
        endif
 
       else if (im_ice.eq.0) then
        ireverse=-1
        icemask=one
        icefacecut=one
       else
        print *,"im_ice invalid"
        stop
       endif

      else
       print *,"im_FSI_rigid invalid"
       stop
      endif
   
      if (icemask.lt.zero) then
       print *,"icemask invalid"
       stop
      else if (icemask.eq.zero) then
       ! do nothing
      else if ((icemask.gt.zero).and.(icemask.le.one)) then
       icemask=one
      else
       print *,"icemask invalid"
       stop
      endif
      if ((icefacecut.ge.zero).and.(icefacecut.le.one)) then
       ! do nothing
      else
       print *,"icefacecut invalid"
       stop
      endif
 
      return
      end subroutine get_icemask

       ! MEHDI VAHAB HEAT SOURCE
       ! T^new=T^* + dt * (Q)/(rho cv)
       ! Q units: J/(m^3 s)
       ! called from: GODUNOV_3D.F90, subroutine FORT_HEATSOURCE
       ! in FORT_HEATSOURCE:
       ! T_local(im)=T_local(im)+ &
       !   dt*DeDTinverse(D_DECL(i,j,k),1)*heat_source_total  im=1..nmat

      subroutine get_local_heat_source( &
       time,dt, &
       nmat, &
       x, &
       xsten, &  ! xsten(-nhalf:nhalf,SDIM)
       nhalf, &
       temperature_source, &  ! inputs file variable; default = 0.0
       temperature_source_cen, &
       temperature_source_rad, &
       LS,VFRAC,TEMPERATURE,DENSITY, &
       CV, &
       HEAT_SOURCE_OUT)
      use global_utility_module
      use global_distance_module
      use USERDEF_module
      use CAV3D_module
      use HELIX_module
      use TSPRAY_module
      use CAV2Dstep_module
      use ZEYU_droplet_impact_module
      use rigid_FSI_module
      IMPLICIT NONE

      REAL_T, intent(in) :: time,dt
      INTEGER_T, intent(in) :: nmat
      INTEGER_T, intent(in) :: nhalf
      REAL_T, intent(in) :: x(SDIM)
      REAL_T, intent(in) :: xsten(-nhalf:nhalf,SDIM)
      REAL_T, intent(in) :: temperature_source
      REAL_T, intent(in) :: temperature_source_cen(SDIM)
      REAL_T, intent(in) :: temperature_source_rad(SDIM)
      REAL_T, intent(in) :: LS(nmat)
      REAL_T, intent(in) :: VFRAC(nmat)
      REAL_T, intent(in) :: TEMPERATURE(nmat)
      REAL_T, intent(in) :: DENSITY(nmat)
      REAL_T, intent(in) :: CV(nmat)
      REAL_T, intent(out) :: HEAT_SOURCE_OUT(nmat)
      REAL_T dist
      REAL_T dist_gas
      REAL_T eta,depth,xs,ys,zs,phiE
      REAL_T alpha_absorp,p_laser,r0,v_laser,xi,sigma_rad,eps_rad,hc
      REAL_T T_chill
      REAL_T time_unit
      INTEGER_T im 
      REAL_T vfrac_cutoff
      REAL_T dist_cutoff
      INTEGER_T localdir,inbox
      REAL_T xlo,xhi

      ! eta: absorption efficiency
      ! phiE: electron beam diameter
      ! xs,ys,zs: center of electronic beam 

      vfrac_cutoff=0.1  ! was 0.99
      dist_cutoff=-1.0e+10 ! was 0.0

      depth=0.0062
      eta=0.9
      phiE=0.055 ! cm
      xs=0.5+7.0*sin(2.0*Pi*5.0*time)**3
      ys=0.5*floor(time*5.0)
      zs=zero

      alpha_absorp=3.0  ! was 0.3
      p_laser=100.0
      v_laser=1.25
      r0=3.5e-5
      xi=5.0e-6
      sigma_rad=5.67e-8
      eps_rad=1.0
      hc=100.0

      if (time.lt.zero) then
       print *,"time invalid"
       stop
      endif
      if (dt.le.zero) then
       print *,"dt invalid"
       stop
      endif
      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif
      if (temperature_source.lt.zero) then
       print *,"temperature_source invalid"
       stop
      endif
      do im=1,nmat
       if ((VFRAC(im).lt.-VOFTOL).or. &
           (VFRAC(im).ge.one+VOFTOL)) then
        print *,"VFRAC invalid"
        stop
       endif 
       if (DENSITY(im).le.zero) then
        print *,"DENSITY must be positive"
        stop
       endif
       if (TEMPERATURE(im).le.zero) then
        print *,"TEMPERATURE must be positive"
        stop
       endif
       if (CV(im).le.zero) then
        print *,"CV must be positive"
        stop
       endif
       HEAT_SOURCE_OUT(im)=zero

       if (is_in_probtype_list().eq.1) then

        call SUB_HEATSOURCE(im,VFRAC,time, &
               x, &
               xsten, & ! xsten(-nhalf:nhalf,SDIM)
               nhalf, &
               TEMPERATURE, &
               HEAT_SOURCE_OUT(im),DENSITY,CV,dt, &
               num_materials)

       else if (probtype.eq.411) then

        call CAV3D_HEATSOURCE(im,VFRAC,time, &
               x, &
               TEMPERATURE, &
               HEAT_SOURCE_OUT(im),DENSITY,CV,dt)

       else if (probtype.eq.401) then

        call HELIX_HEATSOURCE(im,VFRAC,time,x,TEMPERATURE, &
               HEAT_SOURCE_OUT(im),DENSITY,CV,dt)

       else if (probtype.eq.402) then
      
        call TSPRAY_HEATSOURCE(im,VFRAC,time,x,TEMPERATURE, &
               HEAT_SOURCE_OUT(im),DENSITY,CV,dt)

       else if (probtype.eq.533) then

        call rigid_FSI_HEATSOURCE(im,VFRAC,time,x,TEMPERATURE, &
            HEAT_SOURCE_OUT(im),DENSITY,CV,dt)

       else if (probtype.eq.311) then ! sample user defined call

        call USERDEF_HEATSOURCE(im,VFRAC,time,x,TEMPERATURE, &
               HEAT_SOURCE_OUT(im),DENSITY,CV,dt)

       else if ((probtype.eq.299).or. &
                (probtype.eq.301)) then ! melting or additive manufacturing
        if (im.eq.3) then ! metal
         if ((radblob3.lt.zero).or.(radblob3.gt.radblob)) then
          print *,"radblob3 invalid"
          stop
         endif
         if (probtype.eq.299) then
          call INIT_LS_SOLID_MELT(x(1),x(2),x(SDIM),time,dist)  !>0 in solid
          call INIT_LS_GAS_MELT(x(1),x(2),x(SDIM),time,dist_gas)  !>0 in gas
         else if (probtype.eq.301) then
          call INIT_LS_SOLID_AM(x(1),x(2),x(SDIM),time,dist)  !>0 in solid
          call INIT_LS_GAS_AM(x(1),x(2),x(SDIM),time,dist_gas)  !>0 in gas
         else
          print *,"probtype invalid"
          stop
         endif

         if (axis_dir.eq.0) then

          if ((dist.gt.radblob-radblob3).and. &
              (vfrac(im).ge.vfrac_cutoff)) then
           if (TEMPERATURE(im).lt.fort_tempconst(im)) then
            HEAT_SOURCE_OUT(im)=(fort_tempconst(im)-TEMPERATURE(im))* &
             DENSITY(im)*CV(im)/dt 
           endif 
          endif ! dist>radblob-radblob3

         else if (axis_dir.eq.1) then

          if ((dist.gt.dist_cutoff).and. &
              (VFRAC(im).ge.vfrac_cutoff)) then 
!           time_unit=dt
           time_unit=one
           HEAT_SOURCE_OUT(im)=(alpha_absorp*p_laser/(Pi*r0*r0)* & 
            exp(-2.0*(x(1)-50.0e-6)**2/(r0*r0)))
           !- & 
           !sigma_rad*eps_rad*(TEMPERATURE(im)**4-300.0**4)- &
           !hc*(TEMPERATURE(im)-300.0))*DENSITY(im)*CV(im)/dt

           !INTENSITY=max(0.0, (-2.25*dist*dist/(depth*depth) & 
           !           +1.5*dist/depth+0.75)/0.75)
           !HS=exp(-2.0*(x-xs)*(x-xs)/(phiE*phiE))           
           !HEAT_SOURCE_OUT(im)=2.0*60.0*6.7/(Pi*phiE*phiE)* &
           !     DENSITY(im)*CV(im)*eta*HS*INTENSITY/depth/dt
          endif ! dist>dist_cutoff and vfrac>vfrac_cutoff?
         else if (axis_dir.eq.2) then

          if (VFRAC(im).ge.vfrac_cutoff) then
!           time_unit=dt
           time_unit=one
           HEAT_SOURCE_OUT(im)=alpha_absorp*p_laser/(Pi*r0*r0*r0)* &
            exp(-2.0*(x(1)-time*v_laser-xi)**2/(r0*r0)) - &
            sigma_rad*eps_rad*(TEMPERATURE(im)**4-300.0**4)- &
            hc*(TEMPERATURE(im)-300.0)
           if (HEAT_SOURCE_OUT(im).lt.zero) then
            HEAT_SOURCE_OUT(im)=zero
           endif
          endif ! vfrac>vfrac_cutoff?

         else if (axis_dir.eq.3) then

          if ((dist.gt.radblob-radblob3).and. &
              (vfrac(im).ge.vfrac_cutoff)) then
           if (TEMPERATURE(im).lt.fort_tempconst(im)) then
            HEAT_SOURCE_OUT(im)=(fort_tempconst(im)-TEMPERATURE(im))* &
             DENSITY(im)*CV(im)/dt
           endif
          endif ! dist>radblob-radblob3

         else
          print *,"axis_dir invalid"
          stop
         endif

        else if (im.eq.1) then ! melt

         if (axis_dir.eq.0) then
          ! do nothing
         else if (axis_dir.eq.1) then

          if ((radblob3.lt.zero).or.(radblob3.gt.radblob)) then
           print *,"radblob3 invalid"
           stop
          endif
          if (probtype.eq.299) then
           call INIT_LS_LIQUID_MELT(x(1),x(2),x(SDIM),time,dist)  !>0 in melt
          else if (probtype.eq.301) then
           call INIT_LS_LIQUID_AM(x(1),x(2),x(SDIM),time,dist)  !>0 in melt
          else
           print *,"probtype invalid"
           stop
          endif

           ! inside the liquid metal
          if ((dist.gt.dist_cutoff).and. &
              (vfrac(im).ge.vfrac_cutoff)) then 
           HEAT_SOURCE_OUT(im)=(alpha_absorp*p_laser/(Pi*r0*r0)* &
              exp(-2.0*(x(1)-50.0e-6)**2/(r0*r0)))
          endif ! dist>dist_cutoff and F>vfrac_cutoff in melt 

         else if (axis_dir.eq.2) then

          if ((radblob3.lt.zero).or.(radblob3.gt.radblob)) then
           print *,"radblob3 invalid"
           stop
          endif
          if (probtype.eq.299) then
           call INIT_LS_LIQUID_MELT(x(1),x(2),x(SDIM),time,dist)  !>0 in melt
          else if (probtype.eq.301) then
           call INIT_LS_LIQUID_AM(x(1),x(2),x(SDIM),time,dist)  !>0 in melt
          else
           print *,"probtype invalid"
           stop
          endif

           ! inside the liquid metal
          if ((dist.gt.dist_cutoff).and. &
              (vfrac(im).ge.vfrac_cutoff)) then

           HEAT_SOURCE_OUT(im)=alpha_absorp*p_laser/(Pi*r0*r0*r0)* &
            exp(-2.0*(x(1)-time*v_laser-xi)**2/(r0*r0)) - &
            sigma_rad*eps_rad*(TEMPERATURE(im)**4-300.0**4)- &
            hc*(TEMPERATURE(im)-300.0)
           if (HEAT_SOURCE_OUT(im).lt.zero) then
            HEAT_SOURCE_OUT(im)=zero
           endif
          endif ! dist>dist_cutoff and F>vfrac_cutoff in melt 

         else if (axis_dir.eq.3) then
          ! do nothing
         else
          print *,"axis_dir invalid"
          stop
         endif

        else if (im.eq.2) then ! air

         if (axis_dir.eq.0) then
          ! do nothing
         else if (axis_dir.eq.1) then
          ! do nothing
         else if (axis_dir.eq.2) then
          ! do nothing
         else if (axis_dir.eq.3) then
          
          if ((dist_gas.gt.radblob4).and. &
              (vfrac(im).ge.vfrac_cutoff)) then
           T_chill=250.0
           if (TEMPERATURE(im).gt.T_chill) then
            HEAT_SOURCE_OUT(im)=(T_chill-TEMPERATURE(im))* &
             DENSITY(im)*CV(im)/dt 
           endif 
          endif ! dist_gas>radblob4

         else
          print *,"axis_dir invalid"
          stop
         endif

        else
         print *,"im invalid61"
         stop
        endif 
       endif ! probtype==299 or probtype==301

       if (temperature_source.eq.zero) then
        ! do nothing
       else if (temperature_source.gt.zero) then
        inbox=1
        do localdir=1,SDIM
         xlo=temperature_source_cen(localdir)-temperature_source_rad(localdir)
         xhi=temperature_source_cen(localdir)+temperature_source_rad(localdir)
         if ((x(localdir).lt.xlo).or.(x(localdir).gt.xhi)) then
          inbox=0
         endif
        enddo

        if (inbox.eq.1) then
         if (TEMPERATURE(im).lt.temperature_source) then
          HEAT_SOURCE_OUT(im)=(temperature_source-TEMPERATURE(im))* &
             DENSITY(im)*CV(im)/dt 
         else if (TEMPERATURE(im).ge.temperature_source) then
          ! do nothing
         else
          print *,"TEMPERATURE(im) invalid"
          stop
         endif
        else if (inbox.eq.0) then
         ! do nothing
        else
         print *,"inbox invalid"
         stop
        endif
     
       else
        print *,"temperature_source invalid"
        stop
       endif

       if (1.eq.0) then
        if (HEAT_SOURCE_OUT(im).ne.zero) then
         print *,"x,im,heat_source_out ",xsten(0,1),xsten(0,2), &
           im,HEAT_SOURCE_OUT(im)
        endif
       endif
      enddo ! im=1..nmat

      return
      end subroutine get_local_heat_source 



      subroutine check_user_defined_velbc(time,dir,uu,dx)
      use global_utility_module
      use shockdrop

      IMPLICIT NONE

      INTEGER_T, intent(in) :: dir
      REAL_T, intent(in) :: time
      REAL_T, intent(inout) :: uu
      REAL_T, intent(in) :: dx(SDIM)
      REAL_T utest,uscale
      INTEGER_T nhalf

      nhalf=1

      if ((dir.lt.0).or.(dir.ge.SDIM)) then
       print *,"dir invalid"
       stop
      endif

      if (is_in_probtype_list().eq.1) then

       call SUB_CFL_HELPER(time,dir,uu,dx)

      else

       if (dir.eq.adv_dir-1) then
        if (probtype.eq.32) then ! flow past cylinder
         uu=max(abs(uu),abs(adv_vel))
         uu=max(abs(uu),abs(advbot))
        endif
        if (probtype.eq.41) then ! pipe flow
         uu=max(abs(uu),abs(adv_vel))
         uu=max(abs(uu),abs(advbot))
         uu=max(abs(uu),abs(vinletgas))
        endif
       endif
       if (probtype.eq.1) then
        if ((axis_dir.eq.150).or.(axis_dir.eq.151)) then
         call shockdrop_maxvelocity(utest,axis_dir)
         uu=max(abs(uu),abs(utest))
        endif
       endif
       
       if (dir.eq.0) then
        if ((probtype.eq.1).and.(axis_dir.eq.15)) then
         ! u = U t
         ! U(t+k)k=h 
         ! k^2+k t = h/U
         ! k=(-t+sqrt(t^2+4h/U))/2=(2h/U)/(t+sqrt(t^2+4h/U))
         ! h/k=(t+sqrt(t^2+4h/U))U/2
         uscale=abs(adv_vel)/two
         if (time.lt.two) then
          utest=(time+sqrt(time**2+four*dx(1)/uscale))
          utest=utest*uscale/two
         else
          utest=abs(adv_vel)
         endif
         uu=max(abs(uu),utest)
        else if ((probtype.eq.1).and.(axis_dir.lt.150).and. &
                 (axis_dir.ge.0)) then
         uu=max(abs(uu),abs(vinletgas))
         if (SDIM.eq.2) then
          uu=max(abs(uu),abs(adv_vel))
         endif
        endif
        if (probtype.eq.5700) then
         uu=max(abs(uu),abs(vinletgas))
        endif
       else if (dir.eq.1) then
 
         ! advbot is inflow vel at base 
        if (SDIM.eq.2) then
         if ((probtype.eq.531).or. &
             (probtype.eq.538).or. &  ! inputs.injA
             (probtype.eq.53).or. &
             (probtype.eq.541)) then
          uu=max(abs(uu),abs(advbot))
         endif
        endif
        if (probtype.eq.5700) then
         uu=max(abs(uu),abs(advbot))
        endif
        if (probtype.eq.5700) then
         uu=max(abs(uu),abs(vinletgas))
        endif

       else if ((dir.eq.2).and.(SDIM.eq.3)) then
        if (probtype.eq.36) then
         uu=max(abs(uu),abs(yblob9))
         uu=max(abs(uu),abs(yblob10))
        endif
         ! advbot is inflow vel at base  
        if ((probtype.eq.537).or. &
            (probtype.eq.538).or. &
            (probtype.eq.53).or. &
            (probtype.eq.541)) then
         uu=max(abs(uu),abs(advbot))
        endif
       else
        print *,"dir invalid check user defined velbc"
        stop
       endif

       ! vinletgas is a prescribed boiling rate
       if (probtype.eq.801) then
        uu=max(abs(uu),abs(vinletgas)*fort_denconst(1)/fort_denconst(2))
       endif

       if (probtype.eq.31) then
        uu=max(abs(uu),abs(adv_vel))
       endif

       if ((probtype.eq.701).and.(axis_dir.eq.2)) then
        uu=max(abs(uu),abs(adv_vel))
        uu=max(abs(uu),yblob*two*Pi)
       endif 
       if (probtype.eq.201) then
        uu=max(abs(uu),abs(advbot))
       endif 
      endif

      return
      end subroutine check_user_defined_velbc

      subroutine Zuzio_velbc(time,dir,side,veldir, &
       vel_out,vel_in)
      IMPLICIT NONE

      REAL_T time,vel_out,vel_in
      INTEGER_T dir,side,veldir

      vel_out=vel_in
      if ((dir.eq.1).and.(veldir.eq.1)) then
       vel_out=min(adv_vel,time*adv_vel/two)
      else if (dir.eq.1) then
       vel_out=zero
      else if (dir.eq.veldir) then
       vel_out=zero
      endif

      return
      end subroutine Zuzio_velbc


        ! fractional error always less than 1.2E-7
      REAL_T function erf_recipe(x)
      IMPLICIT NONE

      REAL_T dumerfc, x
      REAL_T t, z

      z = abs(x)
      t = one / ( one + half * z )

      dumerfc = t * exp(-z * z - 1.26551223d0 + t *   &
        ( 1.00002368d0 + t * ( 0.37409196d0 + t *     &
        ( 0.09678418d0 + t * (-0.18628806d0 + t *     &
        ( 0.27886807d0 + t * (-1.13520398d0 + t *     &
        ( 1.48851587d0 + t * (-0.82215223d0 + t * 0.17087277d0 )))))))))

      if ( x.lt.zero ) dumerfc = two - dumerfc
     
      erf_recipe = one - dumerfc

      return
      end function erf_recipe

      REAL_T function transf(x,cp)
      IMPLICIT NONE

      REAL_T x,pi,cp

      if (cp.le.zero) then
       print *,"cp invalid"
       stop
      endif

      pi=four*atan(one)
      transf=x*exp(x*x)*erf_recipe(x)-cp/sqrt(pi)

      return
      end function transf

       ! ice is supercooled, liquid is saturation temperature
      subroutine stefan1D(SUBLEN,TSUBSTRATE,TSAT,CP,L,K,den,time,rad)
      IMPLICIT NONE

      REAL_T SUBLEN,tcrit
      REAL_T TSUBSTRATE,TSAT,CP,L,K,den,time,rad
      REAL_T a,b,fb,fa,c,fc,lambda,alpha,fact
      INTEGER_T i

      if (TSAT.le.TSUBSTRATE) then
       print *,"TSAT invalid in stefan1D"
       stop
      endif
      if ((L.le.zero).or.(den.le.zero).or.(CP.le.zero).or.(K.le.zero).or. &
          (TSUBSTRATE.le.zero).or.(time.le.zero)) then
       print *,"stefan1D parameters invalid"
       stop
      endif
      fact=CP*(TSAT-TSUBSTRATE)/L
      alpha=K/(den*CP)

      a=zero
      b=two
      fb=transf(b,fact)
      do while (fb.le.zero) 
       b=2.0*b
       fb=transf(b,fact)
      enddo 
      fa=transf(a,fact)
      fb=transf(b,fact)
      if (fa*fb.gt.zero) then
       print *,"a,b invalid"
      endif
      do i=1,20
       c=(a+b)/two  
       fc=transf(c,fact)
       if (fa*fc.gt.zero) then
        a=c
        fa=fc
       else
        b=c
        fb=fc
       endif
      enddo
      lambda=c
       ! R=2 lam sqrt(alpha t)
       ! (R/(2 lam))^2 = alpha t
       ! t=(R/(2 lam))^2 / alpha
      if ((lambda.le.zero).or.(alpha.le.zero).or. &
          (SUBLEN.lt.zero)) then
       print *,"parameters invalid"
       stop
      endif
      tcrit=(SUBLEN/(two*lambda))**2/alpha 
      rad=two*lambda*sqrt(alpha*(tcrit+time))-SUBLEN
      if (rad.le.zero) then
       print *,"rad invalid"
       stop
      endif

      return
      end subroutine stefan1D


! for bering straight, radblob=sillrad, yblob=width, xblob=length
!  zblob=height  zblob-twall=free surface height
! height= height of sill
      subroutine beringfree(x,y,z,dist)
      IMPLICIT NONE


      REAL_T x,y,z,dist

      dist=zblob-twall-z

      return
      end subroutine beringfree
      
      subroutine bering(x,y,z,height,width,length,sillrad,dist)
      use global_utility_module
      use global_distance_module

      IMPLICIT NONE

      REAL_T x,y,z,dist
      REAL_T height,width,length,sillrad
      REAL_T midx,midy,yy,maxx,dist1
      REAL_T hy,hz,ylo,yhi,zlo,zhi

      midx=half*length
      midy=half*width
      maxx=midx+height

      yy=y
      if (y.gt.midy) then
       yy=two*midy-y
      endif

      if (x.le.midx) then
       if ((z.le.height).or.(yy.le.midy-sillrad)) then
        dist=midx-x
       else 
        dist=sqrt( (midx-x)**2+(yy-midy+sillrad)**2 )
       endif
      else 
       hz=height-(x-midx)
       hy=midy-sillrad-(x-midx)  
       ylo=hy
       yhi=midy+sillrad+(x-midx)
       zlo=hz
       zhi=99999.0
       call squaredist(yy,z,ylo,yhi,zlo,zhi,dist1)
       dist=-dist1
       if (dist.lt.zero) then
        dist1=midx-x
        if (dist1.gt.dist) then
         dist=dist1
        endif
       endif
      endif

      return
      end subroutine bering



! XIAOYI LI: Adding turbulent boundary layer for gas flow      
      subroutine BL_inlet(vel,z,time)
      IMPLICIT NONE
      REAL_T z,vel,time
      REAL_T TBLT
      REAL_T freq,amp,time0,velmax

      time0=0.0
      freq=0.5
      amp=0.1*adv_vel

!      velmax=adv_vel+amp*sin(2.0*3.1415926*(time-time0)*freq)
      velmax=adv_vel

      TBLT=1.0

      if(z < TBLT) then
       vel = velmax*(z/TBLT)**(1/7.0)
      else
       vel = velmax
      endif

!      if (z>2.55) print *, "Imposed gas flow = ", velmax                                            
      return
      end subroutine BL_inlet



! unit are in meters

      subroutine boatparms(depth,waterdepth,height,length,botwidth, &
         xback,yback,zback)
      IMPLICIT NONE
      REAL_T depth,waterdepth,height,length,botwidth, &
             xback,yback,zback


      if (probtype.eq.9) then  ! ship wave with solid parms and
                               ! free surface parms prescribed here ?

      if (axis_dir.eq.0) then
       depth=1.0
       waterdepth=13.0
       height=7.0
       length=21.0
       botwidth=4.0
       xback=40.0
       yback=15.0
       zback=waterdepth-depth
         ! solid comes from .cas file
      else if ((axis_dir.eq.1).or.(axis_dir.eq.2).or. &  
               (axis_dir.eq.3)) then
       depth=-0.1
       waterdepth=0.0
       height=0.1
       length=1.0
       botwidth=0.1
       xback=1.0
       yback=0.1
       zback=waterdepth-depth
      else
       print *,"invalid boat selection"
       stop
      endif 

      else
       print *,"probtype should be 9"
       stop
      endif

      return
      end subroutine

      subroutine boatdist(x,y,z,dist)
      IMPLICIT NONE
      REAL_T x,y,z,dist
      REAL_T depth,waterdepth,height,length,botwidth, &
             xback,yback,zback

      call boatparms(depth,waterdepth,height,length,botwidth, &
             xback,yback,zback) 
      dist=waterdepth-z ! waterdepth=0 if axis_dir=1
      if (axis_dir .eq. 3) then
       if (x .gt. -0.65 .and. x .lt. -0.49 .and. &
           y .gt. -0.02 .and. y .lt. 0.02         ) then
        dist = -0.03 - z
       endif
      endif
 
      return
      end subroutine boatdist

      subroutine get_mod_elastic_time(elastic_time,traceA, &
          overL,modtime)
      IMPLICIT NONE

      REAL_T elastic_time,traceA,overL,modtime


      if (overL.lt.zero) then
       print *,"over L invalid"
       stop
      endif
      if (elastic_time.lt.zero) then
       print *,"elastic_time invalid"
       stop
      endif
      if (traceA.lt.zero) then
       print *,"WARNING trace A invalid, traceA=",traceA
       traceA=zero
!       stop
      endif

      modtime=elastic_time*(one-traceA*(overL**2))
      if (modtime.lt.zero) then
       modtime=zero
      endif

      return
      end subroutine get_mod_elastic_time

      subroutine viscosity(system,vis,shear)
      IMPLICIT NONE
!
      INTEGER_T   system
!
      REAL_T    zeroviscosity,  contviscosity
      REAL_T    parameterA,  parameterB,  parameterN
      REAL_T    vis, shear, shearmax,etacutoff
      REAL_T    term1,powerterm
!
!     * This is a subroutine for setting pseudoplastic viscosity
!
!     * Generalized Cross-Carreau model parameters (4 parameters)
!     * Zero sheare rate viscosity (cgs)
!     * theree parameters a, B, n (-),(s),(-)

      shearmax=1.0D+20
      etacutoff=zero

      if (system.eq.1) then
        zeroviscosity = 0.5
        parameterA  = 2.0
        parameterB  = 1.0
        parameterN  = 0.5
      else if (system.eq.2) then
        zeroviscosity = 0.5
        parameterA  = 2.0
        parameterB  = 0.01
        parameterN  = 0.5
      else if (system.eq.3) then
        zeroviscosity = 0.5
        parameterA  = 2.0
        parameterB  = 1.0
        parameterN  = 0.8
      else if (system.eq.4) then
        zeroviscosity = 0.5
        parameterA  = 2.0
        parameterB  = 0.01
        parameterN  = 0.8
      else if (system.eq.5) then
        zeroviscosity = 0.31
        parameterA  = 5.0
        parameterB  = 0.167
        parameterN  = 0.875
      else if (system.eq.6) then
        zeroviscosity = 0.5
        parameterA  = 2.5
        parameterB  = 0.9
        parameterN  = 0.25
        shearmax=153.6
        etacutoff=1.24D-2
      else if (system.eq.7) then
        zeroviscosity = 0.26
        parameterA  = 4.0
        parameterB  = 1.429
        parameterN  = 0.4
        shearmax=103.1
        etacutoff=1.30D-2
      else
        print *,"system invalid"
        stop
      endif

       if (parameterN.gt.one) then
        print *,"parameterN invalid"
        stop
       endif

       if (shear.ge.shearmax) then
        contviscosity=etacutoff
       else
        term1=one+(parameterB*shear)**parameterA
        powerterm=(parameterN-one)/parameterA
        contviscosity=zeroviscosity*(term1**powerterm)
       endif
       vis=contviscosity

      return
      end subroutine viscosity

      subroutine get_bottom_elevation(x,elevation)

      IMPLICIT NONE

      real*8 x,elevation
      real*8 h,l

       ! inlet x/H=-52 outlet x/H=44
       ! inlet x=-52H=594.36 cm  outlet x=44H=502.92 cm
       ! zhi=5H=57.15 cm
       ! (x/l)=(x/(2.5 h))=2/5 (x/h)
       ! at inlet, (x/l)=-52 * 2/5 = -20.8
       ! at outlet, (x/l)=44 * 2/5 = 17.6
       ! 0<z/h<5
       ! dx_min=0.3mm  dz_min=0.2mm ?
       ! -1<x/l<1
      h=11.43  ! h=H  maximum bump height in centimeters
      l=2.5*h
      if (abs(x/l).le.1.0) then
       elevation=h*(1.0-2.0*((x/l)**2)+(x/l)**4)
      else if (x/l.lt.0.0) then
       elevation=0.0
      else if (x/l.gt.0.0) then
       elevation=0.0
      else
       print *,"bust"
       stop
      endif

      return
      end subroutine

      subroutine local_shallow_water_elevation(time,x,dist)
      IMPLICIT NONE

      REAL_T time,x,dist
      REAL_T xright,xleft,shallow_tstop
      REAL_T thetax,thetat,tgrid,xgrid
      REAL_T delta_t_grid,delta_x_grid
      REAL_T new_time
      INTEGER_T igrid,jgrid

      xleft=-594.36
      xright=502.92
      shallow_tstop=15.0
      new_time=time+SHALLOW_TIME

      delta_t_grid=shallow_tstop/SHALLOW_M
      delta_x_grid=(xright-xleft)/SHALLOW_N

        !  NINT->round to nearest whole number

      if (new_time.ge.shallow_tstop) then
       igrid=SHALLOW_M-1
      else if (new_time.le.zero) then
       igrid=0
      else
       igrid=NINT(new_time/delta_t_grid)-2
       if (igrid.lt.0) then
        igrid=0
       endif
       tgrid=igrid*delta_t_grid
       do while ((tgrid.lt.new_time).and.(igrid.lt.SHALLOW_M))
        igrid=igrid+1
        tgrid=igrid*delta_t_grid
       enddo
       igrid=igrid-1
      endif

      if (x.le.xleft) then
       jgrid=0
      else if (x.ge.xright) then
       jgrid=SHALLOW_N-1
      else
       jgrid=NINT((x-xleft)/delta_x_grid)-2
       if (jgrid.lt.0) then
        jgrid=0
       endif
       xgrid=xleft+jgrid*delta_x_grid
       do while ((xgrid.lt.x).and.(jgrid.lt.SHALLOW_N))
        jgrid=jgrid+1
        xgrid=xleft+jgrid*delta_x_grid
       enddo
       jgrid=jgrid-1
      endif

      xgrid=xleft+jgrid*delta_x_grid
      tgrid=igrid*delta_t_grid
      if (x.le.xgrid) then
       thetax=zero
      else if (x.ge.xgrid+delta_x_grid) then
       thetax=one
      else
       thetax=(x-xgrid)/delta_x_grid
      endif

      if (new_time.le.tgrid) then
       thetat=zero
      else if (new_time.ge.tgrid+delta_t_grid) then
       thetat=one
      else
       thetat=(new_time-tgrid)/delta_t_grid
      endif

      dist= &
       (one-thetax)*(one-thetat)*shallow_water_data(igrid,jgrid,1)+ &
       (thetax)*(one-thetat)*shallow_water_data(igrid,jgrid+1,1)+ &
       (thetax)*(thetat)*shallow_water_data(igrid+1,jgrid+1,1)+ &
       (one-thetax)*(thetat)*shallow_water_data(igrid+1,jgrid,1)

      return
      end subroutine

      subroutine local_shallow_water_velocity(time,x,vel)
      IMPLICIT NONE

      REAL_T time,x,vel
      REAL_T xright,xleft,shallow_tstop
      REAL_T thetax,thetat,tgrid,xgrid
      REAL_T delta_t_grid,delta_x_grid
      REAL_T new_time
      INTEGER_T igrid,jgrid

      xleft=-594.36
      xright=502.92
      shallow_tstop=15.0
      new_time=time+SHALLOW_TIME

      delta_t_grid=shallow_tstop/SHALLOW_M
      delta_x_grid=(xright-xleft)/SHALLOW_N

        !  NINT->round to nearest whole number

      if (new_time.ge.shallow_tstop) then
       igrid=SHALLOW_M-1
      else if (new_time.le.zero) then
       igrid=0
      else
       igrid=NINT(new_time/delta_t_grid)-2
       if (igrid.lt.0) then
        igrid=0
       endif
       tgrid=igrid*delta_t_grid
       do while ((tgrid.lt.new_time).and.(igrid.lt.SHALLOW_M))
        igrid=igrid+1
        tgrid=igrid*delta_t_grid
       enddo
       igrid=igrid-1
      endif

      if (x.le.xleft) then
       jgrid=0
      else if (x.ge.xright) then
       jgrid=SHALLOW_N-1
      else
       jgrid=NINT((x-xleft)/delta_x_grid)-2
       if (jgrid.lt.0) then
        jgrid=0
       endif
       xgrid=xleft+jgrid*delta_x_grid
       do while ((xgrid.lt.x).and.(jgrid.lt.SHALLOW_N))
        jgrid=jgrid+1
        xgrid=xleft+jgrid*delta_x_grid
       enddo
       jgrid=jgrid-1
      endif

      xgrid=xleft+jgrid*delta_x_grid
      tgrid=igrid*delta_t_grid
      if (x.le.xgrid) then
       thetax=zero
      else if (x.ge.xgrid+delta_x_grid) then
       thetax=one
      else
       thetax=(x-xgrid)/delta_x_grid
      endif

      if (new_time.le.tgrid) then
       thetat=zero
      else if (new_time.ge.tgrid+delta_t_grid) then
       thetat=one
      else
       thetat=(new_time-tgrid)/delta_t_grid
      endif

      vel= &
       (one-thetax)*(one-thetat)*shallow_water_data(igrid,jgrid,2)+ &
       (thetax)*(one-thetat)*shallow_water_data(igrid,jgrid+1,2)+ &
       (thetax)*(thetat)*shallow_water_data(igrid+1,jgrid+1,2)+ &
       (one-thetax)*(thetat)*shallow_water_data(igrid+1,jgrid,2)

      return
      end subroutine




      subroutine doit(problo,probhi,ncell,dx,tstop)
      IMPLICIT NONE

      real*8 problo,probhi,dx,tstop
      integer ncell
      real*8 SSold(-1:ncell)
      real*8 SS(-1:ncell)
      real*8 QQold(-1:ncell)
      real*8 QQ(-1:ncell)
      real*8 DD(-1:ncell)  ! bottom topography
      real*8 xx(-1:ncell)
      real*8 SSflux(0:ncell)
      real*8 QQflux(0:ncell)
      real*8 start_elevation
      integer skip,nstep,i
      real*8 local_gravity,time
      real*8 elevation_right,elevation_left,u_right,u_left
      real*8 maxu,maxc,den,mom,uu,cc,dt,lambda
      real*8 denleft,denright,momleft,momright,pleft,pright
      real*8 minz
      integer icrit

      integer igrid,jgrid  ! t index x index
      REAL_T delta_t_grid,delta_x_grid,t_grid,x_grid
      REAL_T thetax,thetat
      integer hitgrid,last_index

      delta_t_grid=tstop/SHALLOW_M
      delta_x_grid=(probhi-problo)/SHALLOW_N

      skip=2000

      local_gravity=980.0
      start_elevation=22.862

      time=0.0
      nstep=0

      do i=-1,ncell
       xx(i)=problo+(i+0.5)*dx
       call get_bottom_elevation(xx(i),DD(i))
       QQ(i)=0.0
       SS(i)=start_elevation-DD(i)
      enddo

      do while (time.le.tstop-1.0D-10) 

       call get_right_elevationIOWA(time,elevation_right)
       call get_left_elevationIOWA(time,elevation_left)
       call get_right_velocityIOWA(time,u_right)
       call get_left_velocityIOWA(time,u_left)
       SS(-1)=elevation_left
       SS(ncell)=elevation_right
       QQ(-1)=elevation_left*u_left
       QQ(ncell)=elevation_right*u_right

       do i=-1,ncell
        SSold(i)=SS(i)
        QQold(i)=QQ(i)
       enddo
 
       maxu=0.0
       maxc=0.0 
       do i=0,ncell-1
        den=SS(i)
        mom=QQ(i)
        if (den.le.0.0) then
         print *,"density must be positive (subroutine doit shallow_water)"
         print *,"i,den ",i,den
         stop
        endif
        cc=sqrt(local_gravity*den)
        if (cc.gt.maxc) then
         maxc=cc
        endif
        uu=abs(mom/den)
        if (uu.gt.maxu) then
         maxu=abs(uu)
        endif
       enddo
       if (maxu+maxc.le.0.0) then
        print *,"must have acoustic waves"
        stop
       endif
       dt=0.8*dx/(maxu+maxc)
       if (time+dt.ge.tstop) then
        dt=tstop-time
       endif
       lambda=dt/dx

       do i=0,ncell
        denleft=SS(i-1)
        denright=SS(i)
        momleft=QQ(i-1)
        momright=QQ(i)
        pleft=0.5*local_gravity*(denleft**2)
        pright=0.5*local_gravity*(denright**2)
        SSflux(i)=0.5*(momleft+momright)-0.5*(denright-denleft)/lambda
        if (denright.le.0.0) then
         print *,"hydraulic section must be positive"
         stop
        endif
        if (denleft.le.0.0) then
         print *,"hydraulic section must be positive"
         stop
        endif
        QQflux(i)=0.5*(momleft**2/denleft+momright**2/denright+ &
          pleft+pright)-0.5*(momright-momleft)/lambda
       enddo
       do i=0,ncell-1
        SS(i)=SS(i)-lambda*(SSflux(i+1)-SSflux(i))
        QQ(i)=QQ(i)-lambda*(QQflux(i+1)-QQflux(i))- &
          lambda*SS(i)*local_gravity*0.5*(DD(i+1)-DD(i-1))
       enddo

       hitgrid=0
       do igrid=0,SHALLOW_M
        t_grid=igrid*delta_t_grid
        if (hitgrid.eq.0) then
         if ((time.le.t_grid).and.(time+dt.ge.t_grid)) then
          hitgrid=1
          last_index=-1
          do jgrid=0,SHALLOW_N
           x_grid=problo+jgrid*delta_x_grid
           do while (xx(last_index).le.x_grid)
            last_index=last_index+1
           enddo
           last_index=last_index-1
           if (t_grid.le.time) then
            thetat=zero
           else if (t_grid.ge.time+dt) then
            thetat=one
           else 
            thetat=(t_grid-time)/dt
           endif
           if (x_grid.le.xx(last_index)) then
            thetax=zero
           else if (x_grid.ge.xx(last_index+1)) then
            thetax=one
           else
            thetax=(x_grid-xx(last_index))/dx
           endif
           shallow_water_data(igrid,jgrid,1)= &
             (one-thetax)*(one-thetat)* &
                (DD(last_index)+SSold(last_index))+ &
             (one-thetax)*thetat* &
                (DD(last_index)+SS(last_index))+ &
             (one-thetat)*thetax* &
                (DD(last_index+1)+SSold(last_index+1))+ &
             thetat*thetax* &
               (SS(last_index+1)+DD(last_index+1))
           shallow_water_data(igrid,jgrid,2)= &
             (one-thetax)*(one-thetat)* &
             QQold(last_index)/SSold(last_index)+ &
             (one-thetax)*thetat* &
             QQ(last_index)/SS(last_index)+ &
             (one-thetat)*thetax* &
             QQold(last_index+1)/SSold(last_index+1)+ &
             thetat*thetax* &
             QQ(last_index+1)/SS(last_index+1)
          enddo  ! jgrid
         endif ! time<t_grid<time+dt
        endif ! hitgrid=0
       enddo ! igrid

       time=time+dt
       nstep=nstep+1

       if (nstep-skip*(nstep/skip).eq.0) then
        print *,"time=",time
        print *,"dt=",dt
        icrit=0
        minz=SS(0)+DD(0)
        do i=0,ncell-1
         if (SS(i)+DD(i).lt.minz) then
          minz=SS(i)+DD(i)
          icrit=i
         endif
        enddo
        print *,"icrit,x,minz ",icrit,xx(icrit),minz
       endif
      enddo ! while time<tstop
 
      return
      end subroutine doit

      subroutine shallow_water_solve()
      IMPLICIT NONE

      real*8 problo,probhi,tstop,dx
      integer ncell

      problo=-594.36
      probhi=502.92

       ! 0.1 mm  (0.2mm in Fred Stern's paper)
       ! 100000
      ncell=5000
      dx=(probhi-problo)/ncell
      tstop=15.0

      call doit(problo,probhi,ncell,dx,tstop)

      return
      end subroutine shallow_water_solve



      subroutine get_max_user_tension(tension,new_tension,nmat,nten)
      IMPLICIT NONE

      INTEGER_T nmat,nten,nten_test
      REAL_T tension(nten)
      REAL_T new_tension(nten)
      INTEGER_T iten

      nten_test=( (nmat-1)*(nmat-1)+nmat-1 )/2
      if (nten_test.ne.nten) then
       print *,"nten invalid get_max_user_tension nten nten test", &
         nten,nten_test
       stop
      endif

      do iten=1,nten
       new_tension(iten)=tension(iten)
      enddo

      return
      end subroutine get_max_user_tension



 
       subroutine get_scaled_tension(tension_in,tension_out)
       IMPLICIT NONE

       REAL_T, intent(in) :: tension_in
       REAL_T, intent(out) :: tension_out


       tension_out=tension_in/global_pressure_scale

       return 
       end subroutine

       subroutine get_scaled_pforce(pforce_scaled)
       IMPLICIT NONE

       REAL_T, intent(out) :: pforce_scaled


       pforce_scaled=one/global_pressure_scale

       return
       end subroutine get_scaled_pforce


function ZEYU_delta(s)
implicit none

double precision ZEYU_delta
double precision, intent(in) :: s
double precision :: r

! integral_r=0 to r=2 d(r)dr =1 
! s=alpha (r/2)
! integral_s=0 to s= alpha d(2s/alpha) 2 ds/alpha = 1

if (GNBC_RADIUS.ge.1.0d0) then
 ! do nothing
else
 print *,"GNBC_RADIUS invalid"
 stop
endif

r = 2.0d0*s/GNBC_RADIUS

if (abs(r) <= 1.0d0) then
    ZEYU_delta = (3.0d0 - 2.0d0 * abs(r) + &
      sqrt(1.0d0 + 4.0d0 * abs(r) - 4.0d0 * r * r)) / 8.0d0
else if (1.0d0 < abs(r) .AND. abs(r) <= 2.0d0) then
    ZEYU_delta = (5.0d0 - 2.0d0 * abs(r) -  &
      sqrt(-7.0d0 + 12.0d0 * abs(r) - 4.0d0 * r * r)) / 8.0d0
else
    ZEYU_delta = 0.0d0
end if

ZEYU_delta=ZEYU_delta * 2.0d0/GNBC_RADIUS

end function ZEYU_delta


!assume x_proj locates in centeral cell ((ni+1)/2,(nj+1)/2,(nk+1)/2)
!The stencil is better to be 7x7x7 (or larger), 
!because the range of delta function in GNBC model is 2*dx, 
!if cannot find contact line in stencil, or closest_distance > 2*dx, or 
!the cell cloest to CL is (i = 1 or ni, or j = ..., or k = ...(dim=3)), 
!then return?
!LS1_xp: fluid level set value of projection point
!x(ni, nj, nk, dim): positions of stencil
!x_proj(dim): position of projection point
!dx: cell scale
!if dim = 2, then nk = 1
subroutine closest_distance_to_CL( &
     LS_stencil, &
     LS_xp, &! bilinear interp of LS to x_projection
     x_stencil, & ! stencil of x values
     x_proj, &
     n_rad, &
     actual_angle, &
     closest_distance, &
     im_primary, & ! im_primary owns adjoining cell to given structure cell
     im_secondary, & ! im_secondary is a fluid too.
     im_solid, &  ! structure material id.
     nmat, &
     prob_dim)
use global_utility_module
implicit none

integer, intent(in) :: nmat,n_rad, prob_dim
integer, intent(in) :: im_primary,im_secondary,im_solid
double precision, intent(in) :: &
   LS_stencil(-n_rad:n_rad,-n_rad:n_rad,-n_rad:n_rad,nmat)
double precision, intent(in) :: &
   x_stencil(-n_rad:n_rad,-n_rad:n_rad,-n_rad:n_rad,prob_dim)
double precision, intent(in) :: x_proj(prob_dim)
double precision, intent(in) :: LS_xp(nmat)

double precision, intent(out) :: actual_angle, closest_distance

double precision :: dx

integer dir
integer i, j, k, d, i_method, icl, jcl, kcl
integer find_cl ! estimate if contact line exits
double precision costheta, eps, dis, mag, phimin, tmp(3), tmp1(3), &
                 nphi(3), npsi(3), nphi_xp(3), tpsi(3), nalpha(3), &
                 x_inf_proj(prob_dim), x_inf_proj_alpha(prob_dim), &
                 x_psi_proj(prob_dim), x_contact_point(prob_dim)
!nphi: normal vector of contact line, grad(LS1)/|grad(LS1)|
!npsi: normal vector of substrate, grad(LS3)/|grad(LS3)|
!nphi_xp: unit vector in gradient direction of projection point, 
!    grad(LS1)/|grad(LS1)|, assume it equal the value at centeral cell
!tpsi: unit vector which is tangent to substrate, on plane_alpha 
!    (constructed by npsi and nphi_xp), point outward to interface
!nalpha: normal vector of plane_alpha
!x_inf_proj: projection point of (icl,jcl,kcl) on interface
!x_inf_proj_alpha: projection point of x_inf_proj_alpha on plane_alpha
!x_psi_proj: projection point of x_inf_proj_alpha on substrate
!x_contact_point: location of closest contact point

    if (n_rad.eq.3) then
     ! do nothing
    else
     print *,"n_rad invalid"
     stop
    endif

    dir=1
    dx=0.5d0*(x_stencil(1,0,0,dir)-x_stencil(-1,0,0,dir))
    i_method = 2
    find_cl = 0
    eps = 1.1d0*dx
    closest_distance = 1.d10
    actual_angle = 0.d0

!calculate normal vector of substrate
!this used to be LS3
    dir=1
    tmp(dir) = (LS_stencil(1,0,0,im_solid)-LS_stencil(-1,0,0,im_solid))/ &
               (x_stencil(1,0,0,dir)-x_stencil(-1,0,0,dir))
    dir=2
    tmp(dir) = (LS_stencil(0,1,0,im_solid)-LS_stencil(0,-1,0,im_solid))/ &
               (x_stencil(0,1,0,dir)-x_stencil(0,-1,0,dir))
    if (prob_dim .eq. 3) then
     dir=prob_dim
     tmp(dir) = (LS_stencil(0,0,1,im_solid)-LS_stencil(0,0,-1,im_solid))/ &
                (x_stencil(0,0,1,dir)-x_stencil(0,0,-1,dir))
    else
       tmp(3) = 0.d0
    endif
    mag = 0.d0
    do d = 1, prob_dim
       mag = mag+tmp(d)*tmp(d)
    enddo
    mag = sqrt(mag)
    do d = 1, prob_dim
       npsi(d) = tmp(d)/mag
    enddo

!find closest distance and actual angle

!method 1: approximate value, find closest cell center (with different LS 
!          sign and close to substrate)
    if (i_method .eq. 1) then
       closest_distance = 1.d10
       do i = -n_rad,n_rad
       do j = -n_rad,n_rad
       do k = -n_rad,n_rad
        if ((LS_stencil(i,j,k,im_primary)*LS_xp(im_primary).le.0.d0).and. &
            (abs(LS_stencil(i,j,k,im_solid)).lt.eps)) then
         find_cl = 1
         dis = 0.d0
         do d = 1, prob_dim
          dis = dis+(x_stencil(i,j,k,d)-x_proj(d))**2.d0
         enddo
         dis = sqrt(dis)
         if (dis .lt. closest_distance) then
          closest_distance = dis
          if (LS_stencil(i,j,k,im_solid) .lt. 0.d0) then
           icl = i
           jcl = j
           kcl = k
          endif
         endif
        endif
       enddo
       enddo
       enddo
       if (find_cl .ne. 1) then
          print *, "Cannot find contact line!"
          return
       endif
       if (icl .eq. -n_rad .or. icl .eq. n_rad .or. &
           jcl .eq. -n_rad .or. jcl .eq. n_rad .or. &
           (prob_dim .eq. 3 .and. &
           (kcl .eq. -n_rad .or. kcl .eq. n_rad))) then
          print *, "Too far from contact line!"
          return
       endif
!calculate normal vector of contact line
!this used to be LS1
       dir=1
       tmp(dir) = (LS_stencil(icl+1,jcl,kcl,im_primary)- &
                   LS_stencil(-1+icl,jcl,kcl,im_primary))/ &
         (x_stencil(icl+1,jcl,kcl,dir)-x_stencil(-1+icl,jcl,kcl,dir))
       dir=2
       tmp(dir) = (LS_stencil(icl,jcl+1,kcl,im_primary)- &
                   LS_stencil(icl,-1+jcl,kcl,im_primary))/ &
         (x_stencil(icl,jcl+1,kcl,dir)-x_stencil(icl,-1+jcl,kcl,dir))
       if (prob_dim .eq. 3) then
        dir=prob_dim
        tmp(dir) = (LS_stencil(icl,jcl,kcl+1,im_primary)- &
                    LS_stencil(icl,jcl,-1+kcl,im_primary))/ &
         (x_stencil(icl,jcl,kcl+1,dir)-x_stencil(icl,jcl,-1+kcl,dir))
       else
          tmp(3) = 0.d0
       endif
       mag = 0.d0
       do d = 1, prob_dim
          mag = mag+tmp(d)*tmp(d)
       enddo
       mag = sqrt(mag)
!calculate actual contact angle
       costheta = 0.d0
       do d = 1, prob_dim
          nphi(d) = tmp(d)/mag
          costheta = costheta + nphi(d) * npsi(d)
       enddo
       actual_angle = acos(costheta)

!method 2:
!  define: phi = LS1, psi = LS3
!  step1: calculate nphi_xp based on LS1 value in centeral cell, 
!         with nphi_xp and npsi, determine plane-alpha (which is 
!         perpendicular to substrate and interface)
!  step2: calculate tpsi on substrate and plane-alpha, with point x_proj
!         and vector tpsi, we can determine line L (contact point is on L)
!  step3: when -eps<psi<0 and |phi|<eps and |(x-x_proj) X tpsi|<eps,
!         find (icl,jcl,kcl) makes |phi| minimum
!  step4: calculate nphi based on LS1 value in (icl,jcl,kcl)
!  step5: calculate actual_angle based on nphi and npsi
!  step6: project (icl,jcl,kcl) to interface based on nphi and 
!         LS1(icl,jcl,kcl), get point x_inf_proj
!  step7: project x_inf_proj to plane_alpha, get x_inf_proj_alpha
!  step8: get distance between x_inf_proj_alpha and line L, dis, and 
!         intersection x_psi_proj
!  step9:get x_contact_point = x_psi_proj + dis/tan(actual_angle) * tpsi
!  step10:get closest_distance = |x_proj - x_contact_point|

    else if (i_method .eq. 2) then

!calculate unit vector in gradient direction of projection point, nphi_xp
       icl=0
       jcl=0
       kcl=0
       dir=1
         ! used to be LS1
       tmp(dir) = (LS_stencil(icl+1,jcl,kcl,im_primary)- &
                   LS_stencil(-1+icl,jcl,kcl,im_primary))/ &
         (x_stencil(icl+1,jcl,kcl,dir)-x_stencil(-1+icl,jcl,kcl,dir))
       dir=2
       tmp(dir) = (LS_stencil(icl,jcl+1,kcl,im_primary)- &
                   LS_stencil(icl,-1+jcl,kcl,im_primary))/ &
         (x_stencil(icl,jcl+1,kcl,dir)-x_stencil(icl,-1+jcl,kcl,dir))
       if (prob_dim .eq. 3) then
        dir=prob_dim
        tmp(dir) = (LS_stencil(icl,jcl,kcl+1,im_primary)- &
                    LS_stencil(icl,jcl,-1+kcl,im_primary))/ &
         (x_stencil(icl,jcl,kcl+1,dir)-x_stencil(icl,jcl,-1+kcl,dir))
       else
          tmp(3) = 0.d0
       endif

       mag = 0.d0
       do d = 1, prob_dim
          mag = mag+tmp(d)*tmp(d)
       enddo
       mag = sqrt(mag)
       do d = 1, prob_dim
          nphi_xp(d) = tmp(d)/mag
       enddo
!calculate tpsi
!  nalpha = nphi_xp X npsi (X: cross product)
!  nalpha = nalpha / |nalpha|
!  tpsi = nalpha X npsi
!  tpsi = tpsi / |tpsi|
       call crossprod(nphi_xp, npsi, nalpha)
       mag = 0.d0
       do d = 1, prob_dim
          mag = mag+nalpha(d)*nalpha(d)
       enddo
       mag = sqrt(mag)
       do d = 1, prob_dim
          nalpha(d) = nalpha(d)/mag
       enddo
       call crossprod(nalpha, npsi, tpsi)
       mag = 0.d0
       do d = 1, prob_dim
          mag = mag+tpsi(d)*tpsi(d)
       enddo
       mag = sqrt(mag)
       do d = 1, prob_dim
          tpsi(d) = tpsi(d)/mag
       enddo
!find icl, jcl, kcl
       phimin = 1.d10
       do i = -n_rad,n_rad
       do j = -n_rad,n_rad
       do k = -n_rad,n_rad
        do d = 1, 2
         tmp(d) = x_stencil(i,j,k,d) - x_proj(d)
        enddo
        if (prob_dim .eq. 3) then
         tmp(3) = x_stencil(i,j,k,prob_dim) - x_proj(prob_dim)
        else
         tmp(3) = 0.d0
        endif
        call crossprod(tmp, tpsi, tmp1)
        dis = 0.d0
        do d = 1, prob_dim
         dis = dis+tmp1(d)*tmp1(d)
        enddo
        dis = sqrt(dis)
         ! used to be LS3
        if (LS_stencil(i,j,k,im_solid) .le. 0.d0 .and. &
            LS_stencil(i,j,k,im_solid) .gt. -eps .and. &
            abs(LS_stencil(i,j,k,im_primary)) .lt. eps .and. &
            dis .lt. eps) then
         find_cl = 1
         if (abs(LS_stencil(i,j,k,im_primary)) .lt. phimin) then
          phimin = abs(LS_stencil(i,j,k,im_primary))
          icl = i
          jcl = j
          kcl = k
          !print *, "phimin = ", phimin
          !print *, "icl, jcl, kcl = ", icl, jcl, kcl
         endif
        endif
       enddo
       enddo
       enddo
       if (find_cl .ne. 1) then
          print *, "Cannot find contact line!"
          return
       endif
       if (icl .eq. -n_rad .or. icl .eq. n_rad .or. &
           jcl .eq. -n_rad .or. jcl .eq. n_rad .or. &
           (prob_dim .eq. 3 .and. &
           (kcl .eq. -n_rad .or. kcl .eq. n_rad))) then
          print *, "Too far from contact line!"
          return
       endif
!calculate nphi and actual angle

        ! used to be LS1
       dir=1
       tmp(dir) = (LS_stencil(icl+1,jcl,kcl,im_primary)- &
                   LS_stencil(-1+icl,jcl,kcl,im_primary))/ &
         (x_stencil(icl+1,jcl,kcl,dir)-x_stencil(-1+icl,jcl,kcl,dir))
       dir=2
       tmp(dir) = (LS_stencil(icl,jcl+1,kcl,im_primary)- &
                   LS_stencil(icl,-1+jcl,kcl,im_primary))/ &
         (x_stencil(icl,jcl+1,kcl,dir)-x_stencil(icl,-1+jcl,kcl,dir))
       if (prob_dim .eq. 3) then
        dir=prob_dim
        tmp(dir) = (LS_stencil(icl,jcl,kcl+1,im_primary)- &
                    LS_stencil(icl,jcl,-1+kcl,im_primary))/ &
         (x_stencil(icl,jcl,kcl+1,dir)-x_stencil(icl,jcl,-1+kcl,dir))
       else
          tmp(3) = 0.d0
       endif


       mag = 0.d0
       do d = 1, prob_dim
          mag = mag+tmp(d)*tmp(d)
       enddo
       mag = sqrt(mag)

       costheta = 0.d0
       do d = 1, prob_dim
          nphi(d) = tmp(d)/mag
          costheta = costheta + nphi(d) * npsi(d)
          !print *, "d, nphi(d), npsi(d) = ", d, nphi(d), npsi(d)
       enddo
       actual_angle = acos(costheta)
!get point x_inf_proj
       do d = 1, prob_dim
           ! used to be LS1
          x_inf_proj(d) = x_stencil(icl,jcl,kcl,d)- &
                  LS_stencil(icl,jcl,kcl,im_primary)*nphi(d)
          !print *, "d = ", d, "x_inf_proj = ", x_inf_proj(d)
       enddo
!get point x_inf_proj_alpha
       if (prob_dim .eq. 2) then
          do d = 1, prob_dim
             x_inf_proj_alpha(d) = x_inf_proj(d)
          enddo
       else if (prob_dim .eq. 3) then
          dis = 0.d0
          do d = 1, prob_dim
             tmp(d) = x_inf_proj(d) - x_proj(d)
             dis = dis + tmp(d) * nalpha(d)
          enddo
          !if x_inf_proj locates in left side of plane_alpha, dis < 0
          do d = 1, prob_dim
             x_inf_proj_alpha(d) = x_inf_proj(d)-dis*nalpha(d)
             !print *, "d = ", d, "x_inf_proj_alpha = ", x_inf_proj_alpha(d)
          enddo
       else
          print *, "prob_dim invalid"
          stop
       endif
!get point x_psi_proj
       dis = 0.d0
       do d = 1, prob_dim
          tmp(d) = x_inf_proj_alpha(d) - x_proj(d)
          dis = dis + tmp(d) * npsi(d)
       enddo
       !if x_inf_proj_alpha locates in fluid zone, dis < 0
       do d = 1, prob_dim
          x_psi_proj(d) = x_inf_proj_alpha(d)-dis*npsi(d)
          !print *, "d = ", d, "x_psi_proj = ", x_psi_proj(d)
       enddo
!get point x_contact_point
       if (costheta .eq. 1.d0) then
          print *, "contact angle equal zero"
          stop
       else if (costheta .eq. 0.d0) then
          do d = 1, prob_dim
             x_contact_point(d) = x_psi_proj(d)
          enddo
       else
          do d = 1, prob_dim
             x_contact_point(d) = x_psi_proj(d)-dis/tan(actual_angle) &
                                  *tpsi(d)
             !print *, "d = ", d, "x_contact_point = ", x_contact_point(d)
          enddo
       endif
       closest_distance = 0.d0
       do d = 1, prob_dim
          closest_distance = closest_distance+(x_proj(d)- &
                             x_contact_point(d))**2.d0
       enddo
       closest_distance = sqrt(closest_distance)

    else
       print *, "i_method invalid"
       stop
    endif

  end subroutine closest_distance_to_CL


! ZEYU HUANG
!mu_l: dynamic viscocity of liquid
!mu_g: dynamic viscocity of gas
!sigma: surface tension coeffient
!thet_s: static contact angle (liquid region)
!imodel: model index, can be 1 ~ 7
!ifgnbc: if use gnbc, only works in model 1
!lambda: slip length, equal to 8.e-7 in Yamamoto2013, depends on 
!specific problems
!l_macro: parameter in gnbc, can be set as grid length
!l_micro: parameter in gnbc, can be set as 1.e-9
!dgrid: grid length = dxmin when called from getGhostVel
!d_closest: closest distance to the contact line
!thet_d_apparent: dynamic contact angle from simulation (input in gnbc)
!(liquid region)
!u_cl: velocity of contact line (input in dynamic contact angle models)
! (unused for GNBC)
!u_slip: slip velocity of wall (output in gnbc)
! u_slip>0 if CL advancing into the vapor region.
!thet_d: dynamic contact angle (output in dynamic contact angle models)
!(liquid region) (unused, GNBC)
!For the test results of different dynamic contact angle models, model 4 and 
!model 7 have large difference between other models.
!
!called from: GODUNOV_3D.F90
subroutine dynamic_contact_angle(mu_l, mu_g, sigma, &
                thet_s, &
                imodel, ifgnbc, lambda, &
                l_macro, l_micro, &
                dgrid, d_closest, thet_d_apparent, &
                u_cl, u_slip, thet_d)
implicit none

integer imodel, ifgnbc
double precision mu_l, mu_g, sigma, thet_s, dgrid, d_closest
double precision thet_d_apparent, u_cl, u_slip, thet_d
double precision lambda, l_macro, l_micro !parameter of gnbc
integer iter
double precision Ca
double precision sign_Ca
double precision thet_d_micro, beta, chi !parameters of model1
double precision thet_d_micro_old, Ca_old, a, b, c
double precision f1, f2, Ja11, Ja12, Ja21, Ja22
double precision b1, b2, u11, u12, u22, l21, y1, y2
double precision a1, a2, a3, a4, u, u0, thet_d_old !parameters of model3
double precision temp,temp2
double precision fHI, fHI_old !parameters of model5
double precision sigma_0, v_0 !parameters of model7
integer diag_output

diag_output=1

if (ifgnbc.eq.0) then
        if (diag_output.eq.1) then
         print *, "Implement Dynamic Contact Angle ..."
        endif
else if (ifgnbc.eq.1) then
        if (diag_output.eq.1) then
         print *, "Implement Generalized Navier Boundary Condition ..."
        endif
else
        print *,"ifgnbc invalid"
        stop
end if

 ! sanity check
if (sigma.gt.0.0d0) then
 Ca = mu_l * u_cl / sigma
 if (Ca.ge.0.0d0) then
  sign_Ca=1.0d0
 else if (Ca.lt.0.0d0) then
  sign_Ca=-1.0d0
 else
  print *,"Ca corrupt"
  stop
 endif
else
        print *,"sigma invalid"
        stop
endif

select case (imodel)
    case (1) !GNBC
        if (diag_output.eq.1) then
         print *, "Implement model 1 ..."
        endif
       if (abs(l_macro) < 1.0D-9) then
           l_macro = dgrid
       end if

        if (ifgnbc.eq.0) then !If don't implement GNBC.
            print *,"imodel and ifgnbc mismatch"
            stop
        else if (ifgnbc.eq.1) then !Implement GNBC
            beta = mu_l / lambda
            chi = (mu_l + mu_g) / (2.0d0 * beta * dgrid)
            a = 9.0d0 * log(l_macro / l_micro)
            b = thet_d_apparent**3.0d0
            c = chi * cos(thet_s)
            
            iter = 0
            thet_d_micro = 0.0d0
            Ca = 0.0d0
            thet_d_micro_old = thet_d_apparent
            Ca_old = chi * (cos(thet_s) - cos(thet_d_apparent))
            do iter = 0, 1000
                f1 = thet_d_micro_old**3.0d0 + a * Ca_old - b
                f2 = Ca_old + chi * cos(thet_d_micro_old) - c
                Ja11 = 3.0d0 * thet_d_micro_old**2.0d0
                Ja12 = a
                Ja21 = - chi * sin(thet_d_micro_old)
                Ja22 = 1.0d0
                b1 = Ja11 * thet_d_micro_old + Ja12 * Ca_old - f1
                b2 = Ja21 * thet_d_micro_old + Ja22 * Ca_old - f2
                u11 = Ja11
                u12 = Ja12
                l21 = Ja21 / (u11 + 1.0D-20)
                u22 = Ja22 - l21 * u12
                y1 = b1
                y2 = b2 - l21 * y1
                Ca = y2 / (u22 + 1.0D-20)
                thet_d_micro = (y1 - u12 * Ca) / (u11 + 1.0D-20)
                if (abs((thet_d_micro - thet_d_micro_old)/ &
                        (thet_d_micro_old+1.0D-20)) < 1.0D-4 &
                   .AND. abs((Ca - Ca_old)/(Ca_old+1.0D-20)) < 1.0D-4) then
                    exit
                end if
                thet_d_micro_old = thet_d_micro
                Ca_old = Ca
            end do
            print *, "Calculating Ca and thet_d_micro..."
            print *, "number of iteration is: ", iter
             ! beta = mu_l / lambda  e.g. lambda=8.0D-7
             ! integral_{-2 dx}^{2 dx} u_slip = u_CL_JIANG * 4 dx ?
            u_slip = 1. / (beta * dgrid + 1.0D-20) *  &
                  ZEYU_delta(d_closest/dgrid) * sigma *  &
                  (cos(thet_s) - cos(thet_d_micro))
            thet_d = thet_d_apparent
        else
            print *,"ifgnbc invalid"
            stop
        end if

    case (8) !Cox1986
        if (diag_output.eq.1) then
         print *, "Implement model 1 ..."
        endif
       if (abs(l_macro) < 1.e-9) then
           l_macro = dgrid
       end if

        if (ifgnbc.eq.0) then !If don't implement GNBC.
            thet_d = (thet_s**3 + 9. * Ca * log(l_macro / l_micro))**(1./3.)
            u_slip = 0.
        else if (ifgnbc.eq.1) then !Implement GNBC
            print *,"imodel and ifgnbc mismatch"
            stop
        else
            print *,"ifgnbc invalid"
            stop
        end if

    case (2) !Jiang1970
        if (diag_output.eq.1) then
         print *, "Implement model 2, Ca= ...",Ca
        endif
        if (Ca.eq.0.0d0) then
         thet_d=thet_s
        else if (Ca.ne.0.0d0) then
         temp2=abs(Ca)**0.702d0
         temp=tanh(4.96*temp2)
         temp=temp*(1.0d0+cos(thet_s))
         temp=cos(thet_s)-(Ca/abs(Ca))*temp
         if (temp.gt.1.0d0) temp = 1.0d0 
         if (temp.lt.-1.0d0) temp = -1.0d0 
         thet_d=acos(temp)
        else
         print *,"Ca invalid"
         stop
        endif
        u_slip = 0.
        if (diag_output.eq.1) then
         print *, "End Implement model 2, thet_d= ...",thet_d
        endif 

    case (3) !Shikmurzaev2008
        if (diag_output.eq.1) then
         print *, "Implement model 3 ..."
        endif
        a2 = 0.54
        a3 = 12.5
        a4 = 0.07
        a1 = 1. + (1. - a2) * (cos(thet_s) - a4)
        u = a3 * Ca
        thet_d_old = thet_d_apparent
        u0 = 0.
        do iter = 0, 1000
            u0 = (sin(thet_d_old - thet_d_old * cos(thet_d_old))) / (sin(thet_d_old) * cos(thet_d_old) - thet_d_old)
            thet_d = acos(cos(thet_s) - 2. * u * (a1 + a2 * u0) / (1. - a2) / (sqrt(a1 + u * u) + u))
            if (abs((thet_d - thet_d_old)/(thet_d_old + 1.e-20)) < 1.e-4) then
                exit
            else
               thet_d_old = thet_d
            end if
        end do
        if (diag_output.eq.1) then
         print *, "Calculating thet_d..."
         print *, "number of iteration is: ", iter
        endif
        u_slip = 0.

    case (4) !Kalliadasis1994-'abs(tan(the_d))=...', so how to determine the_d<90 or thet_d>90? It seems have problems...
        print *,"Kalliadasis 1994 fails if Ca<=0, also no theta_s input!"
        stop

        if (diag_output.eq.1) then
         print *, "Implement model 4 ..."
        endif
        thet_d = atan(7.48 * Ca**(1./3.) - 3.28 * 1.e-8**0.04 * Ca**0.293)
        u_slip = 0.
        
    case (5) !Kistler1993
        if (diag_output.eq.1) then
         print *, "Implement model 5 ..."
        endif 
        temp = (tanh((1. - cos(thet_s)) / 2.) / 5.16)**(1./0.706)
        fHI_old = temp / (1. - 1.31 * temp)
        do iter = 0, 1000
            fHI = temp * (1. + 1.31 * fHI_old**0.99)
            if (abs((fHI - fHI_old)/(fHI_old + 1.e-20)) < 1.e-4) then
                exit
            else
                fHI_old = fHI
            end if
        end do
        if (diag_output.eq.1) then
         print *, "Calculating fHI..."
         print *, "number of iteration is: ", iter
        endif
        thet_d = acos(1. - 2. * tanh(5.16 * ((Ca + fHI)/(1. + 1.31 * (Ca + fHI)**0.99))**0.706))
        u_slip = 0.

    case (6) !modified Bracke1989

           ! Ca<0 then the model is not validated.
        if (diag_output.eq.1) then
         print *, "Implement model 6 ..."
        endif 
        thet_d = acos(cos(thet_s) -  &
           sign_Ca * 2.0d0 * (1.0d0 + cos(thet_s)) * abs(Ca)**0.5)
        u_slip = 0.0d0

    case (7) !Blake2006, Popescu2008
        print *,"Popescu 2008 model has dimensional parameters; disallowed!"
        stop

        if (diag_output.eq.1) then
         print *, "Implement model 7 ..."
        endif
         ! sigma_0=1.7e-2=0.017  n/m  for water
         ! sigma_0=1.0e-2=0.01   n/m  for oil
         ! v_0=5.0e-3 m/s for water
         ! v_0=1.35e-5 m/s for oil
        sigma_0 = 1.7e-2 !sigma_0 = 1.7e-2 for water and 1.e-2 for oil in Popescu2008
        v_0 = 5.e-3 !v_0 = 5e-3 for water and 1.35e-5 for oil in Popescu2008
        thet_d = acos(cos(thet_s) - sigma_0 / sigma * asinh(u_cl / v_0))
        u_slip = 0.

    case default
        print *, "unknown model index"
        stop
end select


end subroutine dynamic_contact_angle



      subroutine get_vortex_info(x,time,neg_force,vel,vort,energy_moment)
      IMPLICIT NONE

      REAL_T, intent(in) :: x(SDIM)
      REAL_T :: xprime(SDIM)
      REAL_T, intent(in) :: time
      REAL_T, intent(out) :: neg_force(SDIM)
      REAL_T, intent(out) :: vel(SDIM)
      REAL_T, intent(out) :: vort
      REAL_T, intent(out) :: energy_moment
      REAL_T problo(SDIM)
      REAL_T probhi(SDIM)
      REAL_T problen(SDIM)
      REAL_T rr,alpha,alpha_t,alpha_r,r_x,r_y,uy,vx
      REAL_T fx,gy,fy,gx,fxp,gyp,fyp,gxp
      INTEGER_T dir,dir_x,dir_y
      REAL_T decay_term

      if (time.ge.zero) then
       ! do nothing
      else
       print *,"time invalid"
       stop
      endif

      if ((probtype.eq.26).and. &
          ((axis_dir.eq.2).or.(axis_dir.eq.3))) then

       if (SDIM.eq.2) then

        if ((adv_dir.eq.1).or. &
            (adv_dir.eq.2).or. &
            (adv_dir.eq.3)) then

         do dir=1,SDIM
          xprime(dir)=x(dir)
         enddo
         if ((adv_dir.eq.1).or.(adv_dir.eq.3)) then
          xprime(1)=xprime(1)-adv_vel*time
         endif
         if ((adv_dir.eq.2).or.(adv_dir.eq.3)) then
          xprime(2)=xprime(2)-adv_vel*time
         endif
         problo(1)=problox
         problo(2)=probloy
         probhi(1)=probhix
         probhi(2)=probhiy

         do dir=1,SDIM
          problen(dir)=probhi(dir)-problo(dir)
          if (problen(dir).gt.zero) then
           do while (xprime(dir).lt.problo(dir))
            xprime(dir)=xprime(dir)+problen(dir)
           enddo
           do while (xprime(dir).gt.probhi(dir))
            xprime(dir)=xprime(dir)-problen(dir)
           enddo
          else
           print *,"problen invalid"
           stop
          endif
         enddo ! dir=1..sdim

         if ((radblob2.lt.zero).or. &
             (radblob3.le.zero)) then
          print *,"radblob2 or radblob3 invalid"
          stop
         endif

         rr=sqrt((xprime(1)-xblob)**2+(xprime(2)-yblob)**2)-radblob
         energy_moment=rr+radblob

         if (rr+radblob.gt.1.0E-14) then
          alpha=half*vinletgas*(one-tanh(30.0*rr))* &
                (one+radblob2*sin(two*Pi*time/radblob3))
          vel(1)=alpha*(xprime(2)-yblob)       
          vel(2)=-alpha*(xprime(1)-xblob)       
          if ((adv_dir.eq.1).or.(adv_dir.eq.3)) then
           vel(1)=vel(1)+adv_vel
          endif
          if ((adv_dir.eq.2).or.(adv_dir.eq.3)) then
           vel(2)=vel(2)+adv_vel
          endif
          alpha_t=half*vinletgas*(one-tanh(30.0*rr))* &    
                radblob2*cos(two*Pi*time/radblob3)* &
                two*Pi/radblob3
          neg_force(1)=-alpha_t*(xprime(2)-yblob)
          neg_force(2)=alpha_t*(xprime(1)-xblob)       
          alpha_r=half*vinletgas*(tanh(30.0*rr)**2-one)* &    
                (one+radblob2*sin(two*Pi*time/radblob3))*30.0
          r_x=(xprime(1)-xblob)/(rr+radblob)
          r_y=(xprime(2)-yblob)/(rr+radblob)
          uy=alpha_r*r_y*(xprime(2)-yblob)+alpha
          vx=-alpha_r*r_x*(xprime(1)-xblob)-alpha
          vort=abs(uy-vx)
         else if (abs(rr+radblob).le.1.0E-14) then
          vel(1)=zero
          vel(2)=zero
          neg_force(1)=zero
          neg_force(2)=zero
          vort=two*vinletgas*(one+radblob2*sin(two*Pi*time/radblob3))
         else
          print *,"rr invalid"
          stop
         endif

        else
         print *,"adv_dir invalid probtype==26"
         stop
        endif

       else
        print *,"dimension other than 2 is not supported here"
        stop
       endif

      else if ((probtype.eq.26).and.(axis_dir.eq.11)) then

       do dir=1,SDIM
        xprime(dir)=x(dir)
       enddo
       problo(1)=problox
       problo(2)=probloy
       probhi(1)=probhix
       probhi(2)=probhiy
       if (SDIM.eq.3) then
        problo(SDIM)=probloz
        probhi(SDIM)=probhiz
       endif

       if (SDIM.eq.2) then

        if ((adv_dir.ge.1).and.(adv_dir.le.3)) then
         ! do nothing
        else
         print *,"adv_dir invalid probtype==26"
         stop
        endif

        if ((adv_dir.eq.1).or.(adv_dir.eq.3)) then
         xprime(1)=xprime(1)-adv_vel*time
        endif
        if ((adv_dir.eq.2).or.(adv_dir.eq.3)) then
         xprime(2)=xprime(2)-adv_vel*time
        endif

       else if (SDIM.eq.3) then

        if ((adv_dir.ge.1).and.(adv_dir.le.7)) then
         ! do nothing
        else
         print *,"adv_dir invalid"
         stop
        endif

        if ((adv_dir.eq.1).or.(adv_dir.eq.4).or. &
            (adv_dir.eq.5).or.(adv_dir.eq.7)) then
         xprime(1)=xprime(1)-adv_vel*time
        endif
        if ((adv_dir.eq.2).or.(adv_dir.eq.4).or. &
            (adv_dir.eq.6).or.(adv_dir.eq.7)) then
         xprime(2)=xprime(2)-adv_vel*time
        endif
        if ((adv_dir.eq.3).or.(adv_dir.eq.5).or. &
            (adv_dir.eq.6).or.(adv_dir.eq.7)) then
         xprime(SDIM)=xprime(SDIM)-adv_vel*time
        endif

       else
        print *,"dimension bust"
        stop
       endif

       do dir=1,SDIM
        problen(dir)=probhi(dir)-problo(dir)
        if (problen(dir).gt.zero) then
         do while (xprime(dir).lt.problo(dir))
          xprime(dir)=xprime(dir)+problen(dir)
         enddo
         do while (xprime(dir).gt.probhi(dir))
          xprime(dir)=xprime(dir)-problen(dir)
         enddo
        else
         print *,"problen invalid"
         stop
        endif
       enddo ! dir=1..sdim

       energy_moment=zero
       decay_term=exp(-fort_viscconst(1)*eight*Pi*Pi*time)
       alpha=cos(two*Pi*radblob*time)*decay_term

       if ((radblob.eq.zero).and.(fort_viscconst(1).eq.zero)) then
        ! do nothing, ok set of parameters
       else if ((radblob.gt.zero).and. &
                (fort_viscconst(1).eq.zero)) then
        ! do nothing, ok set of parameters
       else if ((radblob.eq.zero).and. &
                (fort_viscconst(1).gt.zero)) then
        ! do nothing, ok set of parameters
       else
        print *,"radblob and/or fort_viscconst(1) must be changed"
        stop
       endif

       if (SDIM.eq.2) then
        dir_x=1
        dir_y=2
        if ((probhix.eq.one).and.(probhiy.eq.one)) then
         ! do nothing
        else
         print *,"probhix or probhiy invalid"
         stop
        endif
       else if (SDIM.eq.3) then

        if ((probhix.eq.one).and. &
            (probhiy.eq.one).and. &
            (probhiz.eq.half)) then
         dir_x=1
         dir_y=2
        else if ((probhix.eq.one).and. &
                 (probhiy.eq.half).and. &
                 (probhiz.eq.one)) then
         dir_x=1
         dir_y=SDIM
        else if ((probhix.eq.half).and. &
                 (probhiy.eq.one).and. &
                 (probhiz.eq.one)) then
         dir_x=2
         dir_y=SDIM
        else
         print *,"probhi x,y, or z invalid"
         stop
        endif

       else
        print *,"dimension bust"
        stop
       endif

       do dir=1,SDIM
        vel(dir)=zero
        neg_force(dir)=zero
       enddo
       fx=sin(two*Pi*xprime(dir_x))
       gy=cos(two*Pi*xprime(dir_y))
       fy=sin(two*Pi*xprime(dir_y))
       gx=cos(two*Pi*xprime(dir_x))
       vel(dir_x)=-alpha*fx*gy
       vel(dir_y)=alpha*fy*gx
       if (SDIM.eq.2) then
        if ((adv_dir.eq.1).or.(adv_dir.eq.3)) then
         vel(1)=vel(1)+adv_vel
        endif
        if ((adv_dir.eq.2).or.(adv_dir.eq.3)) then
         vel(2)=vel(2)+adv_vel
        endif
       else if (SDIM.eq.3) then

        if ((adv_dir.eq.1).or.(adv_dir.eq.4).or. &
            (adv_dir.eq.5).or.(adv_dir.eq.7)) then
         vel(1)=vel(1)+adv_vel
        endif
        if ((adv_dir.eq.2).or.(adv_dir.eq.4).or. &
            (adv_dir.eq.6).or.(adv_dir.eq.7)) then
         vel(2)=vel(2)+adv_vel
        endif
        if ((adv_dir.eq.3).or.(adv_dir.eq.5).or. &
            (adv_dir.eq.6).or.(adv_dir.eq.7)) then
         vel(SDIM)=vel(SDIM)+adv_vel
        endif
       else
        print *,"dimension bust"
        stop
       endif

       alpha_t=-sin(two*Pi*radblob*time)*two*Pi*radblob*decay_term
         
       fxp=gx*two*Pi
       gyp=-fy*two*Pi 
       fyp=gy*two*Pi
       gxp=-fx*two*Pi 
      
       neg_force(dir_x)=alpha_t*fx*gy
       neg_force(dir_y)=-alpha_t*fy*gx

       uy=-alpha*fx*gyp
       vx=alpha*fy*gxp
       vort=abs(uy-vx)
      else
       print *,"get_vortex_info should not have been called"
       stop
      endif

      end subroutine get_vortex_info

      subroutine get_vort_vel_error(time,x,vort,vel,vort_err,vel_err, &
          vort_expect,vel_expect,energy_moment)
      IMPLICIT NONE

      REAL_T, intent(in) :: time
      REAL_T, intent(in) :: x(SDIM)
      REAL_T, intent(in) :: vort
      REAL_T, intent(in) :: vel(SDIM)
      REAL_T, intent(out) :: vort_err
      REAL_T, intent(out) :: vel_err
      REAL_T, intent(out) :: vort_expect
      REAL_T, intent(out) :: energy_moment
      REAL_T, intent(out) :: vel_expect(SDIM)
      REAL_T :: neg_force(SDIM)
      INTEGER_T dir

      do dir=1,SDIM
       vel_expect(dir)=zero
      enddo
      vort_expect=zero
      vort_err=zero
      vel_err=zero
      energy_moment=zero

      if (time.lt.zero) then
       print *,"time invalid"
       stop
      endif
      
      if (probtype.eq.26) then
       if ((axis_dir.eq.2).or.(axis_dir.eq.3)) then
        if ((adv_dir.eq.1).or. &
            (adv_dir.eq.2).or. &
            (adv_dir.eq.3)) then
         if (SDIM.eq.2) then
          call get_vortex_info(x,time,neg_force,vel_expect,vort_expect, &
           energy_moment)
          vort_err=abs(vort_expect-vort)
          do dir=1,SDIM
           vel_err=vel_err+(vel_expect(dir)-vel(dir))**2
          enddo
          vel_err=sqrt(vel_err)
         else
          print *,"sdim invalid"
          stop
         endif
        else
         print *,"adv_dir invalid (2) probtype==26"
         stop
        endif
       else if ((axis_dir.eq.0).or.(axis_dir.eq.1)) then
        ! do nothing
       else if (axis_dir.eq.10) then
        ! do nothing
       else if (axis_dir.eq.11) then ! BCG periodic
        call get_vortex_info(x,time,neg_force,vel_expect,vort_expect, &
          energy_moment)
        vort_err=abs(vort_expect-vort)
        do dir=1,SDIM
         vel_err=vel_err+(vel_expect(dir)-vel(dir))**2
        enddo
        vel_err=sqrt(vel_err)
       else
        print *,"axis_dir invalid"
        stop
       endif
      endif ! probtype.eq.26

      return
      end subroutine get_vort_vel_error

      subroutine get_local_neg_mom_force(x,prev_time,cur_time, &
        dt,update_state,neg_force)
      IMPLICIT NONE

      INTEGER_T update_state
      REAL_T x(SDIM)
      REAL_T prev_time,cur_time,dt
      REAL_T neg_force(SDIM)
      REAL_T vel(SDIM)
      REAL_T vort
      REAL_T energy_moment
      INTEGER_T dir

      do dir=1,SDIM
       neg_force(dir)=zero
      enddo

      if (update_state.eq.1) then
       if ((dt.le.zero).or. &
           (prev_time.lt.zero).or. &
           (abs(cur_time-prev_time-dt).gt.1.0e-5)) then
        print *,"dt, prev_time, or cur_time invalid"
        stop
       endif
      else if (update_state.eq.0) then
       if ((dt.le.zero).or. &
           (prev_time.lt.zero).or. &
           (cur_time.lt.zero)) then
        print *,"dt, prev_time, or cur_time invalid"
        stop
       endif
      else
       print *,"update_state invalid"
       stop
      endif

      if (probtype.eq.26) then
       if ((axis_dir.eq.2).or.(axis_dir.eq.3)) then
        if ((adv_dir.eq.1).or. &
            (adv_dir.eq.2).or. &
            (adv_dir.eq.3)) then
         if (SDIM.eq.2) then
          call get_vortex_info(x,cur_time,neg_force,vel,vort,energy_moment)
         else
          print *,"sdim==3 not implemented yet: get_vortex_info"
          stop
         endif
        else
         print *,"adv_dir invalid probtype==26 (3)"
         stop
        endif
       else if ((axis_dir.eq.0).or.(axis_dir.eq.1)) then
        ! do nothing
       else if (axis_dir.eq.10) then
        ! do nothing
       else if (axis_dir.eq.11) then ! BCG_periodic
        call get_vortex_info(x,cur_time,neg_force,vel,vort,energy_moment)
       else
        print *,"axis_dir invalid"
        stop
       endif
      endif ! probtype.eq.26

      return
      end subroutine get_local_neg_mom_force

      subroutine thermal_offset(xsten,nhalf,temp_offset,gtemp_offset)
      IMPLICIT NONE

      INTEGER_T nhalf
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T temp_offset
      REAL_T gtemp_offset(SDIM)
      REAL_T ACOEF,BCOEF,rval
      INTEGER_T dir

      if (nhalf.lt.1) then
       print *,"nhalf invalid"
       stop
      endif

      if (probhix.le.problox) then
       print *,"probhix invalid"
       stop
      endif

      temp_offset=zero
      do dir=1,SDIM
       gtemp_offset(dir)=zero
      enddo

      if (probtype.eq.82) then

       if (twall.lt.fort_tempconst(1)) then
        print *,"outer temperature must be >= inner"
        stop
       endif

       if (levelrz.eq.0) then

        ! T=A x + B
        ! T_x = A
        ! T_xx = 0
        ! T1=A x1 + B 
        ! T2=A x2 + B 
        ! A(x2 - x1)=T2-T1

        ACOEF=(twall-fort_tempconst(1))/(probhix-problox)
        BCOEF=twall-fort_tempconst(1)+ACOEF*probhix
        rval=xsten(0,1)
        if (ACOEF.lt.zero) then
         print *,"ACOEF invalid"
         stop
        endif
        temp_offset=ACOEF*rval+BCOEF
        gtemp_offset(1)=ACOEF

       else if (levelrz.eq.1) then

        print *,"levelrz invalid for annulus problem"
        stop

       else if (levelrz.eq.3) then

        ! T=A log r + B
        ! T_r = A/r
        ! (r T_r)_r = 0
        ! T1=A log r1 + B 
        ! T2=A log r2 + B 
        ! A(log r2 - log r1)=T2-T1

        if (problox.le.zero) then
         print *,"problox invalid"
         stop
        endif
        ACOEF=(twall-fort_tempconst(1))/log(probhix/problox)
        BCOEF=twall-fort_tempconst(1)+ACOEF*log(probhix)
        rval=xsten(0,1)
        if (rval.le.zero) then
         print *,"rval invalid"
         stop
        endif
        if (ACOEF.lt.zero) then
         print *,"ACOEF invalid"
         stop
        endif
        temp_offset=ACOEF*log(rval)+BCOEF
        gtemp_offset(1)=ACOEF/rval

       else
        print *,"levelrz invalid"
        stop
       endif   
 
      endif ! probtype.eq.82 ?

      end subroutine thermal_offset

       ! called by ESTDT: determine maximum force due to buoyancy. 
      subroutine get_max_denjump(denjump,nmat)
      use global_utility_module

      IMPLICIT NONE

      INTEGER_T nmat,im,im_opp
      REAL_T denjump
      REAL_T denjump_temp

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      denjump=zero

      do im=1,nmat 
       if (is_rigid(nmat,im).eq.0) then
        do im_opp=im+1,nmat
         if (is_rigid(nmat,im_opp).eq.0) then
          denjump_temp=abs(fort_denconst(im)-fort_denconst(im_opp))
          if (denjump_temp.gt.denjump) then
           denjump=denjump_temp
          endif
         else if (is_rigid(nmat,im_opp).eq.1) then
          ! do nothing
         else
          print *,"is_rigid invalid"
          stop
         endif
        enddo ! im_opp
       else if (is_rigid(nmat,im).eq.1) then
        ! do nothing
       else
        print *,"is_rigid invalid"
        stop
       endif
      enddo ! im

      if (probtype.eq.82) then ! rotating annulus
       if (twall.lt.fort_tempconst(1)) then
        print *,"twall invalid"
        stop
       endif
       denjump_temp=abs(fort_drhodt(1)*(twall-fort_tempconst(1)))
       if (denjump_temp.gt.denjump) then
        denjump=denjump_temp
       endif
      endif

      return
      end subroutine get_max_denjump
   
       ! called from FORT_OVERRIDE 
      subroutine init_density_at_depth()
      use global_utility_module
      IMPLICIT NONE

      REAL_T depth,pgrad,a,b,c,tol
      REAL_T surface_den,depth_den
      REAL_T surface_pressure,depth_pressure


      density_at_depth=one

       ! water density where the charge is initially located.
      if ((probtype.eq.42).and.(SDIM.eq.2)) then  ! bubble jetting
       density_at_depth=1.00039080D0
        ! cavitation
      else if ((probtype.eq.46).and.(SDIM.eq.2)) then 
       if ((axis_dir.ge.0).and.(axis_dir.lt.10)) then
        density_at_depth=1.00008343D0
       else if (axis_dir.eq.10) then
        density_at_depth=1.0000423520369408D0 ! 10.22 meters
       else if (axis_dir.eq.20) then
        ! do nothing
       else
        print *,"axis_dir out of range"
        stop
       endif
      else if (fort_material_type(1).eq.13) then

       if (abs(gravity).eq.zero) then
        print *,"gravity invalid"
        stop
       endif

       if (1.eq.0) then
        print *,"abs(gravity)= ",abs(gravity)
        print *,"denconst(1)= ",fort_denconst(1)
       endif

       surface_den=fort_denconst(1)  ! density at top of domain
       depth_den=surface_den

       if (SDIM.eq.2) then
        depth=probhiy-probloy
       else if (SDIM.eq.3) then
        depth=probhiz-probloz
       else
        print *,"dimension bust"
        stop
       endif
 
!       print *,"depth= ",depth

       if (depth.le.zero) then
        print *,"depth invalid"
        stop
       endif
       if (surface_den.le.zero) then
        print *,"surface den invalid"
        stop
       endif
       call EOS_tait_ADIABATIC_rhohydro(surface_den,surface_pressure)
       call EOS_tait_ADIABATIC_rhohydro(depth_den,depth_pressure)
       pgrad=abs(depth_pressure-surface_pressure)/(depth*surface_den)
       do while (pgrad.le.abs(gravity))
        depth_den=two*depth_den
        call EOS_tait_ADIABATIC_rhohydro(depth_den,depth_pressure)
        pgrad=abs(depth_pressure-surface_pressure)/(depth*surface_den)
        if (1.eq.0) then
         print *,"depth_den,pgrad ",depth_den,pgrad
        endif
       enddo ! while (pgrad.le.abs(gravity))
       a=surface_den
       b=depth_den
       c=half*(surface_den+depth_den)
       call EOS_tait_ADIABATIC_rhohydro(c,depth_pressure)
       pgrad=abs(depth_pressure-surface_pressure)/(depth*surface_den)
       tol=abs(gravity)*1.0D-3
       do while (abs(pgrad-abs(gravity)).gt.tol)
        if (1.eq.0) then
         print *,"a,b,c ",a,b,c
         print *,"pgrad ",pgrad
        endif
        if (pgrad.gt.abs(gravity)) then
         b=c
         c=half*(a+b)
        else if (pgrad.lt.abs(gravity)) then
         a=c
         c=half*(a+b)
        else
         print *,"pgrad bust"
         stop
        endif
        call EOS_tait_ADIABATIC_rhohydro(c,depth_pressure)
        pgrad=abs(depth_pressure-surface_pressure)/(depth*surface_den)
       enddo
       density_at_depth=c
      endif  ! material_type(1)=13

      return
      end subroutine init_density_at_depth

       ! Du/Dt=-grad p/rho - omega cross (omega cross r)- 2 omega cross u -
       !       |g|z^hat
       ! omega z^hat cross r r^hat=omega r theta^hat
       ! omega z^hat cross (omega z^hat cross r)=
       ! omega z^hat cross omega r theta^hat = -omega^2 r r^hat
       !  
       ! p=dt( -|g| z + (1/2)Omega^2 r^2 )
       ! force=grad p=dt( -|g| z^hat + Omega^2 r r^hat )
       ! gravity_normalized>0 means that gravity is directed downwards.
       ! if invert_gravity==1, then gravity_normalized<0 (pointing upwards)
       !
       ! called from initpotential. (NAVIERSTOKES_3D.F90)
      subroutine general_hydrostatic_pressure_density( &
        override_density, &
        xpos, &
        gravity_normalized, &
        gravity_dir_parm, &
        angular_velocity, &
        dt,rho,pres, &
        for_hydro,liquid_temp)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T for_hydro 
      INTEGER_T override_density 
      INTEGER_T gravity_dir_parm
      REAL_T angular_velocity
      REAL_T xpos(SDIM)
      REAL_T gravity_normalized
      REAL_T dt,rho,pres,liquid_temp
      INTEGER_T imat
      INTEGER_T from_boundary_hydrostatic

      from_boundary_hydrostatic=0

      if (for_hydro.ne.1) then
       print *,"for_hydro invalid"
       stop
      endif

      if (dt.le.zero) then
       print *,"dt must be positive"
       stop
      endif
      if ((gravity_dir_parm.lt.1).or.  &
          (gravity_dir_parm.gt.SDIM)) then
       print *,"gravity dir invalid"
       stop
      endif

      imat=1

       ! in: general_hydrostatic_pressure_density
      if ((probtype.eq.42).and.(SDIM.eq.2)) then ! bubble jetting
       call tait_hydrostatic_pressure_density(xpos,rho,pres, &
               from_boundary_hydrostatic)
      else if ((probtype.eq.46).and.(SDIM.eq.2)) then ! cavitation

       if ((axis_dir.ge.0).and.(axis_dir.le.10)) then
        call tait_hydrostatic_pressure_density(xpos,rho,pres, &
                from_boundary_hydrostatic)
       else if (axis_dir.eq.20) then ! no gravity for this test problem
        rho=one
        pres=zero
       else
        print *,"axis_dir invalid"
        stop
       endif

       ! rising bubble, compressible nucleate boiling
      else if (fort_material_type(1).eq.13) then 
       call tait_hydrostatic_pressure_density(xpos,rho,pres, &
               from_boundary_hydrostatic)
      else if (fort_material_type(1).eq.0) then

       if (override_density.eq.0) then
        rho=one
        pres=-gravity_normalized*rho*xpos(gravity_dir_parm)
       else if (override_density.eq.1) then

         ! rho=rho(T,Y,z)
        call default_hydrostatic_pressure_density(xpos, &
         rho,pres,liquid_temp, &
         gravity_normalized, &
         imat,override_density)
       else if (override_density.eq.2) then
        ! temperature dependence handled in DIFFUSION_3D.F90
        rho=fort_denconst(imat) 
        pres=-gravity_normalized*rho*xpos(gravity_dir_parm)
       else
        print *,"override_density invalid"
        stop
       endif

      else if (fort_material_type(1).gt.0) then
       rho=one
       pres=-gravity_normalized*rho*xpos(gravity_dir_parm)
      else
       print *,"fort_material_type invalid"
       stop
      endif
    
      if (angular_velocity.lt.zero) then
       print *,"angular_velocity should be nonneg"
       stop
      endif

        ! temperature dependence handled in DIFFUSION_3D.F90
      if (levelrz.eq.0) then
       pres=pres+half*rho*(angular_velocity**2)*(xpos(1)**2)
      else if (levelrz.eq.1) then
       if (SDIM.ne.2) then
        print *,"dimension bust"
        stop
       endif
       if (angular_velocity.ne.zero) then
        print *,"angular_velocity must be 0 for RZ for now"
        stop
       endif
        ! temperature dependence handled in DIFFUSION_3D.F90
      else if (levelrz.eq.3) then
       pres=pres+half*rho*(angular_velocity**2)*(xpos(1)**2)
      else
       print *,"levelrz invalid general hydrostatic pressure density"
       stop
      endif
 
        ! dt multiplied by velocity scale.
      pres=pres*dt/global_pressure_scale

      return
      end subroutine general_hydrostatic_pressure_density

       ! called from presBDRYCOND when material_type(1)==13 TAIT EOS
      subroutine boundary_hydrostatic( &
        xpos,rho,pres)
      use global_utility_module
      IMPLICIT NONE

      REAL_T, intent(in) :: xpos(SDIM)
      REAL_T, intent(inout) :: rho
      REAL_T, intent(inout) :: pres
      INTEGER_T from_boundary_hydrostatic

      from_boundary_hydrostatic=1

       ! first material obeys TAIT EOS
      if (fort_material_type(1).eq.13) then

       if (is_in_probtype_list().eq.1) then
        call SUB_hydro_pressure_density(xpos,rho,pres, &
                from_boundary_hydrostatic)
       else

        if ((probtype.eq.36).or. &   ! bubble in liquid
            (probtype.eq.601).or. &  ! cooling disk
            (probtype.eq.602)) then  ! Rayleigh-Taylor
         if ((probtype.eq.36).and. &
             (axis_dir.eq.10)) then
          print *,"cannot use hydrostatic pressure for heat pipe experiment"
          print *,"modify: tait_hydrostatic_pressure_density for microgravity"
          stop
         endif
         call tait_hydrostatic_pressure_density(xpos,rho,pres, &
                 from_boundary_hydrostatic)
        else
         print *,"expecting probtype=36,601, or 602"
         stop
        endif

       endif

      else
       print *,"expecting liquid to be compressible (Tait EOS)"
       stop
      endif
 
      return
      end subroutine boundary_hydrostatic

       ! only called if override_density=1 or override_density=2
       ! only takes into account fort_drhodz.
      subroutine default_hydrostatic_pressure_density( &
        xpos,rho,pres,liquid_temp, &
        gravity_normalized, &
        imat,override_density)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T imat,nmat,override_density
      REAL_T xpos(SDIM)
      REAL_T rho,pres
      REAL_T gravity_normalized
      REAL_T liquid_temp
      REAL_T denfree,zfree,z_at_depth
      REAL_T energy_free,csqr,max_depth,DrhoDz


      nmat=num_materials
      if ((imat.lt.1).or.(imat.gt.nmat)) then
       print *,"imat invalid"
       stop
      endif

      if ((override_density.ne.1).and. &
          (override_density.ne.2)) then
       print *,"override_density invalid"
       stop
      endif
      if (liquid_temp.lt.zero) then
       print *,"liquid_temp cannot be negative"
       stop
      endif

       ! in default_hydrostatic_pressure_density
      denfree=fort_denconst(imat)
      energy_free=fort_energyconst(imat)
      if (energy_free.gt.zero) then
       ! do nothing
      else
       print *,"energy_free invalid in default_hydrostatic_pressure_density"
       print *,"imat,energy_free= ",imat,energy_free
       stop
      endif

      if (SDIM.eq.2) then
       zfree=probhiy
       z_at_depth=probloy
      else if (SDIM.eq.3) then
       zfree=probhiz
       z_at_depth=probloz
      else
       print *,"sdim invalid"
       stop
      endif

! let z be depth
! rho=rho0 + Az
! p=c^2 rho
! grad p/rho+g=0
! p_z=-(rho0+Az)g
! p=-rho0 g z - Az^2 g/2 +C
! at z=0, p=c^2 rho0=C
! at z=L,
! -rho0 g L - A L^2 g/2 + c^2 rho0=c^2(rho0+A L)
! A( -L^2 g/2 - c^2 L)=rho0 g L
! A=rho0 g/(-L g/2 -c^2)=rho0/(c^2/|g|-L/2)

      call SOUNDSQR_tait(denfree,energy_free,csqr)
      max_depth=zfree-z_at_depth

      if (fort_drhodz(imat).eq.-one) then
       DrhoDz=denfree/(csqr/abs(gravity)-half*max_depth)
      else if (fort_drhodz(imat).ge.zero) then
       DrhoDz=fort_drhodz(imat)
      else
       print *,"fort_drhodz invalid"
       stop
      endif

      if (DrhoDz.lt.zero) then
       print *,"DrhoDz invalid"
       stop
      endif

      if (xpos(SDIM).gt.zfree) then
       rho=denfree
      else
       rho=denfree+DrhoDz*(zfree-xpos(SDIM))
      endif

       ! rho=rho(T,Y,z)
      if (override_density.eq.1) then

       if ((DrhoDz.eq.zero).and. &
           (gravity_normalized.ne.zero)) then
        pres=-gravity_normalized*rho*xpos(SDIM)
       else if (DrhoDz.ne.zero) then
        pres=csqr*rho
       else
        print *,"both DrhoDz and gravity_normalized cannot be 0"
        stop
       endif

       ! temperature dependent buoyancy force term
      else if (override_density.eq.2) then

       pres=-gravity_normalized*rho*xpos(SDIM)

      else
       print *,"override_density invalid"
       stop
      endif

      return
      end subroutine default_hydrostatic_pressure_density

! err is initialized already with the slope error
! pres_in comes from the pressure computed from the compressible
! projection method, not the equation of state.
! err=max(err,VOFTOL)
! this routine called from: FORT_PRESSURE_INDICATOR
      subroutine EOS_error_ind( &
       pressure_error_flag, &
       xsten,nhalf,bfact, &
       vort, &
       pres_in, &
       temp_in, &
       err, &
       imattype, &
       vorterr, &
       pressure_cutoff, &
       temperature_cutoff)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T imattype,pressure_error_flag,nhalf,bfact
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T vort
      REAL_T pres_in(D_DECL(3,3,3))
      REAL_T temp_in(D_DECL(3,3,3))
      REAL_T err
      REAL_T atmos_pres,atmos_den
      REAL_T vorterr
      REAL_T pressure_cutoff
      REAL_T temperature_cutoff
      REAL_T pres_scale
      REAL_T pres_test
      REAL_T xpos(SDIM)
      REAL_T temp_variation
      REAL_T pres_variation
      INTEGER_T dir,side,ii,jj,kk
      INTEGER_T from_boundary_hydrostatic

      from_boundary_hydrostatic=0

      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (nhalf.lt.3) then
       print *,"nhalf invalid eos error ind"
       stop
      endif
      do dir=1,SDIM
       xpos(dir)=xsten(0,dir)
      enddo
      if ((pressure_error_flag.ne.0).and. &
          (pressure_error_flag.ne.1)) then
       print *,"pressure_error_flag invalid"
       stop
      endif
      if (vorterr.eq.zero) then
       ! do nothing
      else if (vorterr.gt.zero) then
       if (vort*global_velocity_scale.gt.vorterr) then
        if (err.lt.VOFTOL) then
         err=VOFTOL
        endif
       endif
      else
       print *,"vorterr invalid"
       stop
      endif

      if (temperature_cutoff.eq.zero) then
       ! do nothing
      else if (temperature_cutoff.gt.zero) then

       temp_variation=zero

       do dir=1,SDIM
        do side=0,1
         ii=0
         jj=0
         kk=0
         if (dir.eq.1) then
          ii=2*side-1
         else if (dir.eq.2) then
          jj=2*side-1
         else if ((dir.eq.3).and.(SDIM.eq.3)) then
          kk=2*side-1
         else
          print *,"dir invalid eos error ind"
          stop
         endif

         temp_variation=temp_variation+ &
          abs(temp_in(D_DECL(2,2,2))- &
              temp_in(D_DECL(2+ii,2+jj,2+kk)))
        enddo
       enddo

       temp_variation=temp_variation/(two*SDIM)

       if (temp_variation.gt.temperature_cutoff) then
        if (err.lt.VOFTOL) then
         err=VOFTOL
        endif
       endif

      else
       print *,"temperature cutoff invalid"
       stop
      endif

      pres_scale=pres_in(D_DECL(2,2,2))*global_pressure_scale
      pres_variation=zero

      if (pressure_cutoff.eq.zero) then
       ! do nothing
      else if (pressure_cutoff.gt.zero) then

       do dir=1,SDIM
        do side=0,1
         ii=0
         jj=0
         kk=0
         if (dir.eq.1) then
          ii=2*side-1
         else if (dir.eq.2) then
          jj=2*side-1
         else if ((dir.eq.3).and.(SDIM.eq.3)) then
          kk=2*side-1
         else
          print *,"dir invalid eos error ind 2"
          stop
         endif

         pres_variation=pres_variation+  &
          abs(pres_in(D_DECL(2,2,2))- &
              pres_in(D_DECL(2+ii,2+jj,2+kk)))
        enddo ! side
       enddo ! dir
       pres_variation=pres_variation/(two*SDIM)
       pres_variation=pres_variation*global_pressure_scale

       if (pressure_error_flag.eq.1) then
        pres_test=pres_variation
       else if (pressure_error_flag.eq.0) then
        pres_test=abs(pres_scale)
       else
        print *,"pressure_error_flag invalid"
        stop
       endif

       if (imattype.eq.0) then
        print *,"pressure cutoff should be 0 for incomp materials"
        stop
       else if ((imattype.ge.1).and. &
                (imattype.le.fort_max_num_eos)) then

         ! pressure comes from the compressible projection method, not
         ! the equation of state.
        if ((pres_scale.le.zero).and.(1.eq.0)) then
         print *,"pressure underflow"
         print *,"imattype=",imattype
         print *,"pres_scale= ",pres_scale
         stop
        endif

        if (imattype.eq.1) then  ! tait EOS
         call tait_hydrostatic_pressure_density(xpos,atmos_den,atmos_pres, &
                 from_boundary_hydrostatic)
        else if ((imattype.ge.2).and. &
                 (imattype.le.fort_max_num_eos)) then
         call general_hydrostatic_pressure(atmos_pres)
        else 
         print *,"imattype invalid EOS_error_ind"
         stop
        endif

        if (pres_test/atmos_pres.gt.pressure_cutoff) then
         if (err.lt.VOFTOL) then
          err=VOFTOL
         endif
        endif

       else
        print *,"imattype invalid EOS_error_ind"
        stop
       endif

      else
       print *,"pressure cutoff invalid"
       stop
      endif

      return
      end subroutine EOS_error_ind


       ! ADIABATIC_EOS_FLAG==0 if pressure does depend on internal energy.
       ! ADIABATIC_EOS_FLAG==1 if pressure does NOT depend on internal energy.
       ! NOT USED ANYMORE, BUT SHOULD STILL BE MAINTAINED FOR REINFORCING
       ! WHAT EACH EOS ASSUMES.
      subroutine ADIABATIC_EOS_FLAG(imattype,flag)
      IMPLICIT NONE

      INTEGER_T imattype,flag


      if (imattype.eq.999) then
       flag=1
      else if (imattype.eq.0) then
       flag=1
      else if (imattype.eq.1) then  ! EOS_tait
       flag=1
      else if (imattype.eq.7) then  ! EOS_tait_rho
       flag=1
      else if (imattype.eq.13) then  ! EOS_tait_rhohydro
       flag=1
      else if (imattype.eq.2) then  ! jwl (adiabatic)
       flag=1
      else if (imattype.eq.8) then  ! air adiabatic
       flag=1
      else if (imattype.eq.9) then  ! EOS_tait_rho3
       flag=1
      else if (imattype.eq.10) then  ! EOS_tait_rho2
       flag=1
      else if (imattype.eq.11) then  ! EOS_koren_rho1
       flag=1
      else if (imattype.eq.12) then  ! EOS_koren_rho2
       flag=1
      else if (imattype.eq.15) then  ! EOS_dodecane
       flag=0
      else if (imattype.eq.19) then  ! EOS_vacuum
       flag=1
      else if (imattype.eq.20) then  ! EOS_tait_vacuum
       flag=1
      else if ((imattype.gt.0).and.(imattype.le.fort_max_num_eos)) then
       flag=0
      else
       print *,"material type invalid"
       stop
      endif

      return
      end subroutine
      
      subroutine debug_EOS(im)
      IMPLICIT NONE

      INTEGER_T im
      INTEGER_T verbose_EOS
      INTEGER_T mat_type
      INTEGER_T nden
      INTEGER_T i,iden
      REAL_T temperature,denlo,denhi,den
      REAL_T internal_energy
      REAL_T pressure
      REAL_T soundsqr
      REAL_T massfrac_parm(num_species_var+1)
      character*2 im_str
      character*4 filename4
      character*5 filename5


      verbose_EOS=0
      mat_type=fort_material_type(im)
      if ((mat_type.gt.0).and.(mat_type.le.fort_max_num_eos)) then
       if (verbose_EOS.eq.1) then
        temperature=fort_tempconst(im)
        print *,"EOS and C2 files when temperature=",temperature
        denlo=fort_density_floor(im)
        denhi=fort_density_ceiling(im)
        nden=1000
        print *,"EOS and C2 files when temperature=",temperature
        print *,"im=",im
        print *,"denlo=",denlo
        print *,"denhi=",denhi
        print *,"nden=",nden

        write(im_str,'(I2)') im
        do i=1,2
         if (im_str(i:i).eq.' ') then
          im_str(i:i)='0'
         endif
        enddo
        write(filename5,'(A3,A2)') 'EOS',im_str
        open(unit=11,file=filename5)
        write(filename4,'(A2,A2)') 'C2',im_str
        open(unit=12,file=filename4)

        do iden=0,nden
         den=denlo+iden*(denhi-denlo)/nden
         call init_massfrac_parm(den,massfrac_parm,im)
         call INTERNAL_material(den,massfrac_parm, &
          temperature,internal_energy, &
          mat_type,im)
         call EOS_material(den,massfrac_parm, &
          internal_energy,pressure,mat_type,im)
         call SOUNDSQR_material(den,massfrac_parm, &
          internal_energy,soundsqr,mat_type,im)
         write (11,*) den,pressure
         write (12,*) den,soundsqr
        enddo ! iden=0..nden

        close(11)
        close(12)
       else if (verbose_EOS.eq.0) then
        ! do nothing
       else
        print *,"verbose_EOS invalid"
        stop
       endif
      else
       print *,"mat_type invalid"
       stop
      endif 
       
      end subroutine debug_EOS

        ! returns p(e*scale)/scale
        ! pressure=p(density=rho,internal_energy)
      subroutine EOS_material(rho,massfrac_parm, &
        internal_energy_in,pressure, &
        imattype,im)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T, intent(in) :: imattype,im
      REAL_T, intent(in) :: rho
      REAL_T, intent(in) :: massfrac_parm(num_species_var+1)
      REAL_T :: internal_energy
      REAL_T, intent(out) :: pressure
      REAL_T, intent(in) :: internal_energy_in
      INTEGER_T :: ispec


      internal_energy=internal_energy_in*global_pressure_scale

      do ispec=1,num_species_var
       if (massfrac_parm(ispec).ge.zero) then
        ! do nothing
       else
        print *,"massfrac_parm invalid"
        stop
       endif
      enddo ! ispec
      if (rho.gt.zero) then
       ! do nothing
      else
       print *,"rho invalid"
       stop
      endif
      if (internal_energy.gt.zero) then
       ! do nothing
      else
       print *,"e invalid"
       stop
      endif

      if (is_in_probtype_list().eq.1) then
       call SUB_EOS(rho,massfrac_parm, &
         internal_energy,pressure, &
         imattype,im)
      else 
       call EOS_material_CORE(rho,massfrac_parm, &
               internal_energy,pressure,imattype,im)
      endif

      pressure=pressure/global_pressure_scale

      return
      end subroutine EOS_material


        ! returns De/DT / scale 
        ! T=(e/scale)*scale/cv
      subroutine DeDT_material(rho,massfrac_parm, &
        temperature,DeDT,imattype,im)
      IMPLICIT NONE

      INTEGER_T, intent(in) :: imattype,im
      REAL_T, intent(in) :: rho,temperature
      REAL_T, intent(in) :: massfrac_parm(num_species_var+1)
      REAL_T, intent(out) :: DeDT
      REAL_T :: DT,T2,e1,e2


      if ((rho.gt.zero).and.(temperature.gt.zero)) then
       ! do nothing
      else
       print *,"rho or temperature invalid in DeDT_material"
       print *,"rho=",rho
       print *,"temperature=",temperature
       print *,"im=",im
       print *,"imattype=",imattype
       stop
      endif

      if (imattype.eq.18) then ! simple_air
       DeDT=one 
      else if ((imattype.eq.15).and.(probtype.eq.541).and. &
          (OLD_DODECANE.eq.0)) then
       call DeDT_dodecane(rho,temperature,DeDT)
      else if ((imattype.eq.999).or. &
               (imattype.eq.0).or. &
               ((imattype.ge.1).and.(imattype.le.fort_max_num_eos))) then
       call INTERNAL_material(rho,massfrac_parm, &
         temperature,e1,imattype,im)
       DT=temperature*1.0E-6
       T2=temperature+DT
       call INTERNAL_material(rho,massfrac_parm, &
         T2,e2,imattype,im)
       DeDT=(e2-e1)/DT
       if (DeDT.le.zero) then
        print *,"e must be increasing function of T"
        stop
       endif
      else
       print *,"imattype invalid DE_dt__material"
       stop
      endif

      return
      end subroutine DeDT_material

        ! in general for gas: e=cv T
        !                     p=(gamma-1)rho e=(gamma-1)rho cv T
        !                      =(cp-cv) rho T=rho R T
        ! total energy per unit mass? = (1/2)u dot u  + e
        ! returns c^2(e*scale)/scale
        ! sound squared=c^2(density=rho,internal_energy)
      subroutine SOUNDSQR_material(rho,massfrac_parm, &
        internal_energy_in,soundsqr, &
        imattype,im)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T, intent(in) :: imattype,im
      REAL_T, intent(in) :: rho
      REAL_T, intent(in) :: massfrac_parm(num_species_var+1)
      REAL_T :: internal_energy
      REAL_T, intent(out) :: soundsqr
      REAL_T, intent(in) :: internal_energy_in
      INTEGER_T :: ispec


      internal_energy=internal_energy_in*global_pressure_scale

      if (rho.gt.zero) then
       ! do nothing
      else
       print *,"rho invalid"
       stop
      endif
      if (internal_energy.gt.zero) then
       ! do nothing
      else
       print *,"e invalid"
       stop
      endif
      do ispec=1,num_species_var
       if (massfrac_parm(ispec).ge.zero) then
        ! do nothing
       else
        print *,"massfrac_parm invalid"
        stop
       endif
      enddo

      if (is_in_probtype_list().eq.1) then
       call SUB_SOUNDSQR(rho,massfrac_parm, &
         internal_energy,soundsqr, &
         imattype,im)
      else 
       call SOUNDSQR_material_CORE(rho,massfrac_parm, &
         internal_energy,soundsqr, &
         imattype,im)
      endif

      soundsqr=soundsqr/global_pressure_scale

      return
      end subroutine SOUNDSQR_material

 
        ! returns e/scale
      subroutine INTERNAL_material_cutoff(rho,internal_energy, &
        imattype,im)
      IMPLICIT NONE

      INTEGER_T, intent(in) :: imattype,im
      REAL_T, intent(in) :: rho
      REAL_T, intent(out) :: internal_energy
      REAL_T :: massfrac_parm(num_species_var+1)
 

      if (rho.gt.zero) then
       ! do nothing
      else
       print *,"rho invalid"
       stop
      endif
      if ((im.lt.1).or.(im.gt.num_materials)) then
       print *,"im invalid69"
       stop
      endif
      call init_massfrac_parm(rho,massfrac_parm,im)

        ! returns e/scale
      call INTERNAL_material(rho,massfrac_parm, &
       fort_tempcutoff(im), &
       internal_energy,imattype,im)

      return
      end subroutine INTERNAL_material_cutoff

        ! returns e/scale
        ! internal energy = e(temperature,density=rho)
      subroutine INTERNAL_material(rho,massfrac_parm, &
        temperature,internal_energy, &
        imattype,im)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T, intent(in) :: imattype,im
      REAL_T, intent(in) :: rho,temperature
      REAL_T, intent(in) :: massfrac_parm(num_species_var+1)
      REAL_T, intent(out) :: internal_energy
      REAL_T local_internal_energy  ! this is an output

      if (rho.gt.zero) then
       ! do nothing
      else
       print *,"rho invalid"
       stop
      endif
      if (temperature.gt.zero) then
       ! do nothing
      else
       print *,"T invalid"
       stop
      endif

      if (is_in_probtype_list().eq.1) then
       call SUB_INTERNAL(rho,massfrac_parm, &
         temperature,local_internal_energy, &
         imattype,im)
      else 
       call INTERNAL_material_CORE(rho,massfrac_parm, &
        temperature,local_internal_energy, &
        imattype,im)
      endif

      internal_energy=local_internal_energy/global_pressure_scale

      return
      end subroutine INTERNAL_material



        ! returns e/scale
      subroutine INTERNAL_ENTROPY_material(rho,entropy,internal_energy, &
        imattype,im)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T, intent(in) :: imattype,im
      REAL_T, intent(in) :: rho
      REAL_T, intent(in) :: entropy
      REAL_T, intent(out) :: internal_energy


      if (rho.le.zero) then
       print *,"rho invalid"
       stop
      endif
      if (entropy.le.zero) then
       print *,"entropy invalid"
       stop
      endif

      if (imattype.eq.999) then
       call INTERNAL_default(rho,entropy,internal_energy,imattype,im)
      else if (imattype.eq.0) then
       call INTERNAL_default(rho,entropy,internal_energy,imattype,im)
      else if (imattype.eq.1) then
       call INTERNAL_tait(rho,entropy,internal_energy)
      else if (imattype.eq.2) then  ! this is adiabatic JWL
       call INTERNAL_jwl(rho,entropy,internal_energy)
      else if (imattype.eq.3) then  ! this is non-adiabatic JWL
       call INTERNAL_ENTROPY_jwl(rho,entropy,internal_energy)
      else if (imattype.eq.4) then
       call INTERNAL_ENTROPY_SF6(rho,entropy,internal_energy)
      else if (imattype.eq.5) then
       call INTERNAL_ENTROPY_air(rho,entropy,internal_energy)
      else if (imattype.eq.14) then
       call INTERNAL_ENTROPY_air_rho2(rho,entropy,internal_energy)
      else if (imattype.eq.6) then
       print *,"define INTERNAL_ENTROPY_Marquina"
       stop
       call INTERNAL_Marquina(rho,entropy,internal_energy)
      else if (imattype.eq.7) then
       call INTERNAL_tait_rho(rho,entropy,internal_energy)
      else if (imattype.eq.13) then
       call INTERNAL_tait_rhohydro(rho,entropy,internal_energy)
      else if (imattype.eq.8) then
       call INTERNAL_airADIABAT(rho,entropy,internal_energy)
      else if (imattype.eq.9) then
       call INTERNAL_tait_rho3(rho,entropy,internal_energy)
      else if (imattype.eq.10) then
       call INTERNAL_tait_rho2(rho,entropy,internal_energy)
      else if (imattype.eq.11) then
       call INTERNAL_koren_rho1(rho,entropy,internal_energy)
      else if (imattype.eq.12) then
       call INTERNAL_koren_rho2(rho,entropy,internal_energy)
      else if (imattype.eq.15) then
       print *,"define INTERNAL_ENTROPY_dodecane"
       stop
       call INTERNAL_dodecane(rho,entropy,internal_energy)
      else if (imattype.eq.16) then
       call INTERNAL_SF6ADIABAT(rho,entropy,internal_energy)
      else if (imattype.eq.17) then
       print *,"define INTERNAL_ENTROPY_stiffened"
       stop
       call INTERNAL_stiffened(rho,entropy,internal_energy,im)
      else if (imattype.eq.19) then
       call INTERNAL_vacuum(rho,entropy,internal_energy)
      else if (imattype.eq.20) then
       call INTERNAL_tait_vacuum(rho,entropy,internal_energy)
      else
       print *,"imattype invalid INTERNAL_ENTROPY_material"
       stop
      endif

      internal_energy=internal_energy/global_pressure_scale

      return
      end subroutine INTERNAL_ENTROPY_material



      subroutine TEMPERATURE_ENTROPY_material(rho,massfrac_parm, &
        entropy,temperature, &
        imattype,im)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T, intent(in) :: imattype,im
      REAL_T, intent(in) :: rho
      REAL_T, intent(in) :: massfrac_parm(num_species_var+1)
      REAL_T, intent(in) :: entropy
      REAL_T :: internal_energy
      REAL_T, intent(out) :: temperature


      if (rho.le.zero) then
       print *,"rho invalid"
       stop
      endif
      if (entropy.le.zero) then
       print *,"entropy invalid"
       stop
      endif

      if (imattype.eq.4) then
       call TEMPERATURE_ENTROPY_SF6(rho,entropy,temperature)
      else
       call INTERNAL_ENTROPY_material(rho,entropy,internal_energy, &
        imattype,im)
       call TEMPERATURE_material(rho,massfrac_parm, &
        temperature,internal_energy, &
        imattype,im)
      endif

      return
      end subroutine TEMPERATURE_ENTROPY_material


       ! extracts temperature from density and internal energy
       ! returns T(e*scale)
      subroutine TEMPERATURE_material(rho,massfrac_parm, &
        temperature,internal_energy_in, &
        imattype,im)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T, intent(in) :: imattype,im
      REAL_T, intent(in) :: rho,internal_energy_in
      REAL_T, intent(in) :: massfrac_parm(num_species_var+1)
      REAL_T internal_energy
      REAL_T, intent(out) :: temperature
      INTEGER_T :: ispec

      internal_energy=internal_energy_in*global_pressure_scale

      if ((im.lt.1).or.(im.gt.num_materials)) then
       print *,"im invalid71"
       stop
      endif
      if (rho.gt.zero) then
       ! do nothing
      else
       print *,"rho invalid"
       stop
      endif
      if (internal_energy.gt.zero) then
       ! do nothing
      else
       print *,"internal energy invalid in temperature material"
       print *,"rho,energy,imat ",rho,internal_energy,imattype 
       stop
      endif
      do ispec=1,num_species_var
       if (massfrac_parm(ispec).ge.zero) then
        ! do nothing
       else
        print *,"massfrac_parm(ispec) invalid"
        stop
       endif
      enddo

      if (is_in_probtype_list().eq.1) then
       call SUB_TEMPERATURE(rho,massfrac_parm, &
         temperature,internal_energy, &
         imattype,im)
      else 
       call TEMPERATURE_material_CORE(rho,massfrac_parm, &
        temperature,internal_energy, &
        imattype,im)
      endif

      return
      end subroutine TEMPERATURE_material



       ! extracts entropy from density and internal energy
       ! returns E(e*scale)
      subroutine ENTROPY_material(rho,entropy,internal_energy_in, &
        imattype,im)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T, intent(in) :: imattype,im
      REAL_T, intent(in) :: rho
      REAL_T, intent(out) :: entropy
      REAL_T :: internal_energy
      REAL_T, intent(in) :: internal_energy_in


      internal_energy=internal_energy_in*global_pressure_scale

      if ((im.le.0).or.(im.gt.num_materials)) then
       print *,"im invalid72"
       stop
      endif
      if (rho.le.zero) then
       print *,"rho invalid"
       stop
      endif
      if (internal_energy.le.zero) then
       print *,"internal energy invalid in entropy material"
       print *,"rho,energy,imat ",rho,internal_energy,imattype 
       stop
      endif

      if (imattype.eq.999) then 
       call TEMPERATURE_default(rho,entropy,internal_energy, &
         imattype,im)
      else if (imattype.eq.0) then
       call TEMPERATURE_default(rho,entropy,internal_energy, &
         imattype,im)
      else if (imattype.eq.1) then
       call TEMPERATURE_tait(rho,entropy,internal_energy)
      else if (imattype.eq.2) then  ! adiabatic JWL
       call TEMPERATURE_jwl(rho,entropy,internal_energy)
      else if (imattype.eq.3) then  ! non-adiabatic JWL
       call ENTROPY_jwl(rho,internal_energy,entropy)
      else if (imattype.eq.4) then
       call ENTROPY_SF6(rho,internal_energy,entropy)
      else if (imattype.eq.5) then
       call ENTROPY_air(rho,internal_energy,entropy)
      else if (imattype.eq.14) then
       call ENTROPY_air_rho2(rho,internal_energy,entropy)
      else if (imattype.eq.6) then
       print *,"define ENTROPY_Marquina"
       stop
       call TEMPERATURE_Marquina(rho,entropy,internal_energy)
      else if (imattype.eq.7) then
       call TEMPERATURE_tait_rho(rho,entropy,internal_energy)
      else if (imattype.eq.13) then
       call TEMPERATURE_tait_rhohydro(rho,entropy,internal_energy)
      else if (imattype.eq.8) then
       call TEMPERATURE_airADIABAT(rho,entropy,internal_energy)
      else if (imattype.eq.9) then
       call TEMPERATURE_tait_rho3(rho,entropy,internal_energy)
      else if (imattype.eq.10) then
       call TEMPERATURE_tait_rho2(rho,entropy,internal_energy)
      else if (imattype.eq.11) then
       call TEMPERATURE_koren_rho1(rho,entropy,internal_energy)
      else if (imattype.eq.12) then
       call TEMPERATURE_koren_rho2(rho,entropy,internal_energy)
      else if (imattype.eq.15) then
       print *,"define ENTROPY_dodecane"
       stop
       call TEMPERATURE_dodecane(rho,entropy,internal_energy)
      else if (imattype.eq.16) then
       call TEMPERATURE_SF6ADIABAT(rho,entropy,internal_energy)
      else if (imattype.eq.17) then
       print *,"define ENTROPY_stiffened"
       stop
       call TEMPERATURE_stiffened(rho,entropy,internal_energy,im)
      else if (imattype.eq.19) then
       call TEMPERATURE_vacuum(rho,entropy,internal_energy)
      else if (imattype.eq.20) then
       call TEMPERATURE_tait_vacuum(rho,entropy,internal_energy)
      else
       print *,"imattype invalid ENTROPY_material"
       print *,"imattype= ",imattype
       stop
      endif

      return
      end subroutine ENTROPY_material



      subroutine ENTROPY_TEMPERATURE_material(rho,massfrac_parm, &
        entropy,temperature_in, &
        imattype,im)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T, intent(in) :: imattype,im
      REAL_T, intent(in) :: rho
      REAL_T, intent(out) :: entropy
      REAL_T :: internal_energy
      REAL_T, intent(in) :: temperature_in
      REAL_T, intent(in) :: massfrac_parm(num_species_var+1)

      if (imattype.eq.4) then
       call ENTROPY_TEMPERATURE_SF6(rho,temperature_in,entropy)
      else
       call INTERNAL_material(rho,massfrac_parm, &
         temperature_in,internal_energy, &
         imattype,im)
       call ENTROPY_material(rho,massfrac_parm, &
        entropy,internal_energy, &
        imattype,im)
      endif

      return
      end subroutine ENTROPY_TEMPERATURE_material


      subroutine get_left_velocityIOWA(t,u_left)

      IMPLICIT NONE
      INTEGER_T k1,k2
      REAL_T t,u_left

      REAL_T shallow_water_data(0:SHALLOW_M,0:SHALLOW_N,2)
      REAL_T inflow_time(3000)
      REAL_T inflow_elevation(3000)
      REAL_T inflow_velocity(3000)
      REAL_T outflow_time(3000)
      REAL_T outflow_elevation(3000)
      REAL_T outflow_velocity(3000)
      INTEGER_T inflow_count,outflow_count
      INTEGER_T last_inflow_index,last_outflow_index
      common /fred_stern_data/ shallow_water_data, &
         inflow_time,inflow_elevation, &
         inflow_velocity,outflow_time,outflow_elevation, &
         outflow_velocity,inflow_count,outflow_count, &
         last_inflow_index,last_outflow_index



      if (probtype.ne.110) then
       print *,"probtype invalid get left velocity"
       stop
      endif
      if (inflow_count.le.0) then
       print *,"inflow_count invalid"
       stop
      endif
     
      do while ((inflow_time(last_inflow_index).gt.t).and. &
                (last_inflow_index.gt.1)) 
       last_inflow_index=last_inflow_index-1
      enddo
      do while ((inflow_time(last_inflow_index).lt.t).and. &
                (last_inflow_index.lt.inflow_count))
       last_inflow_index=last_inflow_index+1
      enddo
      if (t.le.inflow_time(1)) then
       u_left=inflow_velocity(1)
      else if (t.ge.inflow_time(inflow_count)) then
       u_left=inflow_velocity(inflow_count)
      else 

       if (t.le.inflow_time(last_inflow_index)) then
        k1=last_inflow_index-1
       else
        k1=last_inflow_index
       endif
       k2=k1+1
       u_left=inflow_velocity(k1)+ &
        ( (inflow_velocity(k2)-inflow_velocity(k1))/ &
          (inflow_time(k2)-inflow_time(k1)) )*(t-inflow_time(k1))
      endif
      u_left=u_left*100.0  ! convert to cm/s

      return
      end subroutine


      subroutine get_right_velocityIOWA(t,u_right)

      IMPLICIT NONE
      INTEGER_T k1,k2
      REAL_T t,u_right

      REAL_T shallow_water_data(0:SHALLOW_M,0:SHALLOW_N,2)
      REAL_T inflow_time(3000)
      REAL_T inflow_elevation(3000)
      REAL_T inflow_velocity(3000)
      REAL_T outflow_time(3000)
      REAL_T outflow_elevation(3000)
      REAL_T outflow_velocity(3000)
      INTEGER_T inflow_count,outflow_count
      INTEGER_T last_inflow_index,last_outflow_index
      common /fred_stern_data/ shallow_water_data, &
         inflow_time,inflow_elevation, &
         inflow_velocity,outflow_time,outflow_elevation, &
         outflow_velocity,inflow_count,outflow_count, &
         last_inflow_index,last_outflow_index



      if (probtype.ne.110) then
       print *,"probtype invalid get_right_velocity"
       stop
      endif
      if (outflow_count.le.0) then
       print *,"outflow_count invalid"
       stop
      endif
     
      do while ((outflow_time(last_outflow_index).gt.t).and. &
                (last_outflow_index.gt.1)) 
       last_outflow_index=last_outflow_index-1
      enddo
      do while ((outflow_time(last_outflow_index).lt.t).and. &
                (last_outflow_index.lt.outflow_count))
       last_outflow_index=last_outflow_index+1
      enddo
      if (t.le.outflow_time(1)) then
       u_right=outflow_velocity(1)
      else if (t.ge.outflow_time(outflow_count)) then
       u_right=outflow_velocity(outflow_count)
      else 

       if (t.le.outflow_time(last_outflow_index)) then
        k1=last_outflow_index-1
       else
        k1=last_outflow_index
       endif
       k2=k1+1
       u_right=outflow_velocity(k1)+ &
        ( (outflow_velocity(k2)-outflow_velocity(k1))/ &
          (outflow_time(k2)-outflow_time(k1)) )*(t-outflow_time(k1))
      endif
      u_right=u_right*100.0  ! convert to cm/s

      return
      end subroutine


      subroutine get_left_elevationIOWA(t,elevation_left)

      IMPLICIT NONE
      INTEGER_T k1,k2
      REAL_T t,elevation_left

      REAL_T shallow_water_data(0:SHALLOW_M,0:SHALLOW_N,2)
      REAL_T inflow_time(3000)
      REAL_T inflow_elevation(3000)
      REAL_T inflow_velocity(3000)
      REAL_T outflow_time(3000)
      REAL_T outflow_elevation(3000)
      REAL_T outflow_velocity(3000)
      INTEGER_T inflow_count,outflow_count
      INTEGER_T last_inflow_index,last_outflow_index
      common /fred_stern_data/ shallow_water_data, &
         inflow_time,inflow_elevation, &
         inflow_velocity,outflow_time,outflow_elevation, &
         outflow_velocity,inflow_count,outflow_count, &
         last_inflow_index,last_outflow_index



      if (probtype.ne.110) then
       print *,"probtype invalid get_left_elevation"
       stop
      endif
      if (inflow_count.le.0) then
       print *,"inflow_count invalid"
       stop
      endif
     
      do while ((inflow_time(last_inflow_index).gt.t).and. &
                (last_inflow_index.gt.1)) 
       last_inflow_index=last_inflow_index-1
      enddo
      do while ((inflow_time(last_inflow_index).lt.t).and. &
                (last_inflow_index.lt.inflow_count))
       last_inflow_index=last_inflow_index+1
      enddo
      if (t.le.inflow_time(1)) then
       elevation_left=inflow_elevation(1)
      else if (t.ge.inflow_time(inflow_count)) then
       elevation_left=inflow_elevation(inflow_count)
      else 

       if (t.le.inflow_time(last_inflow_index)) then
        k1=last_inflow_index-1
       else
        k1=last_inflow_index
       endif
       k2=k1+1
       elevation_left=inflow_elevation(k1)+ &
        ( (inflow_elevation(k2)-inflow_elevation(k1))/ &
          (inflow_time(k2)-inflow_time(k1)) )*(t-inflow_time(k1))
      endif
      elevation_left=elevation_left*100.0  ! convert to cm

      return
      end subroutine


      subroutine get_right_elevationIOWA(t,elevation_right)

      IMPLICIT NONE
      INTEGER_T k1,k2
      REAL_T t,elevation_right

      REAL_T shallow_water_data(0:SHALLOW_M,0:SHALLOW_N,2)
      REAL_T inflow_time(3000)
      REAL_T inflow_elevation(3000)
      REAL_T inflow_velocity(3000)
      REAL_T outflow_time(3000)
      REAL_T outflow_elevation(3000)
      REAL_T outflow_velocity(3000)
      INTEGER_T inflow_count,outflow_count
      INTEGER_T last_inflow_index,last_outflow_index
      common /fred_stern_data/ shallow_water_data, &
         inflow_time,inflow_elevation, &
         inflow_velocity,outflow_time,outflow_elevation, &
         outflow_velocity,inflow_count,outflow_count, &
         last_inflow_index,last_outflow_index



      if (probtype.ne.110) then
       print *,"probtype invalid get_right_elevation"
       stop
      endif
      if (outflow_count.le.0) then
       print *,"outflow_count invalid"
       stop
      endif
     
      do while ((outflow_time(last_outflow_index).gt.t).and. &
                (last_outflow_index.gt.1)) 
       last_outflow_index=last_outflow_index-1
      enddo
      do while ((outflow_time(last_outflow_index).lt.t).and. &
                (last_outflow_index.lt.outflow_count))
       last_outflow_index=last_outflow_index+1
      enddo
      if (t.le.outflow_time(1)) then
       elevation_right=outflow_elevation(1)
      else if (t.ge.outflow_time(outflow_count)) then
       elevation_right=outflow_elevation(outflow_count)
      else 

       if (t.le.outflow_time(last_outflow_index)) then
        k1=last_outflow_index-1
       else
        k1=last_outflow_index
       endif
       k2=k1+1
       elevation_right=outflow_elevation(k1)+ &
        ( (outflow_elevation(k2)-outflow_elevation(k1))/ &
          (outflow_time(k2)-outflow_time(k1)) )*(t-outflow_time(k1))
      endif
      elevation_right=elevation_right*100.0  ! convert to cm

      return
      end subroutine


SUBROUTINE Adist(xx, yy, dist)
IMPLICIT NONE

REAL_T, INTENT (IN) :: xx
REAL_T, INTENT (IN) :: yy
REAL_T, INTENT (INOUT) :: dist

REAL_T, DIMENSION(4) :: xvec
REAL_T, DIMENSION(4) :: yvec
REAL_T, DIMENSION(4) :: nx
REAL_T, DIMENSION(4) :: ny
REAL_T, DIMENSION(4) :: m

REAL_T :: px, py
REAL_T :: vx, vy
REAL_T :: phi_i, maxval
REAL_T :: mhat
REAL_T :: dist1, dist2, dist3
REAL_T :: eps
INTEGER_T :: i

eps = 0.01
dist = -999.9e9
dist1 = -999.9e9
dist2 = -999.9e9
dist3 = -999.9e9

! Big Triangle !
xvec(1) = 0.0
xvec(2) = 1.0
xvec(3) = -1.0

yvec(1) = 3.0
yvec(2) = 0.0
yvec(3) = 0.0

nx(1) = 3.0/sqrt(10.0)
nx(2) = 0.0
nx(3) = -3.0/sqrt(10.0)

ny(1) = 1.0/sqrt(10.0)
ny(2) = -1.0
ny(3) = 1.0/sqrt(10.0)

m(1) = -3.0
m(2) = 0.0
m(3) = 3.0

maxval = -999.9
do i = 1, 3
	if (i /= 2) then
		!write(*,*) 'i = ', i
		mhat = -1.0/m(i)
		px = (m(i)*xvec(i) - mhat*xx + yy - yvec(i))/(m(i) - mhat)
		py = m(i)*(px - xvec(i)) + yvec(i)
	else	! i == 2, horizontal edge
		!write(*,*) 'i = ', i
		px = xx
		py = yvec(i)
	endif
	
	vx = xx - px
	vy = yy - py
	phi_i = vx*nx(i) + vy*ny(i)
	
	!perr = abs(m(i) - (py - yvec(i))/(px - xvec(i)))
	!write(*,*) 'Projection error = ', perr
	
	if(phi_i > maxval) then
		maxval = phi_i
		!write(*,*) 'i = ', i, 'new phi_i = ', phi_i
	endif
	
	!write(*,*) 'i = ', i, 'nx = ', nx(i), 'ny = ', ny(i), 'vx = ', vx, 'vy = ', vy
enddo

dist1 = maxval
! End Big Triangle !

! Trapezoid !
xvec(1) = 4.0/9.0
xvec(2) = (2.0 + eps)/3.0
xvec(3) = -(2.0 + eps)/3.0
xvec(4) = -4.0/9.0

yvec(1) = 2.0/3.0
yvec(2) = -eps
yvec(3) = -eps
yvec(4) = 2.0/3.0

nx(1) = -3.0/sqrt(10.0)
nx(2) = 0.0
nx(3) = 3.0/sqrt(10.0)
nx(4) = 0.0

ny(1) = -1.0/sqrt(10.0)
ny(2) = 1.0
ny(3) = -1.0/sqrt(10.0)
ny(4) = -1.0

m(1) = -3.0
m(2) = 0.0
m(3) = 3.0
m(4) = 0.0

maxval = 999.9
do i = 1, 4
	if ((i == 1) .OR. (i == 3)) then
		!write(*,*) 'i = ', i
		mhat = -1.0/m(i)
		px = (m(i)*xvec(i) - mhat*xx + yy - yvec(i))/(m(i) - mhat)
		py = m(i)*(px - xvec(i)) + yvec(i)
	else	! i == 2 || 4, horizontal edge
		!write(*,*) 'i = ', i
		px = xx
		py = yvec(i)
	endif
	
	vx = xx - px
	vy = yy - py
	phi_i = vx*nx(i) + vy*ny(i)
	
	!perr = abs(m(i) - (py - yvec(i))/(px - xvec(i)))
	!write(*,*) 'Projection error = ', perr
	
	if(phi_i < maxval) then
		maxval = phi_i
		!write(*,*) 'i = ', i, 'new phi_i = ', phi_i
	endif
	
	!write(*,*) 'i = ', i, 'nx = ', nx(i), 'ny = ', ny(i), 'vx = ', vx, 'vy = ', vy
enddo

dist2 = maxval
! End Trapezoid !

! Little Triangle !
xvec(1) = 0.0
xvec(2) = 1.0/3.0
xvec(3) = -1.0/3.0

yvec(1) = 2.0
yvec(2) = 1.0
yvec(3) = 1.0

nx(1) = -3.0/sqrt(10.0)
nx(2) = 0.0
nx(3) = 3.0/sqrt(10.0)

ny(1) = -1.0/sqrt(10.0)
ny(2) = 1.0
ny(3) = -1.0/sqrt(10.0)

m(1) = -3.0
m(2) = 0.0
m(3) = 3.0

maxval = 999.9
do i = 1, 3
	if ((i == 1) .OR. (i == 3)) then
		!write(*,*) 'i = ', i
		mhat = -1.0/m(i)
		px = (m(i)*xvec(i) - mhat*xx + yy - yvec(i))/(m(i) - mhat)
		py = m(i)*(px - xvec(i)) + yvec(i)
	else	! i == 2, horizontal edge
		!write(*,*) 'i = ', i
		px = xx
		py = yvec(i)
	endif
	
	vx = xx - px
	vy = yy - py
	phi_i = vx*nx(i) + vy*ny(i)
	
	!perr = abs(m(i) - (py - yvec(i))/(px - xvec(i)))
	!write(*,*) 'Projection error = ', perr
	
	if(phi_i < maxval) then
		maxval = phi_i
		!write(*,*) 'i = ', i, 'new phi_i = ', phi_i
	endif
	
	!write(*,*) 'i = ', i, 'nx = ', nx(i), 'ny = ', ny(i), 'vx = ', vx, 'vy = ', vy
enddo

dist3 = maxval
! End Little Triangle !

dist = max(dist1, dist2, dist3)

END SUBROUTINE Adist



      function CLS(phi,eps)
      IMPLICIT NONE
      REAL_T CLS,phi,eps,temp

      temp=phi/(two*eps)
      CLS=half*(sinh(temp)/cosh(temp)+one)

      return
      end function CLS

      function myfact(n)
      INTEGER_T myfact,i,n

      if (n.eq.0) then
       myfact=1
      else
       myfact=1
       do i=2,n
        myfact=myfact*i 
       enddo
      endif

      return
      end function myfact


      subroutine get_pipe_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,nmat)
      use global_utility_module
      use geometry_intersect_module

      IMPLICIT NONE

      INTEGER_T nmat,bfact,nhalf
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T xsten2(-1:1,SDIM)
      REAL_T dx(SDIM)
      REAL_T cenbc(nmat,SDIM)
      REAL_T vfrac(nmat)
      INTEGER_T im

      INTEGER_T dir2,i1,j1,k1,k1lo,k1hi
      REAL_T centroid(nmat,SDIM)
      REAL_T areacentroid(nmat,SDIM)
      REAL_T lsgrid(D_DECL(3,3,3),nmat)
      REAL_T distbatch(nmat)
      REAL_T facearea(nmat)
      REAL_T pipexlo,pipexhi,vfrac_sum
      REAL_T EBVOFTOL
      INTEGER_T nhalf2,isten

      nhalf2=1
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (nhalf.lt.3) then
       print *,"nhalf invalid get pipe vfrac"
       stop
      endif

      if ((probtype.eq.41).and.(axis_dir.eq.4)) then
       if (rigid_count().ne.0) then
        print *,"solid not allowed for comparison with LSA"
        stop
       endif
      else
       if (rigid_count().eq.0) then
        print *,"solid missing for pipe"
        stop
       endif
      endif

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      if (probtype.eq.41) then
       ! do nothing
      else
       print *,"probtype invalid in get pipe vfrac"
       stop
      endif

      pipexlo=problox
      pipexhi=probhix
      if ((axis_dir.eq.1).or. &
          (axis_dir.eq.2).or. &
          (axis_dir.eq.3)) then
       pipexlo=zero
       pipexhi=two*radblob3
      endif

      if (SDIM.eq.2) then
       k1lo=0
       k1hi=0
      else if (SDIM.eq.3) then
       k1lo=-1
       k1hi=1
      else
       print *,"dimension bust"
       stop
      endif

      do i1=-1,1
      do j1=-1,1
      do k1=k1lo,k1hi
       do isten=-1,1
        dir2=1
        xsten2(isten,dir2)=xsten(isten+2*i1,dir2)
        dir2=2
        xsten2(isten,dir2)=xsten(isten+2*j1,dir2)
        if (SDIM.eq.3) then
         dir2=SDIM
         xsten2(isten,dir2)=xsten(isten+2*k1,dir2)
        endif
       enddo ! isten

       call inletpipedist(xsten2(0,1),xsten2(0,2),xsten2(0,SDIM), &
        nmat,distbatch)
       do im=1,nmat
        lsgrid(D_DECL(i1+2,j1+2,k1+2),im)=distbatch(im) 
       enddo
      enddo
      enddo
      enddo
      EBVOFTOL=VOFTOL
      call getvolumebatch(bfact,dx,xsten,nhalf, &
        lsgrid,vfrac, &
        facearea,centroid,areacentroid,nmat,EBVOFTOL,SDIM)
      do im=1,nmat
       do dir2=1,SDIM
        cenbc(im,dir2)=centroid(im,dir2)-xsten(0,dir2)
       enddo
      enddo

      if (rigid_exists(nmat).eq.1) then

       if ((axis_dir.ge.0).and.(axis_dir.le.4)) then

        if ((xsten(0,1).lt.pipexlo).or.(xsten(0,1).gt.pipexhi)) then
         do im=1,nmat
          vfrac(im)=zero
          do dir2=1,SDIM
           cenbc(im,dir2)=zero
          enddo
          if (is_rigid(nmat,im).eq.1) then
           vfrac(im)=one
          endif
         enddo !im=1..nat
        endif
       else if (axis_dir.eq.5) then
        ! do nothing
       else
        print *,"axis_dir invalid"
        stop
       endif
      else if (rigid_exists(nmat).eq.0) then
       ! do nothing
      else
       print *,"rigid exists bust"
       stop
      endif

       ! kluge
      vfrac_sum=zero
      do im=1,nmat
       if (is_rigid(nmat,im).eq.0) then
        vfrac_sum=vfrac_sum+vfrac(im)
       else if (is_rigid(nmat,im).eq.1) then
        ! do nothing
       else
        print *,"is_rigid(nmat,im) invalid"
        stop
       endif
      enddo ! im=1..nmat
      if (vfrac_sum.lt.VOFTOL) then
       vfrac(1)=one
       vfrac(2)=zero
      endif

      return
      end subroutine get_pipe_vfrac

         ! nslope points into the solid
         ! materialdistsolid: dist>0 in solid
      subroutine find_LS_stencil_slope( &
       bfact,dx,xsten0,nhalf0, &
       nslope,time,im)
      use global_utility_module
      use global_distance_module

      IMPLICIT NONE

      INTEGER_T im
      INTEGER_T bfact,nhalf0
      REAL_T xsten0(-nhalf0:nhalf0,SDIM)
      REAL_T dx(SDIM)
      REAL_T nslope(SDIM)
      REAL_T xn,yn,zn,time,mag
      INTEGER_T dir
      INTEGER_T inode,jnode,knode
      INTEGER_T idx_array(3)
      INTEGER_T knodelo,knodehi
      INTEGER_T nmat
      REAL_T dist

      nmat=num_materials
      if ((im.lt.1).or.(im.gt.nmat)) then
       print *,"im invalid73"
       stop
      endif
      if (nhalf0.lt.1) then
       print *,"nhalf0 invalid"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif

      if ((time.ge.zero).and.(time.le.1.0D+20)) then
       ! do nothing
      else if (time.ge.1.0D+20) then
       print *,"WARNING time.ge.1.0D+20 in find_ls_stencil_slope"
      else if (time.lt.zero) then
       print *,"time invalid in find_ls_stencil_slope"
       stop
      else
       print *,"time bust in find_ls_stencil_slope"
       stop
      endif

      if (is_rigid(nmat,im).eq.1) then

       do dir=1,SDIM
        nslope(dir)=zero
       enddo

       if (SDIM.eq.2) then
        knodelo=0
        knodehi=0
       else if (SDIM.eq.3) then
        knodelo=-1
        knodehi=1
       else
        print *,"dimension bust"
        stop
       endif

       do inode=-1,1,2
       do jnode=-1,1,2
       do knode=knodelo,knodehi,2

        idx_array(1)=inode
        idx_array(2)=jnode
        idx_array(3)=knode

        xn=xsten0(inode,1)
        yn=xsten0(jnode,2)
        if (SDIM.eq.2) then
         zn=yn
        else if (SDIM.eq.3) then
         zn=xsten0(knode,SDIM)
        else
         print *,"dimension bust prior to materialdistsolid"
         stop
        endif
        call materialdistsolid(xn,yn,zn,dist,time,im)

        do dir=1,SDIM
         nslope(dir)=nslope(dir)+idx_array(dir)*dist
        enddo

       enddo
       enddo
       enddo ! inode,jnode,knode

       mag=zero
       do dir=1,SDIM
        nslope(dir)=nslope(dir)/ &
          (xsten0(1,dir)-xsten0(-1,dir))
        mag=mag+nslope(dir)**2
       enddo
       mag=sqrt(mag)
       if (mag.eq.zero) then
        do dir=1,SDIM
         nslope(dir)=zero
        enddo
        nslope(SDIM)=one
       else if (mag.gt.zero) then
        do dir=1,SDIM
         nslope(dir)=nslope(dir)/mag
        enddo
       else
        print *,"mag invalid"
        stop
       endif

      else
       print *,"expecting is_rigid(nmat,im)==1"
       stop
      endif

      return
      end subroutine find_LS_stencil_slope

       ! cen in absolute coordinates
       ! returns a volume fraction
      subroutine find_LS_stencil_volume_coarse( &
       bfact,dx,xsten,nhalf, &
       time,vfrac,cen, &
       volbox,cenbox,im)
      use global_utility_module
      use global_distance_module
      use geometry_intersect_module

      IMPLICIT NONE

      INTEGER_T im,bfact,nhalf
      REAL_T time
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T dx(SDIM)
      REAL_T vfrac
      REAL_T cen(SDIM)
      INTEGER_T dir
      REAL_T lnode(4*(SDIM-1))
      INTEGER_T inode,jnode,knode,klo,khi
      INTEGER_T isynth
      REAL_T xn,yn,zn,facearea
      REAL_T areacentroid(SDIM)
      REAL_T volbox
      REAL_T cenbox(SDIM)
      INTEGER_T nmat

      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (nhalf.lt.1) then
       print *,"nhalf invalid find override vfrac coarse"
       stop
      endif

      if ((time.ge.zero).and.(time.le.1.0D+20)) then
       ! do nothing
      else if (time.ge.1.0D+20) then
       print *,"WARNING time.ge.1.0D+20 in find_ls_stencil_volume_coarse"
      else if (time.lt.zero) then
       print *,"time invalid in find_ls_stencil_volume_coarse"
       stop
      else
       print *,"time bust in find_ls_stencil_volume_coarse"
       stop
      endif

      nmat=num_materials

      if ((im.lt.1).or.(im.gt.nmat)) then
       print *,"im invalid74"
       stop
      endif

      if (is_rigid(nmat,im).eq.1) then

       isynth=1
       if (SDIM.eq.2) then
        klo=0
        khi=0
       else if (SDIM.eq.3) then
        klo=-1
        khi=1
       else
        print *,"SDIM invalid"
        stop
       endif

       do knode=klo,khi,2
       do jnode=-1,1,2
       do inode=-1,1,2
        xn=xsten(inode,1)
        yn=xsten(jnode,2)
        if (SDIM.eq.2) then
         zn=yn
        else if (SDIM.eq.3) then
         zn=xsten(knode,SDIM)
        else
         print *,"dimension bust calling materialdistsolid"
         stop
        endif
        call materialdistsolid(xn,yn,zn,lnode(isynth),time,im)
        isynth=isynth+1
       enddo
       enddo
       enddo

        ! returns centroid in absolute coordinate system
       call fast_cell_intersection_grid( &
        bfact,dx,xsten,nhalf, &
        lnode, &
        vfrac,cen,facearea,areacentroid, &
        volbox,cenbox,SDIM)
       if (volbox.le.zero) then
        vfrac=zero
       else
        vfrac=vfrac/volbox
       endif

       if (vfrac.le.VOFTOL) then
        vfrac=zero
        do dir=1,SDIM
         cen(dir)=cenbox(dir)
        enddo
       endif
       if (vfrac.ge.one-VOFTOL) then
        vfrac=one
        do dir=1,SDIM
         cen(dir)=cenbox(dir)
        enddo
       endif

      else
       print *,"is_rigid invalid"
       stop
      endif

      return
      end subroutine find_LS_stencil_volume_coarse

       ! cen in absolute coordinates
      subroutine find_LS_stencil_volume( &
       bfact, &
       dx, &
       xsten,nhalf, &
       nrefine, &
       time, &
       vfrac, &
       cen, &
       im)
      use global_utility_module

      IMPLICIT NONE

      INTEGER_T im
      INTEGER_T nrefine,bfact,nhalf
      REAL_T time
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T xsten2(-1:1,SDIM)
      INTEGER_T nhalf2
      REAL_T dx(SDIM)
      REAL_T vfrac
      REAL_T cen(SDIM)
      INTEGER_T dir
      INTEGER_T inode,jnode,knode,khi
      INTEGER_T nside,iside
      REAL_T dxrefine(SDIM)
      REAL_T vfrac_node
      REAL_T cen_node(SDIM)
      REAL_T volbox,volbox_node
      REAL_T cenbox(SDIM)
      REAL_T cenbox_node(SDIM)
      INTEGER_T nmat

      nmat=num_materials
 
      nhalf2=1

      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (nhalf.lt.1) then
       print *,"nhalf invalid find override vfrac"
       stop
      endif
      if ((nrefine.lt.0).or.(nrefine.gt.2)) then
       print *,"nrefine out of range"
       stop
      endif
      if ((im.lt.1).or.(im.gt.nmat)) then
       print *,"im invalid75"
       stop
      endif

      if (is_rigid(nmat,im).eq.1) then

       nside=1
       do iside=1,nrefine
        nside=nside*2
       enddo
       if (SDIM.eq.2) then
        khi=1
       else if (SDIM.eq.3) then
        khi=nside
       else
        print *,"SDIM invalid"
        stop
       endif

       do dir=1,SDIM
        cen(dir)=zero
        cenbox(dir)=zero
       enddo
       vfrac=zero
       volbox=zero

       do dir=1,SDIM
        dxrefine(dir)=(xsten(1,dir)-xsten(-1,dir))/nside
        if (dxrefine(dir).le.zero) then
         print *,"dxrefine invalid"
         stop
        endif
       enddo ! dir=1..sdim

       do knode=1,khi
       do jnode=1,nside
       do inode=1,nside
        dir=1
        xsten2(-1,dir)=xsten(-1,dir)+(inode-1)*dxrefine(dir)
        dir=2
        xsten2(-1,dir)=xsten(-1,dir)+(jnode-1)*dxrefine(dir)
        if (SDIM.eq.3) then
         dir=SDIM
         xsten2(-1,dir)=xsten(-1,dir)+(knode-1)*dxrefine(dir)
        endif
        do dir=1,SDIM
         xsten2(1,dir)=xsten2(-1,dir)+dxrefine(dir)
         xsten2(0,dir)=(xsten2(-1,dir)+xsten2(1,dir))/two
        enddo

        call find_LS_stencil_volume_coarse( &
         bfact,dx,xsten2,nhalf2, &
         time,vfrac_node,cen_node, &
         volbox_node,cenbox_node,im)

        vfrac=vfrac+vfrac_node*volbox_node
        volbox=volbox+volbox_node
        do dir=1,SDIM
         cenbox(dir)=cenbox(dir)+cenbox_node(dir)*volbox_node
         cen(dir)=cen(dir)+cen_node(dir)*vfrac_node*volbox_node
        enddo 
       enddo
       enddo
       enddo

       if (volbox.le.zero) then
        vfrac=zero
        do dir=1,SDIM
         cenbox(dir)=xsten(0,dir)
        enddo
       else
        vfrac=vfrac/volbox
        do dir=1,SDIM
         cenbox(dir)=cenbox(dir)/volbox
         if (vfrac.ge.VOFTOL) then
          cen(dir)=cen(dir)/(vfrac*volbox)
         endif
        enddo ! dir
       endif

       if (vfrac.le.VOFTOL) then
        vfrac=zero
        do dir=1,SDIM
         cen(dir)=cenbox(dir)
        enddo
       endif
       if (vfrac.ge.one-VOFTOL) then
        vfrac=one
        do dir=1,SDIM
         cen(dir)=cenbox(dir)
        enddo
       endif

      else
       print *,"is_rigid invalid"
       stop
      endif

      return
      end subroutine find_LS_stencil_volume


      subroutine inletpipedist(x,y,z,nmat,dist)
      use global_utility_module
      use global_distance_module

      IMPLICIT NONE

      INTEGER_T im,nmat
      REAL_T dist(nmat)
      REAL_T x,y,z,ht,rr,initial_time
      INTEGER_T im_solid_pipe


      if ((SDIM.eq.2).and.(abs(z-y).gt.VOFTOL)) then
       print *,"z<>y in inletpipedist"
       stop
      endif

      im_solid_pipe=im_solid_primary()

      initial_time=zero

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      if (probtype.eq.41) then
       ! do nothing
      else
       print *,"probtype invalid for inlet pipedist"
       stop
      endif

      if ((axis_dir.lt.0).or.(axis_dir.gt.5)) then
       print *,"axis dir invalid for pipe problem"
       stop
      endif

      if (axis_dir.eq.0) then

       if (SDIM.eq.2) then
        dist(1)=xblob+radblob*cos(two*Pi*y/yblob)-x
       else if (SDIM.eq.3) then
        rr=sqrt(y**2+z**2)
        dist(1)=rr-zblob-radblob*sin(two*Pi*x/xblob)
       else
        print *,"dimension bust"
        stop
       endif

      else if ((axis_dir.eq.1).or. &
               (axis_dir.eq.2).or. &
               (axis_dir.eq.3)) then

       if (SDIM.eq.3) then
        dist(1)=z-zblob-radblob*sin(two*Pi*x/xblob) 
       else if (SDIM.eq.2) then
        dist(1)=abs(x)-xblob-radblob*sin(two*Pi*y/yblob)
        if (axis_dir.eq.2) then ! gas in the middle
         ht=radblob2+radblob*sin(two*Pi*y/yblob)
         if (x.gt.xblob) then
          dist(1)=x-(xblob+ht)
         else
          dist(1)=(xblob-ht)-x
         endif
        endif
        if (axis_dir.eq.3) then ! blowout problem
         dist(1)=y
        endif
       else
        print *,"dimension bust"
        stop
       endif

      else if (axis_dir.eq.4) then

       dist(1)=abs(x)-xblob-radblob*sin(two*Pi*y/yblob)
       dist(1)=-dist(1)

      else if (axis_dir.eq.5) then

       dist(1)=-99999.0

      else 
       print *,"axis dir invalid"
       stop
      endif

      dist(2)=-dist(1)
      do im=3,nmat
       dist(im)=-99999.0
      enddo

        ! axis_dir=4 is the comparison with Linear Stability Analysis
      if (axis_dir.ne.4) then
       if ((im_solid_pipe.lt.1).or. &
           (im_solid_pipe.gt.nmat)) then
        print *,"im_solid_pipe invalid 2"
        stop
       endif
         ! in inlet_pipe_dist; positive in solid
       call materialdistsolid(x,y,z,dist(im_solid_pipe),initial_time, &
        im_solid_pipe)
      endif

      return
      end subroutine inletpipedist

      subroutine get_pipe_velocity(xsten,nhalf,dx,bfact,vel,time)
      use global_utility_module

      IMPLICIT NONE

      INTEGER_T nhalf,bfact
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T x,y,z,r,time
      REAL_T dx(SDIM)
      REAL_T cenbc(num_materials,SDIM)
      REAL_T vel(SDIM)
      REAL_T VOF(num_materials)
      INTEGER_T dir2,nmat
      INTEGER_T im_solid_pipe
      REAL_T x_vel,y_vel,z_vel

      im_solid_pipe=im_solid_primary()

      if (nhalf.lt.3) then
       print *,"nhalf invalid get pipe velocity"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif

      nmat=num_materials

      if (probtype.eq.41) then
       ! do nothing
      else 
       print *,"probtype invalid in get pipe velocity"
       stop
      endif

      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)

      if (SDIM.eq.2) then
       if (abs(z-y).gt.VOFTOL) then
        print *,"expecting z=y in 2d 6"
        stop
       endif
      endif

      if ((axis_dir.lt.0).or.(axis_dir.gt.5)) then
       print *,"get_pipe_velocity: axis dir invalid for pipe problem"
       stop
      endif

      do dir2=1,SDIM
       vel(dir2)=zero
      enddo

      call get_pipe_vfrac(xsten,nhalf,dx,bfact,VOF,cenbc,nmat)  

        ! axis_dir=4 is LSA comparison
      if (axis_dir.eq.4) then

       if (VOF(1).gt.zero) then
        if (time.gt.zero) then
         vel(SDIM)=vinletgas
        else if (time.eq.zero) then
         vel(SDIM)=yblob4
        else
         print *,"time invalid in get pipe velocity"
         print *,"time= ",time
         print *,"vof1,vof2 ",VOF(1),VOF(2)
         print *,"axis_dir ",axis_dir
         stop
        endif
       else if ((VOF(1).eq.zero).and.(VOF(2).gt.zero)) then
        if (time.gt.zero) then
         vel(SDIM)=advbot
        else if (time.eq.zero) then
         vel(SDIM)=xblob4
        else
         print *,"time invalid in get pipe velocity"
         print *,"time= ",time
         print *,"vof1,vof2 ",VOF(1),VOF(2)
         print *,"axis_dir ",axis_dir
         stop
        endif
       endif
      else if (axis_dir.eq.3) then
       if ((im_solid_pipe.lt.1).or. &
           (im_solid_pipe.gt.nmat)) then
        print *,"im_solid_pipe invalid 2.9"
        stop
       endif
       if (VOF(im_solid_pipe).gt.zero) then
        vel(SDIM)=zero
       else if (z.ge.VOFTOL*dx(SDIM)) then !y=z if 2D
        if (time.gt.zero) then
         vel(SDIM)=vinletgas
        else if (time.eq.zero) then
         vel(SDIM)=yblob4
        else
         print *,"time invalid in get pipe velocity"
         print *,"time= ",time
         print *,"vof1,vof2 ",VOF(1),VOF(2)
         print *,"axis_dir ",axis_dir
         stop
        endif
       else if (z.le.VOFTOL*dx(SDIM)) then ! y=z if 2D
        if (time.gt.zero) then
         vel(SDIM)=advbot
        else if (time.eq.zero) then
         vel(SDIM)=xblob4
        else
         print *,"time invalid in get pipe velocity"
         print *,"time= ",time
         print *,"vof1,vof2 ",VOF(1),VOF(2)
         print *,"axis_dir ",axis_dir
         stop
        endif
       endif

      else if ((axis_dir.eq.0).or. &
               (axis_dir.eq.1).or. &
               (axis_dir.eq.2)) then

       if ((im_solid_pipe.lt.1).or. &
           (im_solid_pipe.gt.nmat)) then
        print *,"im_solid_pipe invalid 3"
        stop
       endif
       if (VOF(im_solid_pipe).gt.zero) then
        vel(SDIM)=zero
       else if (VOF(1).gt.zero) then
        if (time.gt.zero) then
         vel(SDIM)=vinletgas
        else if (time.eq.zero) then
         vel(SDIM)=yblob4
        else
         print *,"time invalid in get pipe velocity"
         print *,"time= ",time
         print *,"vof1,vof2 ",VOF(1),VOF(2)
         print *,"axis_dir ",axis_dir
         stop
        endif
       else if ((VOF(1).eq.zero).and.(VOF(2).gt.zero)) then
        if (time.gt.zero) then
         vel(SDIM)=advbot
        else if (time.eq.zero) then
         vel(SDIM)=xblob4
        else
         print *,"time invalid in get pipe velocity"
         print *,"time= ",time
         print *,"vof1,vof2 ",VOF(1),VOF(2)
         print *,"axis_dir ",axis_dir
         stop
        endif
       endif
 
       ! above: axis_dir=0,1,2 (and above that 3,4)

      else if (axis_dir.eq.5) then

       if (SDIM.eq.3) then
        ! do nothing
       else if (SDIM.eq.2) then
        z=zero
       else
        print *,"dimension bust"
        stop
       endif
       r = sqrt(y*y+z*z)
     
       if (r.gt.radblob) then
        x_vel=zero
       else 
        x_vel=adv_vel*r*(radblob-r)
       endif
       y_vel=zero
       z_vel=zero
       if((z-0.3)**2+(y-0.3)**2+(x-0.5)**2.le.0.4)then
         x_vel = .3d0
         y_vel = .4d0
         z_vel = -.2d0
       else if((z+0.3)**2+(y-1.7)**2+(x-5.5)**2.le.0.4)then
         x_vel = -.3d0
         y_vel = -.4d0
         z_vel = .2d0
       else if((z-0.9)**2+(y)**2+(x-1.5)**2.le.1.)then
         x_vel = -x_vel
         y_vel = -y_vel
         z_vel = -z_vel 
       else if((z+0.9)**2+(y)**2+(x-3.5)**2.le.1.)then
         x_vel = -y_vel
         y_vel = -x_vel
         z_vel = -z_vel 
       else if((z)**2+(y)**2+(x-2.5)**2.le.0.1)then
         x_vel = -z_vel
         y_vel = -y_vel
         z_vel = -x_vel 
       endif
       vel(1)=x_vel
       vel(2)=y_vel
       if (SDIM.eq.3) then
        vel(SDIM)=z_vel
       endif
      else
       print *,"axis_dir invalid"
       stop
      endif

      return
      end subroutine get_pipe_velocity


! time is in microseconds, LL is in microns,PTERM is in atmospheres
! 1atm=1.013x10^6 dyne/cm^2

      subroutine microfabpressure(LL,PTERM,time)

      use global_distance_module

      IMPLICIT NONE
      REAL_T LL,PTERM,time
      REAL_T realtime,realpress
      INTEGER_T error


      REAL_T NOD,NID,NPT,CHH,CHW,JLEN

      call microfabparm(NOD,NID,NPT,CHH,CHW,JLEN)

      LL=half*(JLEN-NPT)
! simple pressure 2
! assume flat meniscus, so quiescent pressure is 1atm
      if (axis_dir.eq.13) then
       PTERM=zero
      else
       if (time.le.6.0) then
        PTERM=0.7-1.0
       else if (time.le.14.0) then
        PTERM=1.8-1.0
       else if (time.le.21.0) then
        PTERM=0.2-1.0
       else if (time.le.28.0) then
        PTERM=1.2-1.0
       else 
        PTERM=zero
       endif

       realtime=time*1.0D-6
       call pressure_bc(realpress,realtime,error)
       PTERM=realpress/1.00D+06 - one 
      endif
            
      return
      end subroutine

      subroutine microfabdist(rr,z,dist)

      use global_distance_module

      IMPLICIT NONE
      REAL_T x,y,z,rr,dist


      REAL_T NOD,NID,NPT,CHH,CHW,JLEN,incline

      call microfabparm(NOD,NID,NPT,CHH,CHW,JLEN)

      if (SDIM.eq.2) then

      incline=JLEN 
      if (rr.le.half*NOD) then
       if (axis_dir.eq.12) then
        incline=JLEN+sqrt(16.9**2-(half*NOD)**2)-sqrt(16.9**2-rr**2)
       endif
       dist=incline-z
      else
       if (rr.le.half*(NPT+NOD)) then
        dist=incline-z-(rr-half*NOD)
       else
        dist=incline-z-half*NPT
       endif
      endif

      else if (SDIM.eq.3) then

      if (axis_dir.eq.13) then
       xblob=zero
       yblob=zero
      endif

      rr=sqrt( (x-xblob)**2 + (y-yblob)**2 )

      incline=JLEN
      if (rr.le.half*NOD) then
       if (axis_dir.eq.7) then
        incline=JLEN+sqrt(16.9**2-(half*NOD)**2)-sqrt(16.9**2-rr**2)
       endif
       dist=incline-z
      else
       if (rr.le.half*NID) then
        dist=incline-z-(rr-half*NOD)
       else
        dist=incline-z-half*(NID-NOD)
       endif
      endif

      else
       print *,"dimension bust"
       stop
      endif

      return
      end subroutine
 
      subroutine pressure_bc( press, t    , error )
      IMPLICIT NONE

!     * Return the pressure boundary condition at time t provided by MicroFab
!     *  for the Okidata problems.

!     * CAUTION! Pressure is in dynes/ cm^2 and time is in seconds!
      
!     * This routine assumes that time is measured in seconds, the time values
!     * are equally spaced with spacing dt and that the pressure values are 
!     * known up to time t = 7.00D-05. For the MicroFab 
!     * test problems j= 0 ... = 70.  However,  to allow for future use of this
!     * type of BC, the size of the arrays time and pressbc may have to be 
!     * increased or passed as an argument to this subroutine.  Right now the
!     * number of data points in press_file is hard coded to be 70.

!     * Variables passed in ...

      INTEGER_T   error  
      
      real*8    press       , t
      
!     * The array pressbc(i,j).  The first array contains the time t, the
!     * second contains the value of the pressure on the inflow boundary at
!     * time t.

      real*8  sigma    

!     INTEGER_T  1234567890, 1234567890, 1234567890, 1234567890, 1234567890

      INTEGER_T  j         
      
      error = 0
      j = int(t / dt_pressure_bcs)
      
      if (t .gt. 7.00D-05) then

!       * From 70 microseconds on, the pressure BC is 1 atm
        
        press = 1.00D+06
        
      else if ((time_pressure_bcs(j) .le. t) .and.  &
               (t .le. time_pressure_bcs(j+1))) then
        
!       * Lineraly interpolate between the given time values.
        
        sigma = (t - time_pressure_bcs(j)) /dt_pressure_bcs
        press = (1 - sigma) *  &
          pressbc_pressure_bcs(j,selectpress) +  &
          sigma * pressbc_pressure_bcs(j+1,selectpress) 
        
      else
       error = -1
       print *,"error in pressure_bc, t= ",t
       stop
      end if

      return
      end subroutine

!
!     * This is a subroutine for setting inflow B.C.(Poiseuille flow)
!     * Nozzle radius (cm)   
!     probtype.eq.25 and axis_dir.gt.0
!
      subroutine bubble_formation_inflow_bc(xsten,nhalf,x,phi)
      IMPLICIT NONE

      INTEGER_T nhalf
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T delta
      REAL_T aveQ,aveV,radius,diameter,x,phi
      REAL_T density,  viscosity,  sigma
      REAL_T Weber,Reynolds,Froude
      INTEGER_T old_flag,Bright_flag

      if (nhalf.lt.1) then
       print *,"nhalf invalid bubble formation inflow bc"
       stop
      endif
      if (probtype.eq.25) then

       old_flag=0
       Bright_flag=1

       if (old_flag.eq.1) then
        radius=0.127
       else if (old_flag.eq.0) then
        if (Bright_flag.eq.0) then
         radius=0.05
        else if (Bright_flag.eq.1) then
         radius=0.08
        else
         print *,"Bright_flag invalid"
         stop
        endif
       else
        print *,"old_flag invalid"
        stop
       endif

       diameter=two*radius

       if (old_flag.eq.1) then

        if (axis_dir.eq.1) then
         aveQ = 1.3D-2
        else if (axis_dir.eq.2) then
         aveQ = 4.8D-2
        else if (axis_dir.eq.3) then
         aveQ = 2.0D-1
        else if (axis_dir.eq.4) then
         aveQ = 5.0D-1
        else if (axis_dir.eq.5) then
         aveQ = 1.1
        else if (axis_dir.eq.6) then
         aveQ = two
        else if (axis_dir.eq.7) then
         aveQ = five
        else if (axis_dir.eq.8) then
         aveQ = 6.8
        else if (axis_dir.eq.9) then
         aveQ = 7.2
        else if (axis_dir.eq.10) then
         aveQ = 15.0
        else if (axis_dir.eq.11) then
         aveQ = 20.0
        else
         print *,"axis_dir invalid for bubble formation"
         stop
        endif
        aveV=aveQ/(Pi*(radius**2))

        density=0.996
        sigma=51.1
        viscosity=0.00958

       else if (old_flag.eq.0) then

        if (axis_dir.eq.1) then
         aveV = 10.0D0
        else if (axis_dir.eq.2) then
         aveV = 20.0D0
        else if (axis_dir.eq.3) then
         aveV = 30.0D0
        else if (axis_dir.eq.4) then
         aveV = 40.0D0
        else if (axis_dir.eq.5) then
         aveV = 50.0D0
        else if (axis_dir.eq.6) then
         aveV = 60.0D0
        else if (axis_dir.eq.7) then
         aveV = 70.0D0
        else if (axis_dir.eq.8) then
         aveV = 80.0D0
        else if (axis_dir.eq.9) then
         aveV = 90.0D0
        else if (axis_dir.eq.10) then
         if (Bright_flag.eq.0) then
          aveV = 100.0D0
         else if (Bright_flag.eq.1) then
          aveV = 44.0D0
         else
          print *,"Bright_flag invalid"
          stop
         endif
        else
         print *,"axis_dir invalid for bubble formation"
         stop
        endif

        if (Bright_flag.eq.0) then
         density=0.9
         viscosity=10.0
         sigma=25.0
        else if (Bright_flag.eq.1) then
         density=0.732
         viscosity=0.0099
         sigma=22.5
        else
         print *,"Bright_flag invalid"
         stop
        endif

       else
        print *,"old flag invalid"
        stop
       endif

       Weber=(aveV**2)*radius*density/sigma
       Reynolds=density*radius*aveV/viscosity
       Froude=(aveV**2)/(radius*980.0)

       if (1.eq.0) then
        print *,"Weber,Reynolds,Froude ",Weber,Reynolds,Froude
        print *,"1/Weber,1/Reynolds,1/Froude ",one/Weber, &
          one/Reynolds,one/Froude
        stop
       endif
       phi=zero
       aveV=one
       radius=radblob
       if (abs(x).le.radius) then
        delta=xsten(1,1)-xsten(-1,1)
        if (delta.le.zero) then
         print *,"delta invalid bubble_formation_inflow_bc"
         stop
        endif
        phi=two*aveV*(1.0-(abs(x)/radius)**2-((delta/radius)**2)/four) 
       endif

      else
       print *,"need probtype.eq.25 in bubble_formation_inflow_bc"
       stop
      endif

      return
      end subroutine bubble_formation_inflow_bc

      subroutine vbc( velocity, t , yval,zval, error )

      use global_distance_module

      IMPLICIT NONE
! velocity is in m/s (or microns/microseconds), t is in microseconds
! zval in microns

      INTEGER_T   error  
      
      real*8    velocity, t, yval,zval
      
      INTEGER_T  i,j,istar,jstar 
      real*8 zdiff,tdiff,tlocal
      
      REAL_T NOD,NID,NPT,CHH,CHW,JLEN

      tlocal=t
      if (tlocal.lt.timehist_velbc(0)) then
       tlocal=timehist_velbc(0)
      endif

      error = 0
      call microfabparm(NOD,NID,NPT,CHH,CHW,JLEN)
!     print *,"in vbc yval,jlen-npt-193,tlocal,period,t(it) ",yval,
!    &  JLEN-NPT-193.0,tlocal,period_velbc,timehist(itime_velbc)
      if ((yval.le.half).or.(yval.ge.JLEN-NPT-193.0)) then
       velocity=zero
      else

      if (tlocal.gt.period_velbc) then
       velocity=zero
      else
       if (tlocal.ge.timehist_velbc(itime_velbc)) then
        velocity=zero
       else
        do j=0,itime_velbc-1
         if ((timehist_velbc(j).le.tlocal).and. &
             (timehist_velbc(j+1).ge.tlocal)) then
          jstar=j
         endif
        enddo
        if (AMREX_SPACEDIM.eq.2) then
         zval=half*zpos_velbc(ipos_velbc)
        endif
        if (zval.ge.zpos_velbc(ipos_velbc)) then
         velocity=zero
        else if (zval.le.zpos_velbc(1)) then
         velocity=zero
        else
         do i=1,ipos_velbc-1
          if ((zpos_velbc(i).le.zval).and. &
              (zpos_velbc(i+1).ge.zval)) then
           istar=i
          endif
         enddo
         tdiff=(timehist_velbc(jstar+1)-tlocal)/ &
           (timehist_velbc(jstar+1)-timehist_velbc(jstar))
         zdiff=(zpos_velbc(istar+1)-zval)/ &
           (zpos_velbc(istar+1)-zpos_velbc(istar))
         velocity=zdiff*tdiff*velbc_velbc(jstar,istar)+ &
           zdiff*(one-tdiff)*velbc_velbc(jstar+1,istar)+ &
           (one-zdiff)*tdiff*velbc_velbc(jstar,istar+1)+ &
           (one-zdiff)*(one-tdiff)*velbc_velbc(jstar+1,istar+1)
        endif
       endif
      endif
! tlocal in range
      endif
! yval in range          
      return
      end subroutine

      subroutine readpress( press_file, error )
      IMPLICIT NONE

!     * Read in the pressure boundary conditions provided by MicroFab for the 
!     * Okidata problems and store in the array pressbc. 

!     * This routine assumes that time is measured in seconds, the time values
!     * are equally spaced with spacing dt and that the pressure values are 
!     * known up to time t = 7.00D-05. For the MicroFab 
!     * test problems j= 0 ... = 70.  However,  to allow for future use of this
!     * type of BC, the size of the arrays time and pressbc may have to be 
!     * increased or passed as an argument to this subroutine.  Right now the
!     * number of data points in press_file is hard coded to be 71.

!     * Variables passed in ...

      character press_file*20

      INTEGER_T   error  
      
! element 1-complicated 2-simple1 3-simple2


!     INTEGER_T  1234567890, 1234567890, 1234567890, 1234567890, 1234567890

      INTEGER_T  j         
      
!     * Open the data file containing the pressure BCs.  The name of the file
!     * is passed as an argument to the subroutine.

!      open(7, file=press_file, form="formatted", status="old", err=900)

      selectpress=1
      print *,"selectpress = ",selectpress

      do j = 0, 70
         
!        read(7,100) time_pressure_bcs(j), &
!         pressbc_pressure_bcs(j,1),  &
!         pressbc_pressure_bcs(j,2),  &
!         pressbc_pressure_bcs(j,3)
        
      end do
 
!      close(7)
 
      do j=0,70
!      print *,"time,pressure ", &
!        time_pressure_bcs(j), &
!        pressbc_pressure_bcs(j,selectpress)
      enddo

      dt_pressure_bcs = time_pressure_bcs(1) -  &
        time_pressure_bcs(0)
      error = 0
      
      return
      
! 100   format(' ', e10.6, e9.6, e9.6, e9.6 )
! 900   write(6,910) press_file
! 910   format(" Can't open file = ",a," stopping ...")

      error = -1
      
      return
      end subroutine

      subroutine readvel( vel_file, error )
      IMPLICIT NONE

      character vel_file*20

      INTEGER_T   error  
! time is in microseconds, velocity in meter/s, zpos in microns 
    
      INTEGER_T  i,j         

      period_velbc=28.0
      rigidwall_velbc=180.0
      itime_velbc=11
      ipos_velbc=11
      
!      open(7, file=vel_file, form="formatted", status="old", err=901)

!      read(7,101) timehist_velbc(0),zpos_velbc(1),zpos_velbc(2), &
!       zpos_velbc(3),zpos_velbc(4),zpos_velbc(5), &
!       zpos_velbc(6),zpos_velbc(7),zpos_velbc(8), &
!       zpos_velbc(9),zpos_velbc(10)
      zpos_velbc(11)=rigidwall_velbc

      do j = 0, itime_velbc
!       read(7,102) timehist_velbc(j),velbc_velbc(j,1),velbc_velbc(j,2), &
!        velbc_velbc(j,3),velbc_velbc(j,4), &
!        velbc_velbc(j,5),velbc_velbc(j,6),velbc_velbc(j,7), &
!        velbc_velbc(j,8),velbc_velbc(j,9),velbc_velbc(j,10)
       velbc_velbc(j,11)=zero
      end do
!  101 format(f7.2,f7.2,f7.2,f7.2,f7.2,f7.2,f7.2,f7.2,f7.2,f7.2,f7.2)  
!  102 format(f7.2,f7.3,f7.3,f7.3,f7.3,f7.3,f7.3,f7.3,f7.3,f7.3,f7.3)  
      close(7)
 
      print *,"period,rigidwall ",period_velbc,rigidwall_velbc
      do j=1,ipos_velbc
       print *,"j,zpos ",j,zpos_velbc(j)
      enddo
      do j=0,itime_velbc
       print *,"j,timehist ",j,timehist_velbc(j)
      enddo
      do i=0,itime_velbc
      do j=1,ipos_velbc
       print *,"i,j,velbc ",i,j,velbc_velbc(i,j)
      enddo
      enddo
      
      error = 0
      
      return
      
! 901   write(6,911) vel_file
! 911   format(" Can't open file = ",a," stopping ...")

      error = -1
      
      return
      end subroutine


      subroutine localparam(Dbdry,grainbdry)
      IMPLICIT NONE
      REAL_T Dbdry,grainbdry

      Dbdry=zero
      grainbdry=zero

      return
      end subroutine


      subroutine rtdist(x,y,dist)
      IMPLICIT NONE
      REAL_T x,y,dist,rholevel

      dist=radblob*cos(xblob*Pi*x)-y
      rholevel=dist


      return
      end subroutine

        ! currently not used.  April 8, 2016
      subroutine get_ternary(im,im_opp,im_3,iten,iten_13, &
        iten_23,sin1,sin2,sin3,th1,th2,th3,tension,nten,nmat)
      IMPLICIT NONE

      INTEGER_T im,im_opp,im_3,iten,iten_13,iten_23
      INTEGER_T nten,nmat
      REAL_T sin1,sin2,sin3
      REAL_T tension(nten)
      REAL_T t1,t2,t3
      REAL_T th1,th2,th3
      REAL_T t1old,t2old,err
      INTEGER_T iter,maxiter
      INTEGER_T i12,i13,i23

      if ((nmat.lt.3).or. &
          (im.le.0).or.(im.gt.nmat).or. &
          (im_opp.le.0).or.(im_opp.gt.nmat).or. &
          (im_3.le.0).or.(im_3.gt.nmat).or. &
          (iten.le.0).or.(iten.gt.nten).or. & 
          (iten_13.le.0).or.(iten_13.gt.nten).or. & 
          (iten_23.le.0).or.(iten_23.gt.nten).or. &
          (tension(iten).lt.zero).or. &
          (tension(iten_13).lt.zero).or. &
          (tension(iten_23).lt.zero)) then
       print *,"parameter bust in get_ternary"
       stop
      endif

      maxiter=200
      iter=1

      if ((tension(iten).ge.tension(iten_13)).and. &
          (tension(iten).ge.tension(iten_23))) then
       i12=iten
       i13=iten_13
       i23=iten_23
      else if (tension(iten_13).ge.tension(iten_23)) then
       i12=iten_13
       i13=iten
       i23=iten_23
      else
       i12=iten_23
       i13=iten
       i23=iten_13
      endif

      t1=two*Pi/three 
      t2=two*Pi/three
      t3=two*Pi-t1-t2
      sin1=sin(t1)
      sin2=sin(t2)
      sin3=sin(t3)

      if (tension(i12).gt.zero) then

       err=1.0D+20
       do while ((err.gt.VOFTOL).and.(iter.lt.maxiter))
        t3=two*Pi-t1-t2
        t1old=t1
        t2old=t2
        t1=asin(tension(i23)*sin(t3)/tension(i12))
        t2=asin(tension(i13)*sin(t3)/tension(i12))
        if (t1.lt.zero) then
         t1=t1+two*Pi
        endif
        if (t1.gt.two*Pi) then
         t1=t1-two*Pi
        endif
        if (t2.lt.zero) then
         t2=t2+two*Pi
        endif
        if (t2.gt.two*Pi) then
         t2=t2-two*Pi
        endif
        err=abs(t1-t1old)+abs(t2-t2old)
        iter=iter+1
       enddo
       if (iter.ge.maxiter) then
        print *,"iter exceeds maxiter in get_ternary"
        stop
       endif

       t3=two*Pi-t1-t2

       if (i12.eq.iten) then
        th3=t3  ! t3 opposite i12
        th2=t2  ! t2 opposite i13
        th1=t1  ! t1 opposite i23
       else if (i12.eq.iten_13) then
        th2=t3  ! th2 opposite iten_13, t3 opposite i12
        th3=t2  ! th3 opposite iten, t2 opposite i13
        th1=t1  ! th1 opposite iten_23, t1 opposite i23
       else if (i12.eq.iten_23) then
        th1=t3  ! th1 opposite iten_23, t3 opposite i12
        th3=t2  ! th3 opposite iten, t2 opposite i13
        th2=t1  ! th2 opposite iten_13, t1 opposite i23
       else
        print *,"i12 invalid" 
        stop
       endif
       sin1=sin(th1)   
       sin2=sin(th2)   
       sin3=sin(th3)
 
      else if (tension(i12).eq.zero) then
       th1=t1
       th2=t2
       th3=t3
       sin1=sin(th1)   
       sin2=sin(th2)   
       sin3=sin(th3)
      else
       print *,"tension invalid"
       stop
      endif

      if (1.eq.1) then
       print *,"iter,im,im_opp,im_3,th1,th2,th3 ", &
        iter,im,im_opp,im_3,th1,th2,th3
      endif

      return
      end subroutine get_ternary



        ! input: LSleft,LSright,nmat
        ! output: gradh,im,im_opp
        ! gradh=H(LSright)-H(LSleft) 
        !
        ! contact line treatment is done if "im" and "im_opp"
        ! are majority fluids in adjoining cells.  Then "im_3"
        ! is a majority fluid in a 3rd cell of the 3x3x3 stencil.
        ! If there are more than one "im_3", pick the one with the
        ! largest value.
        !
      subroutine fluid_interface(LSleft,LSright, &
        gradh,im_opp,im,nmat)
      use global_utility_module
      use MOF_routines_module

      IMPLICIT NONE

      INTEGER_T im_opp,im,nmat
      REAL_T LSleft(nmat)
      REAL_T LSright(nmat)
      REAL_T gradh
      INTEGER_T imL,imR


      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      im=0
      im_opp=0
      gradh=zero

      call get_primary_material(LSleft,nmat,imL)
      call get_primary_material(LSright,nmat,imR)

      if ((is_rigid(nmat,imL).eq.1).or. &
          (is_rigid(nmat,imR).eq.1)) then
       ! do nothing
      else if ((is_rigid(nmat,imL).eq.0).and. &
               (is_rigid(nmat,imR).eq.0)) then

       if (imL.eq.imR) then
        ! do nothing
       else if (imL.ne.imR) then

        if (imL.lt.imR) then 
         gradh=-one
         im=imL
         im_opp=imR
        else if (imL.gt.imR) then 
         gradh=one
         im=imR
         im_opp=imL
        else
         print *,"imL or imR bust"
         stop
        endif
       else
        print *,"imL or imR invalid"
        stop
       endif

      else
       print *,"is_rigid invalid"
       stop
      endif

      return
      end subroutine fluid_interface

        ! hs and hs_scale are defined in global_utility_module
      subroutine HSCALE(psi,im,im_opp,H)
      use global_utility_module
      IMPLICIT NONE

      REAL_T psi,alpha,H
      INTEGER_T im,im_opp

      alpha=zero
      H=hs(psi,alpha)

      return
      end subroutine HSCALE

       ! partid=0..nparts-1
       ! im_solid=0..nmat
       ! is_solid_face==1 if:
       !   0.0<=facecut_solid<=VOFTOL_AREAFRAC  or
       !   max(LSleft(im_solid),LSright(im_solid))>=0.0
       ! is_prescribed_face==1 if:
       !   0.0<=facecut_prescribed<=VOFTOL_AREAFRAC  or
       !   max(LSleft(im_prescribed),LSright(im_prescribed))>=0.0
      subroutine fixed_face( &
       nmat, &
       facecut_solid, &      
       facecut_prescribed, & 
       LSleft,LSright, &
       is_solid_face, &
       is_prescribed_face, &
       im_solid, &
       im_prescribed, &
       im_solid_valid, &
       im_prescribed_valid, &
       partid_solid, &
       partid_prescribed)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T, intent(in) :: nmat
      REAL_T, intent(out) :: facecut_solid !surface tension coefficient is zero
      REAL_T, intent(out) :: facecut_prescribed ! grad p coefficient is zero
      REAL_T, intent(in) :: LSleft(nmat)
      REAL_T, intent(in) :: LSright(nmat)
      REAL_T LScrit_solid,LScrit_prescribed,LStest
      INTEGER_T, intent(out) :: is_solid_face,is_prescribed_face
      INTEGER_T im
      INTEGER_T, intent(out) :: im_solid,im_prescribed
      INTEGER_T, intent(out) :: im_solid_valid,im_prescribed_valid
      INTEGER_T, intent(out) :: partid_solid,partid_prescribed
      INTEGER_T nparts

      is_solid_face=0
      is_prescribed_face=0
      im_solid=0
      im_prescribed=0
      im_solid_valid=0
      im_prescribed_valid=0
      nparts=0
      partid_solid=-1
      partid_prescribed=-1
      do im=1,nmat

       if (is_lag_part(nmat,im).eq.1) then

        if (is_rigid(nmat,im).eq.0) then
         if (is_prescribed(nmat,im).eq.0) then
          ! do nothing
         else
          print *,"is_prescribed(nmat,im) invalid"
          stop
         endif
        else if (is_rigid(nmat,im).eq.1) then
         if (im_solid.eq.0) then
          im_solid=im
          partid_solid=nparts
          LScrit_solid=max(LSleft(im),LSright(im))
         else if ((im_solid.ge.1).and. &
                  (im_solid.le.nmat)) then
          LStest=max(LSleft(im),LSright(im))
          if (LStest.gt.LScrit_solid) then
           LScrit_solid=LStest
           im_solid=im
           partid_solid=nparts
          endif
         else
          print *,"im_solid invalid 7"
          stop
         endif
         if (is_prescribed(nmat,im).eq.1) then
          if (im_prescribed.eq.0) then
           im_prescribed=im
           partid_prescribed=nparts
           LScrit_prescribed=max(LSleft(im),LSright(im))
          else if ((im_prescribed.ge.1).and. &
                   (im_prescribed.le.nmat)) then
           LStest=max(LSleft(im),LSright(im))
           if (LStest.gt.LScrit_prescribed) then
            LScrit_prescribed=LStest
            im_prescribed=im
            partid_prescribed=nparts
           endif
          else
           print *,"im_prescribed invalid 7"
           stop
          endif
         else if (is_prescribed(nmat,im).eq.0) then
          ! do nothing
         else
          print *,"is_prescribed(nmat,im) invalid"
          stop
         endif
        else
         print *,"is_rigid invalid"
         stop
        endif

        nparts=nparts+1

       else if (is_lag_part(nmat,im).eq.0) then

        if (is_rigid(nmat,im).eq.0) then
         if (is_prescribed(nmat,im).eq.0) then
          ! do nothing
         else
          print *,"is_prescribed(nmat,im) invalid"
          stop
         endif
        else 
         print *,"is_rigid(nmat,im) invalid"
         stop
        endif
       
       else
        print *,"is_lag_part invalid"
        stop
       endif

      enddo ! im=1..nmat

      if ((nparts.lt.0).or.(nparts.gt.nmat)) then
       print *,"nparts invalid fixed_face"
       stop
      endif

      if ((facecut_solid.le.VOFTOL_AREAFRAC).and. &
          (facecut_solid.ge.zero)) then
       is_solid_face=1
       if (im_solid.eq.0) then
        ! do nothing
       else if ((im_solid.ge.1).and.(im_solid.le.nmat)) then
        im_solid_valid=1 
        if ((partid_solid.lt.0).or. &
            (partid_solid.ge.nparts)) then
         print *,"partid_solid invalid"
         stop
        endif 
       else
        print *,"im_solid invalid 20"
        stop
       endif
      else if (facecut_solid.ge.VOFTOL_AREAFRAC) then
       if (im_solid.eq.0) then
        ! do nothing
       else if ((im_solid.ge.1).and.(im_solid.le.nmat)) then
        im_solid_valid=1
        if (LScrit_solid.ge.zero) then
         is_solid_face=1
        endif
        if ((partid_solid.lt.0).or. &
            (partid_solid.ge.nparts)) then
         print *,"partid_solid invalid"
         stop
        endif 
       else
        print *,"im_solid invalid 9"
        stop
       endif
      else
       print *,"facecut_solid invalid"
       stop
      endif
  
      if ((facecut_prescribed.le.VOFTOL_AREAFRAC).and. &
          (facecut_prescribed.ge.zero)) then
       is_prescribed_face=1
       if (im_prescribed.eq.0) then
        ! do nothing
       else if ((im_prescribed.ge.1).and.(im_prescribed.le.nmat)) then
        im_prescribed_valid=1 
        if ((partid_prescribed.lt.0).or. &
            (partid_prescribed.ge.nparts)) then
         print *,"partid_prescribed invalid"
         stop
        endif 
       else
        print *,"im_prescribed invalid 20"
        stop
       endif
      else if (facecut_prescribed.ge.VOFTOL_AREAFRAC) then
       if (im_prescribed.eq.0) then
        ! do nothing
       else if ((im_prescribed.ge.1).and.(im_prescribed.le.nmat)) then
        im_prescribed_valid=1
        if (LScrit_prescribed.ge.zero) then
         is_prescribed_face=1
        endif
        if ((partid_prescribed.lt.0).or. &
            (partid_prescribed.ge.nparts)) then
         print *,"partid_prescribed invalid"
         stop
        endif 
       else
        print *,"im_prescribed invalid 9"
        stop
       endif
      else
       print *,"facecut_prescribed invalid"
       stop
      endif
 
      return
      end subroutine fixed_face

      subroutine fluid_interface_tension(LSleft,LSright, &
        gradh,im_opp,im,nmat,nten)

      use global_utility_module
      use MOF_routines_module

      IMPLICIT NONE

      INTEGER_T, intent(in) :: nmat,nten
      INTEGER_T nten_test
      INTEGER_T, intent(out) :: im_opp,im
      REAL_T, intent(in) :: LSleft(nmat)
      REAL_T, intent(in) :: LSright(nmat)
      REAL_T, intent(out) :: gradh
      REAL_T psiL,psiR,HLEFT,HRIGHT
      INTEGER_T imL,imR
      INTEGER_T iten

      nten_test=( (nmat-1)*(nmat-1)+nmat-1 )/2
      if (nten_test.ne.nten) then
       print *,"nten: fluid_interface_tension nten nten_test ",nten,nten_test
       stop
      endif

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      im=0
      im_opp=0
      gradh=zero

      call get_primary_material(LSleft,nmat,imL)
      call get_primary_material(LSright,nmat,imR)

      if ((imL.lt.1).or.(imL.gt.nmat).or. &
          (imR.lt.1).or.(imR.gt.nmat)) then
       print *,"imL or imR invalid"
       stop
      endif

      if (is_rigid(nmat,imL).eq.1) then
       ! do nothing
      else if (is_rigid(nmat,imR).eq.1) then
       ! do nothing
      else if (imL.eq.imR) then
       ! do nothing
      else if ((is_rigid(nmat,imL).eq.0).and. &
               (is_rigid(nmat,imR).eq.0).and. &
               (imL.ne.imR)) then

       if (imL.lt.imR) then
        im=imL
        im_opp=imR
       else if (imL.gt.imR) then
        im=imR
        im_opp=imL
       else
        print *,"imL,imR bust"
        stop
       endif

       call get_iten(imL,imR,iten,nmat)
       call get_LS_extend(LSleft,nmat,iten,psiL) ! psiL>0 fluid im
       call get_LS_extend(LSright,nmat,iten,psiR) ! psiR>0 fluid im

       call HSCALE(psiL,im,im_opp,HLEFT)
       call HSCALE(psiR,im,im_opp,HRIGHT)
       gradh=HRIGHT-HLEFT
      else
       print *,"imL or imR bust"
       stop
      endif 

      return
      end subroutine fluid_interface_tension


      subroutine adapt_at_nozzle(adapt_nozzle_flag)
      IMPLICIT NONE

      INTEGER_T adapt_nozzle_flag


      adapt_nozzle_flag=0


      if ((probtype.eq.532).or. &
          (probtype.eq.538).or. &  ! inputs.injA
          (probtype.eq.537).or. &
          (probtype.eq.541)) then
       adapt_nozzle_flag=1

      else if (SDIM.eq.2) then

       ! do nothing

      else if (SDIM.eq.3) then

        ! for impinging jet with like materials, or diesel jet,
        ! always adapt at the nozzle. (unless otherwise prescribed)
       if ((probtype.eq.53).or.(probtype.eq.536).or. &
           (probtype.eq.530)) then
        adapt_nozzle_flag=1
       endif

      else
       print *,"dimension bust"
       stop
      endif
       
      return
      end subroutine adapt_at_nozzle

       ! called from SLOPERECON and INITDATA
       ! (note see NavierStokes::init_pressure_error_indicator() too,
       !  which calls FORT_PRESSURE_INDICATOR, which calls
       !  EOS_error_ind)
       ! stencil_valid==1 => coarse/fine ghost values use 2nd order interp.
       ! stencil_valid==0 => coarse/fine ghost values use piecewise const int.
      subroutine calc_error_indicator( &
        stencil_valid, &
        level,max_level, &
        xsten,nhalf,dx,bfact, &
        voflist, &
        LS_stencil, &
        nmat, &
        nten, &
        latent_heat, &
        radius_cutoff, &
        err,time)

      use MOF_routines_module
      use global_utility_module

      IMPLICIT NONE

      INTEGER_T stencil_valid
      INTEGER_T level
      INTEGER_T max_level
      INTEGER_T nhalf,bfact
      INTEGER_T nmat
      INTEGER_T nten
      INTEGER_T inear
      INTEGER_T im,im_opp,im_primary
      INTEGER_T ireverse
      INTEGER_T nten_test,iten

      INTEGER_T radius_cutoff(nmat)

      REAL_T latent_heat(2*nten)

      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T LS_stencil(D_DECL(-1:1,-1:1,-1:1),nmat)
      REAL_T LSCURV(D_DECL(-1:1,-1:1,-1:1))

      REAL_T time
      REAL_T err
      REAL_T dxmin,dxmax
      REAL_T dist,dist3
      REAL_T dx(SDIM)
      INTEGER_T i1,j1,k1
      INTEGER_T material_count
      INTEGER_T adapt_nozzle_flag
      INTEGER_T material_present_flag(nmat)
      INTEGER_T k1lo,k1hi
      REAL_T vfrac_rigid_sum
      REAL_T voflist(nmat)
      REAL_T LS_temp(nmat)
      REAL_T LL
      REAL_T curv

      if ((level.lt.0).or.(level.gt.max_level)) then
       print *,"level invalid calc_error_indicator"
       stop
      endif
      if ((stencil_valid.ne.0).and.(stencil_valid.ne.1)) then
       print *,"stencil_valid invalid"
       stop
      endif
      nten_test=( (nmat-1)*(nmat-1)+nmat-1 )/2
      if (nten_test.ne.nten) then
       print *,"nten invalid calc_error_ind",nten,nten_test
       stop
      endif

      if (nhalf.lt.2) then
       print *,"nhalf invalid in calc_error_indicator"
       stop
      endif 

      if (SDIM.eq.2) then
       k1lo=0
       k1hi=0
      else if (SDIM.eq.3) then
       k1lo=-1
       k1hi=1
      else
       print *,"dimension bust"
       stop
      endif
 
      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      call get_dxmin(dx,bfact,dxmin)
      if (dxmin.le.zero) then
       print *,"dxmin bust"
       stop
      endif
      call get_dxmax(dx,bfact,dxmax)
      if (dxmax.le.zero) then
       print *,"dxmax bust"
       stop
      endif

      err=zero
      inear=0 

      call adapt_at_nozzle(adapt_nozzle_flag)

      if (adapt_nozzle_flag.eq.1) then

       im=1
       call materialdist(xsten,nhalf,dx,bfact,dist,im)
       if ((FSI_flag(im).eq.0).or. & ! fluid
           (FSI_flag(im).eq.7)) then ! fluid from CAD
        ! do nothing
       else
        print *,"FSI_flag(im) invalid"
        print *,"im=",im
        print *,"FSI_flag(im)=",FSI_flag(im)
        stop
       endif
       if (abs(dist).le.two*dxmin) then
        inear=2
       endif

       if (nmat.eq.2) then
        ! do nothing
       else if (nmat.gt.2) then
        im=3
        if ((FSI_flag(im).eq.1).or. &
            (FSI_flag(im).eq.2).or. &
            (FSI_flag(im).eq.3).or. &
            (FSI_flag(im).eq.6).or. &
            (FSI_flag(im).eq.4).or. &
            (FSI_flag(im).eq.5)) then
         ! do nothing
        else if ((FSI_flag(im).eq.0).or. &
                 (FSI_flag(im).eq.7)) then  ! impinging jet case probably
         call materialdist(xsten,nhalf,dx,bfact,dist3,im)
         if (abs(dist3).le.two*dxmin) then
          inear=2
         endif
        else
         print *,"FSI_flag(im) invalid"
         print *,"im=",im
         print *,"FSI_flag(im)=",FSI_flag(im)
         stop
        endif
       else
        print *,"nmat invalid"
        stop
       endif

      else if (adapt_nozzle_flag.eq.0) then
       ! do nothing
      else
       print *,"adapt_nozzle_flag invalid"
       stop
      endif  

      do im=1,nmat 
       material_present_flag(im)=0
      enddo

      vfrac_rigid_sum=zero
      do im=1,nmat 
       LS_temp(im)=LS_stencil(D_DECL(0,0,0),im)
       if (is_rigid(nmat,im).eq.0) then
        ! do nothing
       else if (is_rigid(nmat,im).eq.1) then
        vfrac_rigid_sum=vfrac_rigid_sum+voflist(im)
       else
        print *,"is_rigid(nmat,im) invalid"
        stop
       endif
      enddo ! im=1..nmat

      call get_primary_material(LS_temp,nmat,im_primary)

      material_present_flag(im_primary)=1

      if (radius_cutoff(im_primary).eq.-1) then
       inear=2
      endif

      if ((is_rigid(nmat,im_primary).eq.0).or. &   ! fluid primary
          ((is_rigid(nmat,im_primary).eq.1).and. & ! solid primary, but fluids
           (vfrac_rigid_sum.le.one-VOFTOL))) then  ! in the cell.

       do im=1,nmat 
        if (voflist(im).gt.VOFTOL) then
         material_present_flag(im)=1
        endif
        if ((voflist(im).lt.-VOFTOL).or. &
            (voflist(im).gt.one+VOFTOL)) then
         print *,"voflist is corrupt"
         stop
        endif
       enddo ! im=1..nmat

       do i1=-1,1
       do j1=-1,1
       do k1=k1lo,k1hi
        do im=1,nmat 
         LS_temp(im)=LS_stencil(D_DECL(i1,j1,k1),im)
        enddo
        call get_primary_material(LS_temp,nmat,im_primary)
        material_present_flag(im_primary)=1
        if (is_rigid(nmat,im_primary).eq.0) then
         if (probtype.eq.46) then ! cavitation
          if ((axis_dir.ge.0).and.(axis_dir.lt.10)) then
           im=2 ! jwl
           if (LS_temp(im).gt.-dxmin) then
            material_present_flag(im)=1
           endif
          else if (axis_dir.eq.10) then
           ! do nothing (sphere impact)
          else if (axis_dir.eq.20) then
           ! do nothing (CODY ESTEBE created test problem)
          else
           print *,"axis_dir invalid"
           stop
          endif
         endif 
        else if (is_rigid(nmat,im_primary).eq.1) then
         ! do nothing
        else
         print *,"is_rigid invalid"
         stop
        endif
       enddo
       enddo
       enddo ! i1,j1,k1

      else if ((is_rigid(nmat,im_primary).eq.1).and. &
               (vfrac_rigid_sum.gt.one-VOFTOL)) then
       ! do nothing
      else
       print *,"is_rigid or vfrac_rigid_sum invalid"
       stop
      endif

      material_count=0

      do im=1,nmat 

       if (material_present_flag(im).eq.1) then

        material_count=material_count+1

       else if (material_present_flag(im).eq.0) then
        ! do nothing
       else 
        print *,"material_present_flag invalid"
        stop
       endif
        
      enddo ! im=1..nmat

      if (material_count.gt.nmat) then
       print *,"material_count is corrupt"
       stop
      endif

      if (material_count.ge.2) then
       inear=max(inear,1)
      endif
      if (material_count.ge.3) then
       inear=max(inear,2)
      endif

       ! BEFORE:
       ! always adapt to finest level an interface changing phase.
       ! temperature gradient not accurate across coarse/fine boundary.
       ! (pc_interp used for temperature interpolation)
       ! NOW: 
       ! always adapt to finest level a fluid-fluid interface too.
      do im=1,nmat-1
       do im_opp=im+1,nmat
        if ((material_present_flag(im).eq.1).and. &
            (material_present_flag(im_opp).eq.1)) then

         if ((is_rigid(nmat,im).eq.0).and. &
             (is_rigid(nmat,im_opp).eq.0)) then
          inear=max(inear,2)
         else if ((is_rigid(nmat,im).eq.1).or. &
                  (is_rigid(nmat,im_opp).eq.1)) then
          ! do nothing
         else
          print *,"is_rigid invalid"
          stop
         endif

         if ((im.gt.nmat).or.(im_opp.gt.nmat)) then
          print *,"im or im_opp bust 87"
          stop
         endif

         do ireverse=0,1
          call get_iten(im,im_opp,iten,nmat)
          LL=latent_heat(iten+ireverse*nten)
          if (LL.ne.zero) then
           inear=max(inear,2)
          else if (LL.eq.zero) then
           ! do nothing
          else
           print *,"LL invalid"
           stop
          endif
         enddo ! ireverse=0..1

        else if ((material_present_flag(im).eq.0).or. &
                 (material_present_flag(im_opp).eq.0)) then
         ! do nothing
        else
         print *,"material_present_flag invalid"
         stop
        endif
       enddo ! im_opp=im+1..nmat
      enddo ! im=1..nmat-1

      if (inear.eq.1) then ! 2 materials

       ! 0=>never adapt  -1=>always adapt
       ! otherwise, if radius<radius_cutoff * dx then adapt.
       do im=1,nmat
        if (material_present_flag(im).eq.1) then
         if (radius_cutoff(im).eq.-1) then
          inear=2
         endif
        endif
       enddo

      else if ((inear.eq.0).or.(inear.eq.2)) then
       ! do nothing
      else
       print *,"inear invalid"
       stop
      endif
 
      if ((inear.eq.1).and. &  ! 2 materials
          (stencil_valid.eq.1).and. & !high order coarse/fine interp=>ok curv.
          (material_count.ge.2)) then

       do im=1,nmat 
        if (material_present_flag(im).eq.1) then

         if (radius_cutoff(im).eq.0) then
          ! do nothing, never adapt if level<max_level_two_materials, and
          ! not a fluid.
         else if (radius_cutoff(im).ge.1) then
          do i1=-1,1
          do j1=-1,1
          do k1=k1lo,k1hi
           LSCURV(D_DECL(i1,j1,k1))=LS_stencil(D_DECL(i1,j1,k1),im)
          enddo 
          enddo 
          enddo 
          call curverr(curv,LSCURV,xsten,nhalf)
          if (abs(curv).gt.zero) then
           if (one/abs(curv).lt.radius_cutoff(im)*dxmin) then
            inear=2
            if ((1.eq.0).and.(level.eq.max_level-1)) then
             print *,"(PASS)im,x,y,curv ",im,xsten(0,1),xsten(0,2),curv
             print *,"1/abs(curv),dxmin ",one/abs(curv),dxmin
            endif
           endif
          else if (curv.eq.zero) then
           ! do nothing
          else
           print *,"curv is corrupt"
           stop
          endif

         else
          print *,"radius_cutoff invalid"
          stop
         endif

        else if (material_present_flag(im).eq.0) then
         ! do nothing
        else
         print *,"material_present_flag invalid"
         stop
        endif
       enddo ! im=1..nmat

      else if ((inear.eq.0).or. &
               (inear.eq.2).or. &
               (stencil_valid.eq.0).or. &
               (material_count.eq.1)) then
       ! do nothing
      else
       print *,"parameter bust"
       stop
      endif 

       ! if err>0.0 and level<max_level_two_materials => adapt
       ! if err>=1.0 => adapt
      if (inear.eq.1) then
       err=VOFTOL
      else if (inear.eq.2) then
       err=VOFTOL+one
      else if (inear.eq.0) then
       ! do nothing
      else
       print *,"inear invalid"
       stop
      endif 
 
      return
      end subroutine calc_error_indicator


        ! called from get_symmetric_error
       subroutine exactdist(xsten,nhalf,bfact,dx,dist,imaterial,time)
       use global_utility_module

       IMPLICIT NONE

       INTEGER_T nhalf,bfact,isten
       REAL_T xsten(-nhalf:nhalf,SDIM)
       REAL_T xsten_star(-1:1,SDIM)
       INTEGER_T nhalf_star,dir
       REAL_T dx(SDIM)
       REAL_T x,y,z,dist,time
       REAL_T xstar,ystar,zstar
       INTEGER_T imaterial,nmat,nten
       REAL_T distsolid,distgas,dist_liquid,dist_ice
       INTEGER_T im_solid_exactdist

       im_solid_exactdist=im_solid_primary()

       nhalf_star=1

       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif
       if (nhalf.lt.1) then
        print *,"nhalf invalid exact dist"
        stop
       endif
 
       x=xsten(0,1)
       y=xsten(0,2)
       z=xsten(0,SDIM)

       nmat=num_materials
       nten=( (nmat-1)*(nmat-1)+nmat-1 )/2

       if (SDIM.eq.2) then
        if (abs(z-y).gt.1.0E-8) then
         print *,"expecting z=y"
         stop
        endif
       endif
       xstar=x
       ystar=y
       zstar=z
       if ((probtype.eq.28).and.(adv_vel.ne.zero)) then
        if (SDIM.eq.2) then
         if ((adv_dir.eq.1).or.(adv_dir.eq.SDIM+1)) then
          xstar=xstar-adv_vel*time
          do while (xstar.lt.problox)
           xstar=xstar+probhix-problox
          enddo
          do while (xstar.gt.probhix)
           xstar=xstar-probhix+problox
          enddo
         else if ((adv_dir.eq.2).or.(adv_dir.eq.SDIM+1)) then
          ystar=ystar-adv_vel*time
          do while (ystar.lt.probloy)
           ystar=ystar+probhiy-probloy
          enddo
          do while (ystar.gt.probhiy)
           ystar=ystar-probhiy+probloy
          enddo
         else
          print *,"adv_dir invalid probtype==28 (4)"
          stop
         endif
         zstar=ystar
        else if (SDIM.eq.3) then
         if ((adv_dir.eq.1).or.(adv_dir.eq.SDIM+1)) then
          xstar=xstar-adv_vel*time
          do while (xstar.lt.problox)
           xstar=xstar+probhix-problox
          enddo
          do while (xstar.gt.probhix)
           xstar=xstar-probhix+problox
          enddo
         else if ((adv_dir.eq.2).or.(adv_dir.eq.SDIM+1)) then
          ystar=ystar-adv_vel*time
          do while (ystar.lt.probloy)
           ystar=ystar+probhiy-probloy
          enddo
          do while (ystar.gt.probhiy)
           ystar=ystar-probhiy+probloy
          enddo
         else if ((adv_dir.eq.3).or.(adv_dir.eq.SDIM+1)) then
          zstar=zstar-adv_vel*time
          do while (zstar.lt.probloz)
           zstar=zstar+probhiz-probloz
          enddo
          do while (zstar.gt.probhiz)
           zstar=zstar-probhiz+probloz
          enddo
         else
          print *,"adv_dir invalid probtype==28 (5)"
          stop
         endif
        else
         print *,"dimension bust"
         stop
        endif
       endif 
       do isten=-1,1
        dir=1
        xsten_star(isten,dir)=xsten(isten,dir)+xstar-xsten(0,dir)
        dir=2 
        xsten_star(isten,dir)=xsten(isten,dir)+ystar-xsten(0,dir)
        if (SDIM.eq.3) then
         dir=SDIM
         xsten_star(isten,dir)=xsten(isten,dir)+zstar-xsten(0,dir)
        endif
       enddo ! isten
       call materialdist(xsten_star,nhalf_star,dx,bfact,dist,imaterial)

        ! drop on slope (exactdist)
       if ((probtype.eq.55).and.(SDIM.eq.2)) then
        if ((num_materials.eq.3).and. &
            (im_solid_exactdist.eq.3).and. &
            (axis_dir.eq.0).and. &
            (radblob3.eq.zero).and. &
            (radblob5.eq.zero).and. &
            (radblob6.eq.zero).and. &
            (radblob7.eq.zero).and. &
            (abs(xblob-xblob2).lt.1.0E-7).and. &
            (abs(yblob-yblob2).lt.1.0E-7)) then

         if ((imaterial.eq.1).or.(imaterial.eq.2)) then
           ! distsolid>0 in solid
          call materialdist(xsten_star,nhalf_star,dx,bfact,distsolid,3)
           ! in: exactdist (maxtall=2 * radblob => dist_ice=dist_liquid)
          call drop_slope_dist(xstar,ystar,zstar, &
           time,nmat,two*radblob,dist_ice,dist_liquid)
          distgas=-dist_liquid

          if (imaterial.eq.1) then
           dist=dist_liquid
          else if (imaterial.eq.2) then
           dist=distgas
          else
           print *,"imaterial invalid in exactdist"
           print *,"imaterial= ",imaterial
           stop
          endif
         endif  ! imaterial=1,2

         ! drop falling on ice (exactdist)
        else if ((num_materials.eq.3).and.(axis_dir.eq.1)) then
         ! do nothing (should not come here)
        else if ((num_materials.eq.4).and.(axis_dir.eq.1)) then
         ! do nothing (should not come here)
        endif  ! drop on slope problem

        ! drop on slope
       else if ((probtype.eq.55).and.(SDIM.eq.3)) then
        if ((num_materials.eq.3).and. &
            (im_solid_exactdist.eq.3).and. &
            (axis_dir.eq.0).and. &
            (radblob5.eq.zero).and. &
            (radblob6.eq.zero).and. &
            (radblob7.eq.zero).and. &
            (abs(xblob-xblob2).lt.1.0E-7).and. &
            (abs(yblob-yblob2).lt.1.0E-7).and. &
            (abs(zblob-zblob2).lt.1.0E-7)) then

         if ((imaterial.eq.1).or.(imaterial.eq.2)) then
           ! distsolid>0 in solid
          call materialdist(xsten_star,nhalf_star,dx,bfact,distsolid,3)
           ! in: exactdist (maxtall=2 * radblob => dist_ice=dist_liquid)
          call drop_slope_dist(xstar,ystar,zstar, &
           time,nmat,two*radblob,dist_ice,dist_liquid)
          distgas=-dist_liquid

          if (imaterial.eq.1) then
           dist=dist_liquid
          else if (imaterial.eq.2) then
           dist=distgas
          else
           print *,"imaterial invalid"
           stop
          endif
         endif  ! imaterial=1,2

        endif  ! drop on slope problem

       endif ! probtype=55

       return
       end subroutine exactdist
        
        ! xsten0,nhalf0 corresponds to top level cell
        ! xsten,nhalf center of cell in question
        ! error: f1,e1,f2,e2,f3,e3,f4,e4, ....
        ! called from: stackerror
      subroutine get_symmetric_error( &
        xtrilist, &
        xsten0,nhalf0, & ! top level cell
        dx,bfact, &
        xsten,nhalf, &   ! refined cell
        mofdata, &
        mofdata_tess, &
        errorparm,cutflag,nmat,time)

      use MOF_routines_module
      use geometry_intersect_module

      IMPLICIT NONE


      INTEGER_T, intent(in) :: nmat,nhalf0,nhalf,bfact
      REAL_T, intent(in) :: time
      REAL_T, intent(in) :: mofdata(nmat*ngeom_recon)
      REAL_T, intent(in) :: mofdata_tess(nmat*ngeom_recon)
      REAL_T, intent(in) :: xsten0(-nhalf0:nhalf0,SDIM)  ! top level
      REAL_T, intent(in) :: xsten(-nhalf:nhalf,SDIM)     ! refined
      REAL_T :: xsten_test(-1:1,SDIM)
      INTEGER_T nhalf_test,isten
      REAL_T, intent(in) :: dx(SDIM)
      REAL_T dxlevel(SDIM)
      REAL_T, intent(out) :: errorparm(2*nmat)
      INTEGER_T, intent(out) :: cutflag
      INTEGER_T imaterial
      INTEGER_T minusflag(2)
      INTEGER_T plusflag(2)
      INTEGER_T i1,j1,k1,k1lo,k1hi,ii,dir
      REAL_T volbox
      REAL_T cenbox(SDIM)
      REAL_T cenallagain(SDIM)
      REAL_T ltest(D_DECL(3,3,3))
      REAL_T lnode(4*(SDIM-1))
      REAL_T volallagain
      REAL_T volcut(nmat)
      REAL_T cencut(SDIM)
      REAL_T facearea
      REAL_T areacentroid(SDIM)
      ! get_symmetric_error
      REAL_T, intent(inout) :: xtrilist(SDIM+1,SDIM,POLYGON_LIST_MAX) 
      INTEGER_T nmax
      INTEGER_T tessellate
      INTEGER_T vofcomp
      REAL_T multi_volume(nmat)
      REAL_T multi_cen(SDIM,nmat)
      INTEGER_T combine_materials,imat1a,imat1b,imaterial_temp
      REAL_T vfrac,dxmaxREFINE
      INTEGER_T inode
     
      nhalf_test=1
 
      if (nhalf.lt.3) then
       print *,"nhalf invalid get symmetric error"
       stop
      endif
      if (nhalf0.lt.1) then
       print *,"nhalf0 invalid"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif

      combine_materials=0
      imat1a=0
      imat1b=0

      nmax=POLYGON_LIST_MAX ! get_symmetric_error

      if (levelrz.eq.0) then
       ! do nothing
      else if (levelrz.eq.1) then
       if (SDIM.ne.2) then
        print *,"dimension bust"
        stop
       endif
      else if (levelrz.eq.3) then
       ! do nothing
      else
       print *,"levelrz invalid get_symmetric error"
       stop
      endif

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      call Box_volumeFAST(bfact,dx,xsten,nhalf,volbox,cenbox,SDIM)

      cutflag=0
      do ii=1,2*nmat
       errorparm(ii)=zero
      enddo

      if (SDIM.eq.2) then
       k1lo=0
       k1hi=0
      else if (SDIM.eq.3) then
       k1lo=-1
       k1hi=1
      else
       print *,"dimension bust"
       stop
      endif

      dxmaxREFINE=zero
      do dir=1,SDIM
       dxlevel(dir)=xsten(1,dir)-xsten(-1,dir)
       if (dxlevel(dir).le.zero) then
        print *,"dxlevel invalid"
        stop
       endif
       if (dxlevel(dir).gt.dxmaxREFINE) then
        dxmaxREFINE=dxlevel(dir)
       endif
      enddo ! dir
      if (dxmaxREFINE.le.zero) then
       print *,"dxmaxREFINE invalid"
       stop
      endif

      do imaterial=1,nmat

       do ii=1,2
        minusflag(ii)=0
        plusflag(ii)=0
       enddo

       do i1=-1,1
       do j1=-1,1
       do k1=k1lo,k1hi
        do isten=-1,1
         dir=1
         xsten_test(isten,dir)=xsten(2*i1+isten,dir)
         dir=2
         xsten_test(isten,dir)=xsten(2*j1+isten,dir)
         if (SDIM.eq.3) then
          dir=SDIM
          xsten_test(isten,dir)=xsten(2*k1+isten,dir)
         endif
        enddo ! isten

        imaterial_temp=imaterial
        if (combine_materials.eq.1) then
         if (imaterial.eq.imat1b) then
          imaterial_temp=imat1a
         endif
        else if (combine_materials.ne.0) then
         print *,"bust"
         stop
        endif

        call exactdist(xsten_test,nhalf_test,bfact, &
         dx,ltest(D_DECL(i1+2,j1+2,k1+2)), &
         imaterial_temp,time)

        if (ltest(D_DECL(i1+2,j1+2,k1+2)).le.zero) then
         minusflag(1)=1
        endif
        if (ltest(D_DECL(i1+2,j1+2,k1+2)).ge.zero) then
         plusflag(1)=1
        endif
        if (abs(ltest(D_DECL(i1+2,j1+2,k1+2))).le.dxmaxREFINE) then
         minusflag(1)=1
         plusflag(1)=1
        endif
     
        vofcomp=(imaterial-1)*ngeom_recon+1
        vfrac=mofdata_tess(vofcomp)
        if (combine_materials.eq.1) then
         if (imaterial.eq.imat1a) then 
          vofcomp=(imat1b-1)*ngeom_recon+1
          vfrac=vfrac+mofdata_tess(vofcomp)
         else if (imaterial.eq.imat1b) then
          vofcomp=(imat1a-1)*ngeom_recon+1
          vfrac=vfrac+mofdata_tess(vofcomp)
         endif
        else if (combine_materials.eq.0) then
         ! do nothing
        else 
         print *,"combine_materials invalid"
         stop
        endif

        if (vfrac.lt.VOFTOL) then
         minusflag(2)=1
        else if (vfrac.gt.one-VOFTOL) then
         plusflag(2)=1
        else
         minusflag(2)=1
         plusflag(2)=1
        endif
         
       enddo
       enddo
       enddo

       if ((minusflag(1).eq.1).and. &
           (minusflag(2).eq.1).and. &
           (plusflag(1).eq.0).and. &
           (plusflag(2).eq.0)) then
        errorparm(2*imaterial-1)=zero
        errorparm(2*imaterial)=zero
       else if ((minusflag(1).eq.0).and. &
                (minusflag(2).eq.0).and. &
                (plusflag(1).eq.1).and. &
                (plusflag(2).eq.1)) then
        errorparm(2*imaterial-1)=volbox
        errorparm(2*imaterial)=zero
       else if ((minusflag(1).eq.1).and. &
                (minusflag(2).eq.0).and. &
                (plusflag(1).eq.0).and. &
                (plusflag(2).eq.1)) then
        errorparm(2*imaterial-1)=volbox
        errorparm(2*imaterial)=volbox
       else if ((minusflag(1).eq.0).and. &
                (minusflag(2).eq.1).and. &
                (plusflag(1).eq.1).and. &
                (plusflag(2).eq.0)) then
        errorparm(2*imaterial-1)=zero
        errorparm(2*imaterial)=volbox
       else 
        cutflag=1
       endif

      enddo ! imaterial
      
      if (cutflag.eq.1) then

        ! first initialize the volumes for the expected solution
       do imaterial=1,nmat

        inode=1
        do k1=k1lo,k1hi,2
        do j1=-1,1,2
        do i1=-1,1,2

         do isten=-1,1
          dir=1
          xsten_test(isten,dir)=xsten(i1+isten,dir)
          dir=2
          xsten_test(isten,dir)=xsten(j1+isten,dir)
          if (SDIM.eq.3) then
           dir=SDIM
           xsten_test(isten,dir)=xsten(k1+isten,dir)
          endif
         enddo ! isten

         call exactdist(xsten_test,nhalf_test,bfact, &
          dx,lnode(inode), &
          imaterial,time)

         inode=inode+1
        enddo
        enddo
        enddo
 
        call fast_cell_intersection_grid( &
         bfact,dx,xsten,nhalf, &
         lnode, &
         volcut(imaterial), &
         cencut,facearea,areacentroid, &
         volallagain,cenallagain,SDIM)

       enddo ! imaterial

       tessellate=1
       if (nmax.lt.10) then
        print *,"nmax bust 1"
        stop
       endif
        ! in: get_symmetric_error
       call multi_get_volume_grid_simple( &
        tessellate, &
        bfact,dx,xsten0,nhalf0, &
        mofdata, &
        xsten,nhalf, &
        multi_volume,multi_cen, &
        xtrilist, &
        nmax, &
        nmax, &
        nmat,SDIM,1)

       if (combine_materials.eq.1) then
        volcut(imat1b)=volcut(imat1a)
        multi_volume(imat1a)=multi_volume(imat1a)+multi_volume(imat1b)
        multi_volume(imat1b)=multi_volume(imat1a)
       endif 

       do imaterial=1,nmat
        errorparm(2*imaterial-1)=multi_volume(imaterial)
        errorparm(2*imaterial)=abs(volcut(imaterial)-multi_volume(imaterial))
       enddo

      endif ! cutflag=1
 
      return
      end subroutine get_symmetric_error

        ! xsten0,nhalf0 corresponds to top level cell
        ! xsten,nhalf center of cell in question
        ! error: f1,e1,f2,e2,f3,e3,f4,e4
        ! called from: SUMMASS (NAVIERSTOKES_3D.F90)
      recursive subroutine stackerror( &
       xtrilist, &
       xsten0,nhalf0, &
       dxin,bfact, &
       xsten,nhalf, &
       mofdata, &
       mofdata_tess, &
       errorparm,level, &
       max_level,nmat,time)
      IMPLICIT NONE


      REAL_T, intent(in) :: time
      INTEGER_T, intent(in) :: nmat 
      INTEGER_T, intent(in) :: nhalf0,nhalf,bfact
      REAL_T, intent(in) :: xsten0(-nhalf0:nhalf0,SDIM)
      REAL_T, intent(in) :: xsten(-nhalf:nhalf,SDIM)
      REAL_T, intent(in) :: dxin(SDIM)
      REAL_T, intent(inout) :: errorparm(2*nmat)
      INTEGER_T, intent(inout) :: max_level
      INTEGER_T, intent(in) :: level
      REAL_T, intent(inout) :: mofdata(nmat*ngeom_recon)
      REAL_T, intent(inout) :: mofdata_tess(nmat*ngeom_recon)
       ! in: stackerror
      REAL_T, intent(inout) :: xtrilist(SDIM+1,SDIM,POLYGON_LIST_MAX) 

      INTEGER_T i1,j1,k1,k1lo,k1hi,dir,cutflag,im,isten
      REAL_T, allocatable, dimension(:) :: localerror
      REAL_T, allocatable, dimension(:,:) :: xstensub
      REAL_T, allocatable, dimension(:) :: dxsub
      REAL_T, allocatable, dimension(:) :: xmid

      allocate(localerror(2*nmat)) 
      allocate(dxsub(SDIM))
      allocate(xmid(SDIM))
      allocate(xstensub(-nhalf:nhalf,SDIM))

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      if (nhalf.lt.1) then
       print *,"nhalf invalid stackerror"
       stop
      endif
      if (nhalf0.lt.1) then
       print *,"nhalf0 invalid"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif

      if (SDIM.eq.2) then
       k1lo=0
       k1hi=0
      else if (SDIM.eq.3) then
       k1lo=0
       k1hi=1
      else
       print *,"dimension bust"
       stop
      endif

      if (levelrz.eq.0) then
       ! do nothing
      else if (levelrz.eq.1) then
       if (SDIM.ne.2) then
        print *,"dimension bust"
        stop
       endif
      else if (levelrz.eq.3) then
       ! do nothing
      else
       print *,"levelrz invalid stackerror"
       stop
      endif


      if (level.eq.0) then
       do im=1,2*nmat
        errorparm(im)=zero
       enddo
      endif

      call get_symmetric_error( &
        xtrilist, &
        xsten0,nhalf0, &
        dxin,bfact, &
        xsten,nhalf, &
        mofdata, &
        mofdata_tess, &
        localerror,cutflag,nmat,time)

      if ((level.eq.max_level).or.(cutflag.eq.0)) then
       do im=1,2*nmat
        errorparm(im)=errorparm(im)+localerror(im)
       enddo
      else
       do dir=1,SDIM
        dxsub(dir)=half*(xsten(1,dir)-xsten(-1,dir))
        xmid(dir)=half*(xsten(1,dir)+xsten(-1,dir))
        if (dxsub(dir).le.zero) then
         print *,"dxsub invalid"
         stop
        endif
       enddo
       do i1=0,1
       do j1=0,1
       do k1=k1lo,k1hi
        do isten=-nhalf,nhalf
         dir=1
         xstensub(isten,dir)=xmid(dir)+(i1-half)*dxsub(dir)+ &
          half*isten*dxsub(dir)
         dir=2
         xstensub(isten,dir)=xmid(dir)+(j1-half)*dxsub(dir)+ &
          half*isten*dxsub(dir)
         if (SDIM.eq.3) then
          dir=SDIM
          xstensub(isten,dir)=xmid(dir)+(k1-half)*dxsub(dir)+ &
            half*isten*dxsub(dir)
         endif
        enddo !isten
    
        call stackerror( &
         xtrilist, &
         xsten0,nhalf0,dxin,bfact, &
         xstensub,nhalf, &
         mofdata, &
         mofdata_tess, &
         errorparm,level+1,max_level,nmat,time)
       enddo
       enddo 
       enddo 
      endif

      deallocate(localerror)
      deallocate(dxsub)
      deallocate(xmid)
      deallocate(xstensub)

      return
      end subroutine stackerror

      subroutine rfile_dist( x,y,dist,rfilemax )
      IMPLICIT NONE


!     * j= 0 ... = rfilemax.

      REAL_T x,y,dist

      INTEGER_T  j,distset,rfilemax 
      REAL_T deltaz,hval,rval,zval,z1,z2,r1,r2,rmid
      REAL_T distmin,rcoeff,zcoeff,ccoeff,dist1,zint,rint
      REAL_T dist2,dist3,rmin,rmax

      hval=zstatic(rfilemax)
      deltaz=zstatic(1)-zstatic(0)
      rval=x
      zval=yblob-y

      distset=0
      distmin=zero
      do j=1,rfilemax
       z1=zstatic(j-1)
       z2=zstatic(j)
       r1=rstatic(j-1)
       r2=rstatic(j)
       if (r1.lt.r2) then
        rmin=r1
        rmax=r2
       else
        rmin=r2
        rmax=r1
       endif
       if (abs(r2-r1).gt.abs(z2-z1)) then
        rcoeff=(z2-z1)/(r2-r1)
        zcoeff=-one
       else
        rcoeff=-one
        zcoeff=(r2-r1)/(z2-z1)
       endif
       dist=sqrt(rcoeff**2 + zcoeff**2)
       rcoeff=rcoeff/dist
       zcoeff=zcoeff/dist
       ccoeff=-rcoeff*r1-zcoeff*z1
       dist1=rcoeff*rval+zcoeff*zval+ccoeff
       rint=rval-dist1*rcoeff
       zint=zval-dist1*zcoeff
       if ((zint.lt.z1-1.0D-10).or.(zint.gt.z2+1.0D-10).or. &
           (rint.lt.rmin-1.0D-10).or.(rint.gt.rmax+1.0D-10)) then
        dist2=sqrt( (rval-r1)**2 + (zval-z1)**2 )
        dist3=sqrt( (rval-r2)**2 + (zval-z2)**2 )
        if (dist2.le.dist3) then
         dist1=dist2
        else
         dist1=dist3
        endif
       endif
       if ((abs(dist1).lt.distmin).or.(distset.eq.0)) then
        distmin=abs(dist1)
        distset=1
       endif
      enddo
      
      if (zval.ge.hval) then
       dist=distmin  
      else if (zval.le.zero) then
       dist=rval-rstatic(0)
      else
       j=int( zval/deltaz )
       z1=j*deltaz
       r1=rstatic(j)
       r2=rstatic(j+1) 
       rmid=r1+(zval-z1)*(r2-r1)/deltaz 
       dist=rval-rmid
       if (dist.lt.zero) then
        dist=-distmin
       else
        dist=distmin
       endif
      endif
        
      return
      end subroutine

      subroutine readrfile( rfile, error, rfilemax )
      IMPLICIT NONE


!     *  0..rfilemax

!     * Variables passed in ...

      character rfile*20
      INTEGER_T   error,rfilemax 
      
      INTEGER_T  j         

      print *,"will assume rfilemax=",rfilemax
 
!     open(7, file=rfile, form="formatted", status="old", err=900)

      do j = 0,rfilemax 
         
!       read(7,100) zstatic(j),rstatic(j)
        
      end do
 
!     close(7)
 
      do j=0,rfilemax
       print *,"zstatic,rstatic ",zstatic(j),rstatic(j)
      enddo

      error = 0
      
      return
      
! 100  format(' ', e20.14, e21.14 )
! 900  write(6,910) rfile
! 910  format(" Can't open file = ",a," stopping ...")

      error = -1
      
      return
      end subroutine readrfile


       ! called when temperature is prescribed in the solid. (solid distance
       ! function has the appropriate sign)
       ! this routine is called from:
       ! 1. "initsolidtemp"
       !    "initsolidtemp" is called from "solid_temperature()"
       !    when solidheat_flag=1 or 2.
       ! 2. renormalize routine (when solidheat_flag<>0)
       ! 3. vfrac_split (when solidheat_flag<>0)
      subroutine tempsolid(x,y,z,temp,time,im)
      use global_utility_module
      use probcommon_module
      use USERDEF_module
      use CAV3D_module
      use HELIX_module
      use TSPRAY_module
      use CAV2Dstep_module
      use ZEYU_droplet_impact_module
      use CONE3D_module
      use WAVY_Channel_module

      IMPLICIT NONE
     
      REAL_T, intent(in) :: x,y,z
      REAL_T, intent(out) :: temp
      REAL_T, intent(in) :: time 
      INTEGER_T nmat
      INTEGER_T im
      INTEGER_T im_solid_temp
      REAL_T LS(num_materials)
      REAL_T xvec(SDIM)
      REAL_T STATE(num_materials*num_state_material)
      INTEGER_T ibase
      INTEGER_T bcflag

      bcflag=0

      nmat=num_materials
      im_solid_temp=im_solid_primary()

      if (is_rigid(nmat,im).ne.1) then
       print *,"is_rigid invalid in tempsolid"
       stop
      endif
      xvec(1)=x      
      xvec(2)=y      
      if (SDIM.eq.3) then
       xvec(SDIM)=z
      endif 

      if ((im_solid_temp.ge.1).and. &
          (im_solid_temp.le.nmat)) then

       if (is_in_probtype_list().eq.1) then

        call SUB_LS(xvec,time,LS,num_materials)
        call SUB_STATE(xvec,time,LS,STATE, &
                bcflag,num_materials,num_state_material)
        ibase=(im-1)*num_state_material
        temp=STATE(ibase+2) 

       else if (probtype.eq.411) then ! cavitation user defined
        call CAV3D_LS(xvec,time,LS)
        call CAV3D_STATE(xvec,time,LS,STATE)
        ibase=(im-1)*num_state_material
        temp=STATE(ibase+2) 
       else if (probtype.eq.401) then ! helix user defined
        call HELIX_LS(xvec,time,LS)
        call HELIX_STATE(xvec,time,LS,STATE)
        ibase=(im-1)*num_state_material
        temp=STATE(ibase+2) 
       else if (probtype.eq.402) then  ! thermal spray
        call TSPRAY_LS(xvec,time,LS)
        call TSPRAY_STATE(xvec,time,LS,STATE)
        ibase=(im-1)*num_state_material
        temp=STATE(ibase+2)
       else if (probtype.eq.412) then ! user defined
        call CAV2Dstep_LS(xvec,time,LS)
        call CAV2Dstep_STATE(xvec,time,LS,STATE)
        ibase=(im-1)*num_state_material
        temp=STATE(ibase+2)
       else if (probtype.eq.413) then ! Zeyu's gnbc validation case
        call ZEYU_droplet_impact_LS(xvec,time,LS)
        call ZEYU_droplet_impact_STATE(xvec,time,LS,STATE)
        ibase=(im-1)*num_state_material
        temp=STATE(ibase+2)
       else if (probtype.eq.311) then ! user defined
        call USERDEF_LS(xvec,time,LS)
        call USERDEF_STATE(xvec,time,LS,STATE)
        ibase=(im-1)*num_state_material
        temp=STATE(ibase+2) 
       else if (probtype.eq.222) then ! user defined
        call CONE3D_LS(xvec,time,LS)
        call CONE3D_STATE(xvec,time,LS,STATE)
        ibase=(im-1)*num_state_material
        temp=STATE(ibase+2)
       else if (probtype.eq.915) then ! user defined
        call WAVY_INIT_LS(xvec,time,LS)
        call WAVY_INIT_STATE(xvec,time,LS,STATE)
        ibase=(im-1)*num_state_material
        temp=STATE(ibase+2)
       else
        temp=fort_tempconst(im)
       endif
      else
       print *,"im_solid_temp invalid 4"
       stop
      endif

      return
      end subroutine tempsolid


       ! return Q=-k dT/dx_dir * nstaircase_dir
       ! nstaircase points from fluid to solid
       ! Q>0 if boundary condition is cooling (decreases energy)
       ! dir=0,1,2
      subroutine tempfluxsolid(x,y,z,tempflux,time,dir)
      use global_utility_module

      IMPLICIT NONE

      REAL_T x,y,z,tempflux,time
      INTEGER_T nmat,dir
      INTEGER_T im_solid_tempflux

      if ((dir.lt.0).or.(dir.ge.SDIM)) then
       print *,"dir invalid tempflux solid"
       stop
      endif

      im_solid_tempflux=im_solid_primary()
 
      nmat=num_materials
      if ((im_solid_tempflux.ge.1).and. &
          (im_solid_tempflux.le.nmat)) then
       tempflux=zero
       if ((probtype.eq.32).and.(SDIM.eq.2)) then
        tempflux= &
         -(fort_tempconst(im_solid_tempflux)-fort_tempconst(1))* &
         get_user_heatviscconst(im_solid_tempflux)
       endif
      else
       print *,"im_solid_tempflux invalid 5"
       stop
      endif

      return
      end subroutine tempfluxsolid

      subroutine dumbbelldist(x,y,z,xc,yc,zc,R,wave,eps,dist)
      IMPLICIT NONE


      REAL_T x,y,z,dist
      REAL_T xc,yc,zc,R,wave,eps
      REAL_T z1,r1,cos1

      if(z.le.(zc-wave)) then
        z1 = z-(zc-wave)
        dist = sqrt((x-xc)**2+(y-yc)**2+z1*z1)-R
      else if(z.ge.(zc+wave)) then
        z1 = z-(zc+wave)
        dist = sqrt((x-xc)**2+(y-yc)**2+z1*z1)-R
      else
        cos1 = cos(3.1415926*(z-zc)/wave)
        r1 = R-eps*(1+cos1)
        dist = abs(cos1)*(sqrt((x-xc)**2+(y-yc)**2)-r1)
      endif

      return
      end subroutine dumbbelldist

      subroutine override_tagflag(xsten,nhalf,time,rflag,tagflag)
      use global_distance_module
      IMPLICIT NONE

      INTEGER_T nhalf
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T time,rflag
      INTEGER_T tagflag
      REAL_T radx,radshrink,dist
      REAL_T x,y,z,delta

      if (nhalf.lt.1) then
       print *,"nhalf invalid override tagflag"
       stop
      endif
      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)
      delta=xsten(1,1)-xsten(-1,1)
      if (delta.le.zero) then
       print *,"delta invalid override_tagflag"
       stop
      endif

       ! bubble formation
      if ((probtype.eq.25).and.(axis_dir.gt.0).and.(SDIM.eq.2)) then
       if ( (abs(x-xblob).le.radblob).and.(y.le.zblob) ) then
        tagflag=1
       endif
       if (rflag.gt.zero) then
        tagflag=1
       endif
      endif

      if ((probtype.eq.102).and.(SDIM.eq.2)) then
       radx=radblob3+y*(radblob4-radblob3)/yblob3  
       if ((y.le.yblob3).and.(x.ge.radx-delta).and. &
           (x.le.radx+radblob6+delta)) then
        tagflag=1
       endif
       if ((y.le.yblob+yblob2).and.(x.le.radblob5+delta)) then
        tagflag=1
       endif
       radshrink=radblob7**2-radblob5**2
       radshrink=sqrt(radshrink)
       radx=radblob4+(y-yblob3)*(radshrink-radblob4)/(probhiy-yblob3)
       if ((y.ge.yblob3).and.(x.ge.radx-delta).and. &
           (x.le.radx+radblob6+delta)) then
        tagflag=1
       endif
      endif

       ! in override_tagflag 
      if ((probtype.eq.701).and.(axis_dir.eq.2)) then
        ! dist>0 in the airfoil
       call naca_dist(x,y,z,time,dist)
       if (abs(dist).le.delta) then
        tagflag=1
       endif
       if ((abs(y+0.1).le.0.4).and.(x.le.3.0)) then
        tagflag=1
       endif
      endif 

      return
      end subroutine override_tagflag

       ! called from:
       !  subroutine mask_velocity
       !  subroutine FORT_INITDATASOLID
      subroutine velsolid(x,y,z,vel,time,im,dx)
      use global_utility_module
      use global_distance_module
      use probcommon_module
      use USERDEF_module
      use CAV3D_module
      use HELIX_module
      use TSPRAY_module
      use CAV2Dstep_module
      use ZEYU_droplet_impact_module
      use CONE3D_module
      use WAVY_Channel_module
      IMPLICIT NONE

      INTEGER_T, intent(in) :: im
      INTEGER_T dir
      REAL_T, intent(in) :: x,y,z,time
      REAL_T, intent(in) :: dx(SDIM)
      REAL_T, intent(out) :: vel(SDIM)
      REAL_T areacross
      REAL_T tadv,dist
      REAL_T LS(num_materials)
      REAL_T xvec(SDIM)
      INTEGER_T velsolid_flag

      velsolid_flag=1

      xvec(1)=x      
      xvec(2)=y      
      if (SDIM.eq.3) then
       xvec(SDIM)=z
      endif      

      if ((time.ge.zero).and.(time.le.1.0D+20)) then
       ! do nothing
      else if (time.ge.1.0D+20) then
       print *,"WARNING time.ge.1.0D+20 in velsolid"
      else if (time.lt.zero) then
       print *,"time invalid in velsolid"
       stop
      else
       print *,"time bust in velsolid"
       stop
      endif

      if ((adv_dir.lt.1).or.(adv_dir.gt.2*SDIM+1)) then
       print *,"adv_dir invalid velsolid (6)"
       stop
      endif
      if ((im.lt.1).or.(im.gt.num_materials)) then
       print *,"im invalid76"
       stop
      endif

      do dir=1,SDIM
       vel(dir)=zero
      enddo

      if (FSI_flag(im).eq.1) then  ! prescribed solid (EUL)

       if (is_in_probtype_list().eq.1) then

         ! pass dx
        call SUB_LS(xvec,time,LS,num_materials)
        call SUB_VEL(xvec,time,LS,vel,velsolid_flag,dx, &
                num_materials)

         ! velsolid, no sci_clsvof.F90 
       else if (probtype.eq.411) then
        call CAV3D_LS(xvec,time,LS)
        call CAV3D_VEL(xvec,time,LS,vel,velsolid_flag)

       else if (probtype.eq.401) then
        call HELIX_LS(xvec,time,LS)
        call HELIX_VEL(xvec,time,LS,vel,velsolid_flag)

       else if (probtype.eq.402) then ! thermal spray
        call TSPRAY_LS(xvec,time,LS)
        call TSPRAY_VEL(xvec,time,LS,vel,velsolid_flag)

       else if (probtype.eq.412) then ! step
        call CAV2Dstep_LS(xvec,time,LS)
        call CAV2Dstep_VEL(xvec,time,LS,vel,velsolid_flag)

       else if (probtype.eq.413) then ! ZEYU droplet impact
         ! pass dx
        call ZEYU_droplet_impact_LS(xvec,time,LS)
        call ZEYU_droplet_impact_LS_VEL(xvec,time,LS,vel,velsolid_flag,dx)
       else if (probtype.eq.311) then ! user defined
        call USERDEF_LS(xvec,time,LS)
        call USERDEF_VEL(xvec,time,LS,vel,velsolid_flag)

       else if (probtype.eq.222) then ! cone3d
        call CONE3D_LS(xvec,time,LS)
        call CONE3D_VEL(xvec,time,LS,vel,velsolid_flag)
       else if (probtype.eq.915) then ! wavy channel
        call WAVY_INIT_LS(xvec,time,LS)
        call WAVY_INIT_VEL(xvec,time,LS,vel,velsolid_flag)

        ! cavitation
       else if ((probtype.eq.46).and.(axis_dir.eq.10)) then
          ! dist>0 in the steel sphere
        call stainless_steel_dist_rate(x,y,z,time, &
         dist,vel(SDIM))
          ! CODY ESTEBE created test problem.
       else if ((probtype.eq.46).and.(axis_dir.eq.20)) then
        do dir=1,SDIM
         vel(dir)=zero
        enddo
       else if (probtype.eq.701) then 
        call naca_velocity(x,y,z,time,vel)
       else if (probtype.eq.5700) then ! microfluidics (velsolid)
        if ((axis_dir.eq.4).or.(axis_dir.eq.5)) then
         ! do nothing
        else
         print *,"must have FSI_flag=1"
         stop
        endif
        do dir=1,SDIM
         vel(dir)=zero
        enddo
       else if ((probtype.eq.102).and.(SDIM.eq.2)) then
        ! Roper "choked flow" problem
        ! advbot=flow rate L/s=1000 cm^3/s
        ! radblob3= entry gas nozzle radius
        ! radblob5= liquid nozzle outer wall radius

        areacross=Pi*(radblob3**2-radblob5**2)
        if (areacross.le.zero) then
         print *,"cross section area bust"
         stop
        endif
        print *,"radblob7 because what used to be hy here"
        stop
        if ((y.le.radblob7).and.(x.ge.radblob5).and.(x.le.radblob3)) then
         vel(SDIM)=advbot*1000.0/areacross
        endif
       else if ((probtype.eq.32).and.(SDIM.eq.3)) then

        if (advbot.ne.zero) then
         vel(adv_dir)=advbot
        else if ((xblob4.ne.zero).and.(xblob3.ne.zero)) then
         tadv=time
         vel(adv_dir)= &
           two*Pi*xblob3*sin(two*Pi*tadv/xblob4)/xblob4
        endif

         ! velsolid: pipe velocity=0 at walls
       else if (probtype.eq.41) then

        do dir=1,SDIM
         vel(dir)=zero
        enddo

       else if (probtype.eq.50) then
        print *,"obsolete"
        stop
       else if (probtype.eq.54) then
        vel(1)=zero
        vel(2)=advbot
       else if (probtype.eq.52) then
        print *,"this option obsolete"
        stop
       else if (probtype.eq.56) then
        print *,"obsolete"
        stop
       else if ((probtype.eq.531).and.(SDIM.eq.2)) then ! velsolid
        if (axis_dir.eq.0) then
         vel(SDIM)=advbot
        else if ((axis_dir.eq.1).or.(axis_dir.eq.2).or. &
                 (axis_dir.eq.3)) then
         ! do nothing
        else 
         print *,"axis_dir invalid probtype=531"
         stop
        endif

        ! melting block of ice
       else if (probtype.eq.59) then
        do dir=1,SDIM
         vel(dir)=zero
        enddo
       else if (probtype.eq.710) then
        do dir=1,SDIM
         vel(dir)=zero
        enddo
       else if (probtype.eq.32) then  ! flow past moving cylinder
        if (advbot.ne.zero) then
         vel(adv_dir)=advbot
        else if ((xblob4.ne.zero).and.(xblob3.ne.zero)) then
         tadv=time
         vel(adv_dir)= &
           two*Pi*xblob3*sin(two*Pi*tadv/xblob4)/xblob4
        endif
        ! velsolid (FSI_flag=1)
       else if (probtype.eq.bubbleInPackedColumn) then 
        do dir=1,SDIM
         vel(dir)=zero
        enddo
       endif
      else if ((FSI_flag(im).eq.2).or. & ! prescribed solid - CAD
               (FSI_flag(im).eq.4)) then ! CTML FSI - velsolid

! in future: FSI_MF multifab copied to fortran.
! closest value(s) on same processor are used.

       do dir=1,SDIM
        vel(dir)=zero
       enddo

      else
       print *,"FSI_flag invalid in velsolid"
       stop
      endif

      return
      end subroutine velsolid



      subroutine get_microfluidic_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,nmat)
      use global_utility_module
      use geometry_intersect_module

      IMPLICIT NONE

      INTEGER_T nmat,nten,bfact,nhalf
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T xsten2(-1:1,SDIM)
      INTEGER_T nhalf2
      REAL_T dx(SDIM)
      REAL_T cenbc(nmat,SDIM)
      REAL_T vfrac(nmat)
      INTEGER_T im

      INTEGER_T dir2,i1,j1,k1,k1lo,k1hi,isten
      REAL_T centroid(nmat,SDIM)
      REAL_T areacentroid(nmat,SDIM)
      REAL_T lsgrid(D_DECL(3,3,3),nmat)
      REAL_T, dimension(:), allocatable :: distbatch
      REAL_T facearea(nmat)
      REAL_T EBVOFTOL
      INTEGER_T im_solid_microfluidic

      nhalf2=1

      im_solid_microfluidic=im_solid_primary()

      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (nhalf.lt.3) then
       print *,"nhalf invalid get microfluidic vfrac"
       stop
      endif
      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif
      nten=( (num_materials-1)*(num_materials-1)+ &
          num_materials-1 )/2

      allocate(distbatch(nmat))

      if (SDIM.eq.2) then
       k1lo=0
       k1hi=0
      else if (SDIM.eq.3) then
       k1lo=-1
       k1hi=1
      else
       print *,"dimension bust"
       stop
      endif

      if (probtype.ne.5700) then  ! get_microfluidic_vfrac
       print *,"probtype invalid get_microfluidic_vfrac"
       stop
      endif

      if ( ((xsten(0,SDIM).gt.probhiz+VOFTOL*dx(SDIM)).or. &
            (xsten(0,SDIM).lt.probloz-VOFTOL*dx(SDIM))).and. &
           (SDIM.eq.3)) then

       do im=1,nmat
        do dir2=1,SDIM
         cenbc(im,dir2)=zero
        enddo
        vfrac(im)=zero
       enddo ! im
       if ((im_solid_microfluidic.lt.1).or. &
           (im_solid_microfluidic.gt.nmat)) then
        print *,"im_solid_microfluidic invalid 7"
        stop
       endif
       vfrac(im_solid_microfluidic)=one

      else

       do i1=-1,1
       do j1=-1,1
       do k1=k1lo,k1hi
        do isten=-1,1
         dir2=1
         xsten2(isten,dir2)=xsten(isten+2*i1,dir2)
         dir2=2
         xsten2(isten,dir2)=xsten(isten+2*j1,dir2)
         if (SDIM.eq.3) then
          dir2=SDIM
          xsten2(isten,dir2)=xsten(isten+2*k1,dir2)
         endif
        enddo ! isten

        call materialdist_batch( &
         xsten2,nhalf2,dx,bfact, &
         distbatch,nmat)
        do im=1,nmat
         lsgrid(D_DECL(i1+2,j1+2,k1+2),im)=distbatch(im) 
        enddo
       enddo
       enddo
       enddo

       EBVOFTOL=VOFTOL
       call getvolumebatch(bfact,dx,xsten,nhalf, &
        lsgrid,vfrac,facearea, &
        centroid,areacentroid,nmat,EBVOFTOL,SDIM)

       do im=1,nmat
        do dir2=1,SDIM
         cenbc(im,dir2)=centroid(im,dir2)-xsten(0,dir2)
        enddo
       enddo ! im

      endif ! not above or below the channel.

      deallocate(distbatch)

      return
      end subroutine get_microfluidic_vfrac


      subroutine microfluidic_velbc(xsten,nhalf,dir,side,vel)
      IMPLICIT NONE

      INTEGER_T nhalf
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T dx(SDIM)
      REAL_T x,y,z
      REAL_T vel(SDIM)
      INTEGER_T dir,side,dir2,veldir
      REAL_T LX,LY,LZ,xscale,yscale,zscale
      REAL_T dxscale,dyscale,dzscale
      REAL_T xterm,yterm,zterm
      INTEGER_T iplug

      if (nhalf.lt.1) then
       print *,"nhalf invalid microfluidic velbc"
       stop
      endif 
      x=xsten(0,1) 
      y=xsten(0,2) 
      z=xsten(0,SDIM)
      do dir2=1,SDIM
       dx(dir2)=xsten(1,dir2)-xsten(-1,dir2)
       if (dx(dir2).le.zero) then
        print *,"dx(dir2) invalid"
        stop
       endif
      enddo
 
      if (SDIM.eq.2) then
       if (abs(z-y).gt.VOFTOL) then
        print *,"expecting z=y in 2d 7"
        stop
       endif
      endif 
      if (probtype.eq.5700) then  ! microfluidic_velbc

       iplug=0

       do dir2=1,SDIM
        vel(dir2)=zero
       enddo

       if ((dir.eq.1).and.(side.eq.1)) then ! xlo

        veldir=1

        if (SDIM.eq.2) then

        if (axis_dir.eq.2) then
         print *,"axis_dir=2 obsolete"
         stop
        else if (axis_dir.eq.5) then
         ! do nothing, no inflow from xlo for squeezing geom.
        else if ((axis_dir.eq.0).or.(axis_dir.eq.1).or. &
                 (axis_dir.eq.3)) then
         vel(veldir)=abs(vinletgas)   ! plug flow
        else if (axis_dir.eq.4) then
         if (zblob2.ge.zblob3) then
          print *,"zblob2 or zblob3 invalid"
          stop
         endif
          ! microfluidic probtype=5700
         if ((yblob3.eq.zero).and.(yblob2.eq.zero)) then
          vel(veldir)=abs(vinletgas)   ! plug flow
         else if (yblob2.lt.yblob3) then
          if ((y.le.yblob2).or.(y.ge.yblob3)) then
           ! do nothing
          else
           if (iplug.eq.1) then
            vel(veldir)=abs(vinletgas)   ! plug flow
           else if (iplug.eq.0) then
            LY=yblob3-yblob2
            yscale=two*((y-yblob2)/LY-half)
            dyscale=dx(2)/LY
            yterm=one-yscale**2-dyscale**2/3.0
            if (yterm.lt.zero) then
             yterm=zero
            endif
            vel(veldir)=abs(vinletgas)*(3.0/2.0)*yterm
           else
            print *,"iplug invalid"
            stop
           endif
          endif
         else
          print *,"inflow dimensions invalid"
          stop
         endif
        else
         print *,"axis_dir invalid microfluidic velbc"
         stop
        endif

        else if (SDIM.eq.3) then

        if (axis_dir.eq.2) then
         print *,"axis_dir=2 obsolete"
         stop
        else if (axis_dir.eq.5) then
         ! do nothing, no inflow from xlo for squeezing geom.
        else if ((axis_dir.eq.0).or.(axis_dir.eq.1).or. &
                 (axis_dir.eq.3)) then
         vel(veldir)=abs(vinletgas)   ! plug flow
        else if (axis_dir.eq.4) then
         if (zblob2.ge.zblob3) then
          print *,"zblob2 or zblob3 invalid"
          stop
         endif
         if ((zblob3.eq.zero).and.(zblob2.eq.zero)) then
          vel(veldir)=abs(vinletgas)   ! plug flow
         else if ((yblob2.lt.yblob3).and.(zblob2.lt.zblob3)) then
          if ((y.le.yblob2).or.(y.ge.yblob3).or. &
              (z.le.zblob2).or.(z.ge.zblob3)) then
           ! do nothing
          else
           if (iplug.eq.1) then
            vel(veldir)=abs(vinletgas)   ! plug flow
           else if (iplug.eq.0) then
            LY=yblob3-yblob2
            LZ=zblob3-zblob2
            yscale=two*((y-yblob2)/LY-half)
            zscale=two*((z-zblob2)/LZ-half)
            dyscale=dx(2)/LY
            dzscale=dx(SDIM)/LZ
            yterm=one-yscale**2-dyscale**2/3.0
            if (yterm.lt.zero) then
             yterm=zero
            endif
            zterm=one-zscale**2-dzscale**2/3.0
            if (zterm.lt.zero) then
             zterm=zero
            endif
            vel(veldir)=abs(vinletgas)*((3.0/2.0)**2)*yterm*zterm
           else
            print *,"iplug invalid"
            stop
           endif
          endif
         else
          print *,"inflow dimensions invalid"
          stop
         endif
        else
         print *,"axis_dir invalid microfluidic velbc"
         stop
        endif

        else
         print *,"dimension bust"
         stop
        endif

       else if ((dir.eq.1).and.(side.eq.2)) then  ! xhi
        ! do nothing

       else if ((dir.eq.2).and.(side.eq.1)) then  ! ylo

        if ((axis_dir.eq.0).or.(axis_dir.eq.1).or. &
            (axis_dir.eq.3).or.(axis_dir.eq.4)) then
         ! do nothing
        else if (axis_dir.eq.2) then 
         print *,"this option obsolete"
         stop
        else if (axis_dir.eq.5) then ! squeeze geom, ylo
         veldir=2
         if ((x.ge.xblob2).and.(x.le.xblob3)) then
          vel(veldir)=abs(vinletgas)  ! plug flow
         else
          vel(veldir)=zero
         endif
        else
         print *,"axis_dir invalid ylo velbc"
         stop
        endif

       else if ((dir.eq.2).and.(side.eq.2)) then  ! yhi
        veldir=2

        if (SDIM.eq.2) then

        if (axis_dir.eq.2) then 
         print *,"axis_dir = 2 obsolete"
         stop
        else if (axis_dir.eq.5) then  ! squeezing channel
         if ((x.ge.xblob2).and.(x.le.xblob3)) then
          vel(veldir)=-abs(advbot)  ! plug flow
         else
          vel(veldir)=zero
         endif
        else if ((axis_dir.eq.0).or.(axis_dir.eq.1).or. &
                 (axis_dir.eq.3)) then
         vel(veldir)=-abs(advbot)  !plug flow
        else if (axis_dir.eq.4) then
         if ((yblob3.eq.zero).and.(yblob2.eq.zero)) then
          vel(veldir)=-abs(advbot)  ! plug flow
         else if (xblob2.lt.xblob3) then

          if ((x.le.xblob2).or.(x.ge.xblob3)) then
           ! do nothing
          else
           if (iplug.eq.1) then
            vel(veldir)=-abs(advbot)  ! plug flow
           else if (iplug.eq.0) then
            LX=xblob3-xblob2
            xscale=two*((x-xblob2)/LX-half)
            dxscale=dx(1)/LX
            xterm=one-xscale**2-dxscale**2/3.0
            if (xterm.lt.zero) then
             xterm=zero
            endif
            vel(veldir)=-abs(advbot)*(3.0/2.0)*xterm
           else
            print *,"iplug invalid"
            stop
           endif
          endif
         else
          print *,"inflow dimensions invalid"
          stop
         endif
        else
         print *,"axis_dir invalid microfluidic velbc"
         stop
        endif

        else if (SDIM.eq.3) then

        if (axis_dir.eq.2) then
         print *,"axis_dir = 2 obsolete"
         stop
        else if (axis_dir.eq.5) then  ! squeezing channel
         if ((x.ge.xblob2).and.(x.le.xblob3)) then
          vel(veldir)=-abs(advbot)  ! plug flow
         else
          vel(veldir)=zero
         endif
        else if ((axis_dir.eq.0).or.(axis_dir.eq.1).or. &
                 (axis_dir.eq.3)) then
         vel(veldir)=-abs(advbot)  ! plug flow
        else if (axis_dir.eq.4) then
         if ((zblob3.eq.zero).and.(zblob2.eq.zero)) then
          vel(veldir)=-abs(advbot)  ! plug flow
         else if ((xblob2.lt.xblob3).and.(zblob2.lt.zblob3)) then

          if ((x.le.xblob2).or.(x.ge.xblob3).or. &
              (z.le.zblob2).or.(z.ge.zblob3)) then
           ! do nothing
          else
           if (iplug.eq.1) then
            vel(veldir)=-abs(advbot)  ! plug flow
           else if (iplug.eq.0) then
            LX=xblob3-xblob2
            LZ=zblob3-zblob2
            xscale=two*((x-xblob2)/LX-half)
            zscale=two*((z-zblob2)/LZ-half)
            dxscale=dx(1)/LX
            dzscale=dx(SDIM)/LZ
            xterm=one-xscale**2-dxscale**2/3.0
            if (xterm.lt.zero) then
             xterm=zero
            endif
            zterm=one-zscale**2-dzscale**2/3.0
            if (zterm.lt.zero) then
             zterm=zero
            endif
            vel(veldir)=-abs(advbot)*((3.0/2.0)**2)*xterm*zterm 
           else
            print *,"iplug invalid"
            stop
           endif
          endif
         else
          print *,"inflow dimensions invalid"
          stop
         endif
        else
         print *,"axis_dir invalid microfluidic velbc"
         stop
        endif

        else
         print *,"dimension bust"
         stop
        endif

       else if ((dir.eq.3).and.(side.eq.1).and.(SDIM.eq.3)) then
        ! do nothing
       else if ((dir.eq.3).and.(side.eq.2).and.(SDIM.eq.3)) then
        ! do nothing
       else
        print *,"dir or side invalid"
        stop
       endif

      else
       print *,"probtype invalid in microfluidic velbc"
       stop
      endif

      return
      end subroutine microfluidic_velbc


        ! ice behaves like rigid solid where dist>0
        ! called from "get_icemask" (PROB.F90) and 
        ! "integrate_recalesce" (DERIVE_3D.F90)
      subroutine icemask_override(xtarget,im_source,im_dest,dist)
      use global_utility_module
      use global_distance_module

      IMPLICIT NONE
     
      REAL_T xtarget(SDIM) 
      REAL_T dist
      INTEGER_T nmat,im_source,im_dest

      nmat=num_materials

      if ((im_source.lt.1).or.(im_source.gt.nmat)) then
       print *,"im_source invalid"
       stop
      endif
      if ((im_dest.lt.1).or.(im_dest.gt.nmat)) then
       print *,"im_dest invalid"
       stop
      endif
      if (is_ice(nmat,im_dest).ne.1) then
       print *,"is_ice invalid"
       stop
      endif
      dist=-9999.0

      if (recalesce_material(im_source).eq.0) then
       ! do nothing
      else if ((recalesce_material(im_source).eq.1).or. &
               (recalesce_material(im_source).eq.2)) then
       
       if (probtype.eq.55) then
         ! dist > 0 in the substrate
        call ice_substrate_distance( &
         xtarget(1),xtarget(2),xtarget(SDIM),dist)
       endif  
   
      else 
       print *,"recalesce_material invalid"
       stop
      endif

      end subroutine icemask_override

      subroutine cavitation_bubble_dist(xsten,nhalf,dist,dx,bfact)
      use global_utility_module
      use global_distance_module
      IMPLICIT NONE

      INTEGER_T bfact,nhalf
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T x,y,z,dist
      REAL_T dx(SDIM)
      REAL_T xmin,xmax,ymin,ymax,temprad

      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (nhalf.lt.1) then
       print *,"nhalf invalid cavitation bubble dist"
       stop
      endif
      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)

      if (SDIM.eq.2) then
       if (abs(z-y).ge.1.0E-8) then
        print *,"expecting z=y"
        stop
       endif
      endif
      if (probtype.ne.46) then
       print *,"probtype invalid"
       stop
      endif

      if (1.eq.0) then

       dist=radblob-sqrt( (x-xblob)**2 + (y-yblob)**2 )

      else

       if (radblob2.gt.zero) then
        xmin=xblob-radblob3-radblob2+half*radblob6
        xmax=xblob+radblob3+radblob2-half*radblob6
        ymin=yblob-radblob4-radblob5+half*radblob6
        ymax=yblob+radblob4+radblob5-half*radblob6
          ! negative in the square
        call squaredist(x,y,xmin,xmax,ymin,ymax,dist)
        dist=-dist
       else
        temprad=radblob
        xmin=-temprad
        xmax=temprad
        ymin=yblob-temprad
        ymax=yblob+temprad
          ! negative in the square
        call squaredist(x,y,xmin,xmax,ymin,ymax,dist)
        dist=-dist
       endif

      endif

      end subroutine cavitation_bubble_dist

        ! imaterial = 1..nmat
        ! liquid,gas,alt,solid
      subroutine materialdist_batch(xsten,nhalf,dx,bfact,dist,nmat)
      use global_utility_module
      use global_distance_module
      use hydrateReactor_module
      use unimaterialChannel_module
      use River
      use USERDEF_module
      use CAV3D_module
      use HELIX_module
      use TSPRAY_module
      use CAV2Dstep_module
      use ZEYU_droplet_impact_module
      use CONE3D_module
      use WAVY_Channel_module
      use rigid_FSI_module
      use sinking_particle_module

      IMPLICIT NONE

      INTEGER_T, intent(in) :: bfact
      INTEGER_T, intent(in) :: nhalf
      REAL_T, intent(in) :: dx(SDIM) 
      REAL_T, intent(in) :: xsten(-nhalf:nhalf,SDIM)
      INTEGER_T, intent(in) :: nmat
      REAL_T, intent(out) :: dist(nmat)
      REAL_T x,y,z
      INTEGER_T imaterial
      REAL_T distline
      REAL_T distcircle
      REAL_T distleft,distright
      REAL_T raddist,distfilament,distfilm
      REAL_T distsolid
      REAL_T drat,veltop,velbot,ytop,ybot
      INTEGER_T im_solid_materialdist
      REAL_T initial_time
      INTEGER_T dir
      REAL_T x_in(SDIM)
      REAL_T maxdx

      initial_time=zero

      im_solid_materialdist=im_solid_primary()

      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (nhalf.lt.1) then
       print *,"nhalf invalid materialdistbatch"
       stop
      endif
      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      if ((initial_time.ge.zero).and.(initial_time.le.1.0D+20)) then
       ! do nothing
      else if (initial_time.ge.1.0D+20) then
       print *,"WARNING initial_time.ge.1.0D+20 in materialdistbatch"
      else if (initial_time.lt.zero) then
       print *,"initial_time invalid in materialdistbatch"
       stop
      else
       print *,"initial_time bust in materialdistbatch"
       stop
      endif

      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)
      do dir=1,SDIM
       x_in(dir)=xsten(0,dir)
      enddo

      if (SDIM.eq.2) then
       if (abs(y-z).gt.VOFTOL) then
        print *,"y=z in 2d expected"
        stop
       endif
      endif

      do imaterial=1,nmat
       dist(imaterial)=-9999.0
      enddo

      distsolid=-9999.0
      do imaterial=1,nmat
       if (is_rigid(nmat,imaterial).eq.1) then
         ! pos in solid, calling from materialdist_batch
        call materialdistsolid(x,y,z,dist(imaterial),initial_time,imaterial)  
        if (dist(imaterial).gt.distsolid) then
         distsolid=dist(imaterial)
        endif
       else if (is_rigid(nmat,imaterial).eq.0) then
        ! do nothing
       else
        print *,"is_rigid invalid"
        stop
       endif
      enddo ! imaterial=1..nmat

      if (distsolid.ge.zero) then
       if ((im_solid_materialdist.lt.1).or. &
           (im_solid_materialdist.gt.nmat)) then
        print *,"im_solid_materialdist invalid: ",im_solid_materialdist
        print *,"probtype= ",probtype
        print *,"axis_dir=",axis_dir
        print *,"num_materials=",num_materials
        stop
       endif
      endif
      if (im_solid_materialdist.eq.1) then
       print *,"im_solid_materialdist=1 invalid: ",im_solid_materialdist
       stop
      endif

      if (is_in_probtype_list().eq.1) then
       call SUB_LS(x_in,initial_time,dist,num_materials)
      else if (probtype.eq.411) then
       call CAV3D_LS(x_in,initial_time,dist)
      else if (probtype.eq.401) then
       call HELIX_LS(x_in,initial_time,dist)
      else if (probtype.eq.402) then
       call TSPRAY_LS(x_in,initial_time,dist)
      else if (probtype.eq.412) then ! step
       call CAV2Dstep_LS(x_in,initial_time,dist)
      else if (probtype.eq.413) then ! zeyu
       call ZEYU_droplet_impact_LS(x_in,initial_time,dist)
      else if (probtype.eq.533) then
       call rigid_FSI_LS(x_in,initial_time,dist)
      else if (probtype.eq.534) then
       call sinking_FSI_LS(x_in,initial_time,dist)
      else if (probtype.eq.311) then ! user defined problem
       call USERDEF_LS(x_in,initial_time,dist)
      else if (probtype.eq.222) then ! cone3d
       call CONE3D_LS(x_in,initial_time,dist)
      else if (probtype.eq.915) then ! wavy channel
       call WAVY_INIT_LS(x_in,initial_time,dist)

       ! HYDRATE (materialdist_batch)
      else if (probtype.eq.199) then
       if (nmat.ne.3) then
        print *,"nmat invalid for hydrate problem"
        stop
       endif
       call INIT_LS_WATER(x,y,z,initial_time,dist(1))
       call INIT_LS_GAS(x,y,z,initial_time,dist(2))
       call INIT_LS_HYDRATE(x,y,z,initial_time,dist(3))
       do imaterial=1,3
        if (is_rigid(nmat,imaterial).ne.0) then
         print *,"all hydrate problem materials should be fluids"
         stop
        endif
       enddo

      else if (probtype.eq.220) then
       if (nmat.ne.3) then
        print *,"nmat invalid for unimaterial problem"
        stop
       endif
       maxdx=max(dx(1),dx(2))
       call UNIMAT_INIT_LS_MAT(maxdx,dist(1))
       call UNIMAT_INIT_LS_GST(maxdx,dist(2))

       ! melting (materialdist_batch) (initial level set functions)
      else if (probtype.eq.299) then
       call INIT_LS_LIQUID_MELT(x,y,z,initial_time,dist(1))
       call INIT_LS_GAS_MELT(x,y,z,initial_time,dist(2))
       call INIT_LS_SOLID_MELT(x,y,z,initial_time,dist(3))
       do imaterial=1,3
        if (is_rigid(nmat,imaterial).ne.0) then
         print *,"all additive manufacturing materials should be fluids"
         stop
        endif
       enddo

       ! melting block of ice (materialdist_batch)
       ! fluids must tessellate the whole domain.
      else if (probtype.eq.59) then

       if (SDIM.eq.2) then
        if (abs(yblob2-(yblob-half*radblob)).gt.VOFTOL) then
         print *,"bottom of original ice block must coincide w/substrate"
         stop
        endif

        !dist<0 inside the square
        !water below the ice
        call squaredist(x,y,xblob-half*radblob,xblob+half*radblob, &
         -yblob2-radblob3,yblob2+radblob3,dist(1))
        dist(1)=-dist(1)
        !ice
        call squaredist(x,y,xblob-half*radblob,xblob+half*radblob, &
         yblob2+radblob3,yblob2+radblob,dist(3))
        dist(3)=-dist(3)

        !air; dist<0 inside the square
        call squaredist(x,y,xblob-half*radblob,xblob+half*radblob, &
         -yblob2-radblob,yblob2+radblob,dist(2))

       else if (SDIM.eq.3) then
        print *,"3D case not implemented yet"
        stop
       endif

      else if (probtype.eq.301) then
       call INIT_LS_LIQUID_AM(x,y,z,initial_time,dist(1))
       call INIT_LS_GAS_AM(x,y,z,initial_time,dist(2))
       call INIT_LS_SOLID_AM(x,y,z,initial_time,dist(3))
       do imaterial=1,3
        if (is_rigid(nmat,imaterial).ne.0) then
         print *,"all additive manufacturing materials should be fluids"
         stop
        endif
       enddo

       ! in: materialdist_batch
       ! cavitation
      else if ((probtype.eq.46).and.(SDIM.eq.2)) then

         ! water, jwl, air, vacuum
       if ((axis_dir.ge.0).and.(axis_dir.lt.10)) then
        if (nmat.lt.3) then
         print *,"nmat invalid"
         stop
        endif
        call vapordist(xsten,nhalf,dx,bfact,dist(1))  ! water
        call cavitation_bubble_dist(xsten,nhalf,dist(2),dx,bfact) ! jwl
        dist(3)=y-(zblob+yblob) ! air
        if (nmat.eq.4) then
         dist(nmat)=-99999.0 ! vacuum
        endif
       else if (axis_dir.eq.10) then ! cavitation due to falling steel ball
        if (nmat.ne.3) then
         print *,"nmat invalid: nmat=",nmat
         stop
        endif
         ! dist(nmat)>0 in the steel sphere
        call vapordist(xsten,nhalf,dx,bfact,dist(nmat)) 
        dist(1)=99999.0 ! water
        dist(2)=-99999.0 ! ambient
        if (im_solid_materialdist.ne.nmat) then
         print *,"im_solid_materialdist invalid: ",im_solid_materialdist
         stop
        endif
        ! CODY ESTEBE created test problem
       else if (axis_dir.eq.20) then
        dist(1)=99999.0
        dist(2)=-99999.0 ! ambient
       else
        print *,"axis_dir invalid"
        stop
       endif

       ! River
      else if (probtype.eq.209) then
       if (nmat.ne.2) then
        print *,"nmat invalid for River problem"
        stop
       endif
       call RiverHeight(x,y,dist(1),axis_dir)
       dist(1)=dist(1)-z
       dist(2)=-dist(1)

      else

       call vapordist(xsten,nhalf,dx,bfact,dist(1)) 
       if (im_solid_materialdist.ne.2) then
        dist(2)=-dist(1)
       endif

         ! pos in solid, calling from materialdist_batch
       if (probtype.eq.531) then
        if (((axis_dir.eq.3).and.(SDIM.eq.2)).or.  & ! barbell swimmer
            ((axis_dir.eq.2).and.(SDIM.eq.2)).or.  & ! ice crystal in drop
            ((axis_dir.eq.1).and.(SDIM.eq.2))) then ! falling solid on pool
         if (nmat.ne.3) then
          print *,"expecting nmat=3 if probtype=531"
          stop
         endif
         print *,"FSI algorithm not implemented yet"
         stop
        endif
       endif ! probtype.eq.531 ?

       if ((probtype.eq.29).and.(SDIM.eq.3)) then
        if (denfact.eq.zero) then
         ! do nothing - single vortex 2 materials
         if (nmat.ne.2) then
          print *,"nmat invalid"
          stop
         endif
        else if (denfact.eq.-one) then ! split deforming sphere in half
         if (nmat.ne.3) then
          print *,"nmat invalid"
          stop
         endif
         dist(3)=dist(1)
         dist(1)=-dist(3)
         distline=xblob-x
         if (distline.lt.dist(1)) then
          dist(1)=distline
         endif
         dist(2)=-dist(3)
         distline=x-xblob
         if (distline.lt.dist(2)) then
          dist(2)=distline
         endif

        else
         print *,"denfact invalid"
         stop
        endif

       endif ! 3d vortex

       if ((probtype.eq.29).and. &
           ((axis_dir.eq.3).or.(axis_dir.eq.4)).and. &
           (SDIM.eq.2)) then

        if (denfact.eq.one) then
         ! do nothing - single vortex 2 materials
         if (nmat.ne.2) then
          print *,"nmat invalid"
          stop
         endif
        else if (denfact.eq.-one) then ! split deforming circle in half
         if (nmat.ne.3) then
          print *,"nmat invalid"
          stop
         endif
         dist(3)=dist(1)  ! negative in the circle
         dist(1)=-dist(3)
         distline=half-x
         if (distline.lt.dist(1)) then
          dist(1)=distline
         endif
         dist(2)=-dist(3)
         distline=x-half
         if (distline.lt.dist(2)) then
          dist(2)=distline
         endif
        else
         print *,"denfact invalid"
         stop
        endif

       endif  ! single vortex with reversal

        ! freezing disk: ice, water, air
       if ((probtype.eq.801).and. &
           (num_materials.eq.3).and.(radblob2.gt.zero)) then
        if (axis_dir.eq.3) then
         dist(3)=sqrt( (x-xblob)**2 + (y-yblob)**2 )-radblob2
        else if (axis_dir.eq.0) then
         dist(3)=sqrt( (x-xblob)**2 )-radblob2
        else
         print *,"axis_dir invalid probtype=801"
         stop
        endif
        if (dist(1).gt.zero) then
         if (dist(3).ge.zero) then
          dist(1)=-dist(3)
         else
          dist(1)=min(dist(1),-dist(3))
         endif
        endif
       endif

        ! material 1 = top half  material 2=inside circle
        ! material 3 = bottom half
        ! liquid lens (materialdistbatch)
       if ((probtype.eq.202).and.(SDIM.eq.2)) then 
        if (num_materials.ne.3) then
         print *,"num_materials should be 3"
         stop
        endif
        distline=zblob2-y  ! negative at top half
        distcircle=dist(1)  ! positive outside circle
        distright=sqrt( (x-xblob-radblob)**2 + (y-yblob)**2 )
        distleft=sqrt( (x-xblob+radblob)**2 + (y-yblob)**2 )

        dist(2)=-distcircle  ! positive in the circle

        if (distline.le.zero) then  ! top half
         if (distcircle.gt.zero) then
          if (distcircle.gt.abs(distline)) then
           dist(1)=abs(distline)
          else
           dist(1)=distcircle
          endif
         else
          dist(1)=distcircle
         endif
         if (distcircle.le.zero) then
          if (distleft.le.distright) then
           dist(3)=-distleft
          else
           dist(3)=-distright
          endif
         else
          dist(3)=distline
         endif
        else if (distline.ge.zero) then ! bottom half
         if (distcircle.gt.zero) then
          if (distcircle.gt.abs(distline)) then
           dist(3)=abs(distline)
          else
           dist(3)=distcircle
          endif
         else
          dist(3)=distcircle
         endif
         if (distcircle.le.zero) then
          if (distleft.le.distright) then
           dist(1)=-distleft
          else
           dist(1)=-distright
          endif
         else
          dist(1)=-distline
         endif
        endif
       endif ! probtype.eq.202

        ! material 2 is the bubble or drop
        ! material 1 is the lower stratified fluid
        ! material 3 is the upper stratified fluid
       if (probtype.eq.201) then ! bubble-stratified (materialdistbatch)
        if (num_materials.ne.3) then
         print *,"num_materials should be 3"
         stop
        endif
        if (SDIM.eq.2) then
         if (yblob2.eq.zblob2) then
          ! do nothing
         else 
          print *,"expecting yblob2==zblob2 in 2D"
          stop
         endif
        else if (SDIM.eq.3) then
         ! check nothing
        else
         print *,"dimension bust"
         stop
        endif
        distline=zblob2-z
        dist(3)=dist(1)
        if (distline.lt.dist(1)) then
         dist(1)=distline
        endif
        if (-distline.lt.dist(3)) then
         dist(3)=-distline
        endif
       endif

        ! boiling from a cavity (materialdistbatch)
       if (probtype.eq.710) then

        if (nmat.ne.3) then
         print *,"nmat invalid probtype=710"
         stop
        endif
        dist(nmat)=distsolid
        call vapordist(xsten,nhalf,dx,bfact,dist(1))  ! positive in liquid
        dist(2)=-dist(1)

       endif  ! probtype=710

        ! Rieber problem (materialdistbatch)
       if ((probtype.eq.540).and.(SDIM.eq.3)) then  

        if ((radblob3.ne.zero).and.(radblob4.ne.zero)) then
         print *,"conflict of parameters 540"
         stop
        else if (radblob4.ne.zero) then
         if (nmat.lt.3) then
          print *,"nmat invalid"
          stop
         endif
         raddist=sqrt( (x-xblob)**2 + (y-yblob)**2 + (z-zblob)**2 )
         if (raddist.le.radblob+half*radblob4) then
          distfilament=raddist-radblob
         else if (raddist.ge.radblob+half*radblob4) then
          distfilament=radblob+radblob4-raddist
         else
          print *,"bust"
          stop
         endif
         dist(3)=distfilament

         distfilm=radblob2-z  ! radblob2-z in 3D  radblob2-y in 2D
         if (raddist.le.radblob+radblob4) then
          dist(2)=raddist-radblob-radblob4
         else if (distfilm.ge.zero) then
          dist(2)=-distfilm
         else
          dist(2)=raddist-radblob-radblob4
          if (dist(2).gt.-distfilm) then
           dist(2)=-distfilm
          endif
         endif
        else if (radblob3.ne.zero) then
         if (nmat.lt.3) then
          print *,"nmat invalid"
          stop
         endif
         if (radblob2.ne.zero) then
          print *,"cannot have both radblob2 and radblob3 <>0"
          stop
         endif
         ! if radblob3<>0 then: dist(1)>0 in drop, dist(2)<0 in drop
         ! summary for radblob3<>0:
         !   1. material 1: drop
         !   2. material 2: outside drop and above z=radblob3
         !   3. material 3: outside drop and below z=radblob3
         dist(3)=radblob3-z
         if (dist(2).gt.-dist(3)) then
           dist(2)=-dist(3)
         endif
        endif
       endif  ! 3D rieber problem  probtype.eq.540


        ! 2D Rieber problem (materialdistbatch)
       if ((probtype.eq.540).and.(SDIM.eq.2)) then  

        if ((radblob3.ne.zero).and.(radblob4.ne.zero)) then
         print *,"conflict of parameters 540"
         stop
        else if (radblob4.ne.zero) then
         if (nmat.lt.3) then
          print *,"nmat invalid"
          stop
         endif
         raddist=sqrt( (x-xblob)**2 + (y-yblob)**2 )
         if (raddist.le.radblob+half*radblob4) then
          distfilament=raddist-radblob
         else if (raddist.ge.radblob+half*radblob4) then
          distfilament=radblob+radblob4-raddist
         else
          print *,"bust"
          stop
         endif
         dist(3)=distfilament

         distfilm=radblob2-y  ! radblob2-z in 3D  radblob2-y in 2D
         if (raddist.le.radblob+radblob4) then
          dist(2)=raddist-radblob-radblob4
         else if (distfilm.ge.zero) then
          dist(2)=-distfilm
         else
          dist(2)=raddist-radblob-radblob4
          if (dist(2).gt.-distfilm) then
           dist(2)=-distfilm
          endif
         endif
        else if (radblob3.ne.zero) then
         if (nmat.lt.3) then
          print *,"nmat invalid"
          stop
         endif
         if (radblob2.ne.zero) then
          print *,"cannot have both radblob2 and radblob3 <>0"
          stop
         endif
          ! if radblob3<>0 then dist(2) is the signed distance
          ! to the falling drop.
         dist(3)=radblob3-y
         if (dist(2).gt.-dist(3)) then
           dist(2)=-dist(3)
         endif
        endif
       endif  ! 2D rieber problem probtype.eq.540

       if ((probtype.eq.530).and.(SDIM.eq.3)) then ! impinging jets
        if (axis_dir.eq.1) then  ! impinging unlike jets
         call get_jet_dist(x,y,z,nmat,dist)
        else if (axis_dir.eq.0) then
         ! do nothing
        else
         print *,"axis_dir invalid"
         stop
        endif
       endif !probtype=530


! ysl 05/12/14
        ! water (material 3) on top
        ! diesel (material 1) on bottom
       if ((probtype.eq.17).and.(SDIM.eq.3)) then
        if (nmat.ne.3) then
         print *,"num_materials must be 3"
         stop
        endif
        if (im_solid_materialdist.ne.0) then
         print *,"no solid in this problem"
         stop
        endif
! dist(i)
! if >0: is material i, the nearest distance to another material
! if <0: the shortest distance to material i
! dist(2): air
! oil: 1
! air: 2
! water: 3
! materialdistbatch
        drat=fort_denconst(3)/fort_denconst(1)  ! dentop/denbot
        veltop=-one/(drat+one)
        velbot=drat/(drat+one)
        ytop=yblob+1.25*radblob
        ybot=yblob-radblob+(ytop-yblob-radblob)*velbot/veltop

        if (y.ge.zero) then
         dist(3)=-dist(2)  ! distance to water
         dist(1)=radblob-sqrt((x-xblob)**2+(y-ybot)**2+(z-zblob)**2)
        else
         dist(1)=-dist(2)
         dist(3)=radblob-sqrt((x-xblob)**2+(y-ytop)**2+(z-zblob)**2)
        endif
       endif  ! probtype=17

        ! water (material 3) on top
        ! diesel (material 1) on bottom
       if ((probtype.eq.17).and.(SDIM.eq.2)) then
        if (nmat.ne.3) then
         print *,"num_materials must be 3"
         stop
        endif
        if (im_solid_materialdist.ne.0) then
         print *,"no solid in this problem"
         stop
        endif
        drat=fort_denconst(3)/fort_denconst(1)  ! dentop/denbot
        veltop=-one/(drat+one)
        velbot=drat/(drat+one)
        ytop=yblob+1.25*radblob
        ybot=yblob-radblob+(ytop-yblob-radblob)*velbot/veltop

        if (y.ge.zero) then
         dist(3)=-dist(2)  
         dist(1)=radblob-sqrt((x-xblob)**2+(y-ybot)**2)
        else
         dist(1)=-dist(2)
         dist(3)=radblob-sqrt((x-xblob)**2+(y-ytop)**2)
        endif
       endif

      endif ! not custom distance functions

      return
      end subroutine materialdist_batch

        ! imaterial = 1,2,3,4
        ! liquid,gas,alt,solid
      subroutine materialdist(xsten,nhalf,dx,bfact,dist,imaterial)
      IMPLICIT NONE

      INTEGER_T bfact,nhalf
      REAL_T dx(SDIM)
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T dist
      INTEGER_T imaterial,nmat
      REAL_T, dimension(:), allocatable :: distbatch

      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      nmat=num_materials
      allocate(distbatch(nmat))
      if ((imaterial.lt.1).or.(imaterial.gt.nmat)) then
       print *,"imaterial invalid in materialdist"
       print *,"imaterial = ",imaterial
       stop
      endif

      call materialdist_batch(xsten,nhalf,dx,bfact,distbatch,nmat)
      dist=distbatch(imaterial)

      deallocate(distbatch)

      return
      end subroutine materialdist



      subroutine pulseheight(x,t,ht)
      IMPLICIT NONE
      REAL_T x,t,ht
      REAL_T xprime,cc,xx


      cc=12.0  ! (118.9453125+0.1953125)/10
      xx=x-cc*t
      xprime=sqrt(three*radblob/(four*zblob*zblob*zblob))
      ht=zblob+radblob/(cosh(xx*xprime)**2)

      return
      end subroutine

      subroutine min_jetdist(x,y,dist)
      IMPLICIT NONE

      REAL_T x,y,dist


      if (levelrz.ne.1) then
       print *,"levelrz invalid min jetdist"
       stop
      endif

      if ((xblob3.lt.radblob).or.(xblob3.ge.xblob2)) then
       print *,"xblob3 out of range"
       stop
      endif 
      if (y.le.yblob3) then
       dist=xblob3-abs(x)
      else
       dist=xblob3-sqrt(x*x+(y-yblob3)*(y-yblob3))
      endif

      return
      end subroutine min_jetdist


      subroutine get_jet_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,nmat)
      use geometry_intersect_module
      IMPLICIT NONE

      INTEGER_T nmat,bfact,nhalf
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T xsten2(-1:1,SDIM)

      REAL_T dx(SDIM)
      REAL_T cenbc(nmat,SDIM)
      REAL_T vfrac(nmat)
      INTEGER_T im

      INTEGER_T dir2,i1,j1,k1,k1lo,k1hi,isten
      REAL_T centroid(nmat,SDIM)
      REAL_T areacentroid(nmat,SDIM)
      REAL_T lsgrid(D_DECL(3,3,3),nmat)
      REAL_T facearea(nmat)
      REAL_T distbatch(nmat)
      REAL_T EBVOFTOL
      INTEGER_T nhalf2

      nhalf2=1
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (nhalf.lt.3) then
       print *,"nhalf invalid get jet vfrac"
       stop
      endif

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      if (SDIM.eq.2) then
       k1lo=0
       k1hi=0
      else if (SDIM.eq.3) then
       k1lo=-1
       k1hi=1
      else
       print *,"dimension bust"
       stop
      endif

      do i1=-1,1
      do j1=-1,1
      do k1=k1lo,k1hi
       do isten=-1,1
        dir2=1
        xsten2(isten,dir2)=xsten(isten+2*i1,dir2)
        dir2=2
        xsten2(isten,dir2)=xsten(isten+2*j1,dir2)
        if (SDIM.eq.3) then
         dir2=SDIM
         xsten2(isten,dir2)=xsten(isten+2*k1,dir2)
        endif
       enddo ! isten

       call get_jet_dist(xsten2(0,1),xsten2(0,2), &
         xsten2(0,SDIM),nmat,distbatch)
       do im=1,nmat
        lsgrid(D_DECL(i1+2,j1+2,k1+2),im)=distbatch(im) 
       enddo
      enddo
      enddo
      enddo
      EBVOFTOL=VOFTOL
      call getvolumebatch(bfact,dx,xsten,nhalf, &
        lsgrid,vfrac, &
        facearea,centroid,areacentroid,nmat,EBVOFTOL,SDIM)
      do im=1,nmat
       do dir2=1,SDIM
        cenbc(im,dir2)=centroid(im,dir2)-xsten(0,dir2)
       enddo
      enddo

      return
      end subroutine get_jet_vfrac


      subroutine get_initial_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,nmat)
      use geometry_intersect_module
      IMPLICIT NONE

      INTEGER_T nmat,bfact,nhalf
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T xsten2(-1:1,SDIM)
      REAL_T dx(SDIM)
      REAL_T cenbc(nmat,SDIM)
      REAL_T vfrac(nmat)
      INTEGER_T im

      INTEGER_T dir2,i1,j1,k1,k1lo,k1hi,isten
      REAL_T centroid(nmat,SDIM)
      REAL_T areacentroid(nmat,SDIM)
      REAL_T lsgrid(D_DECL(3,3,3),nmat)
      REAL_T facearea(nmat)
      REAL_T, dimension(:), allocatable :: distbatch
      REAL_T EBVOFTOL
      INTEGER_T nhalf2
      REAL_T LS_center

      nhalf2=1
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (nhalf.lt.3) then
       print *,"nhalf invalid get initial vfrac"
       stop
      endif
      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif
      allocate(distbatch(nmat))

      if (SDIM.eq.2) then
       k1lo=0
       k1hi=0
      else if (SDIM.eq.3) then
       k1lo=-1
       k1hi=1
      else
       print *,"dimension bust"
       stop
      endif

      do i1=-1,1
      do j1=-1,1
      do k1=k1lo,k1hi
       do isten=-1,1
        dir2=1
        xsten2(isten,dir2)=xsten(isten+2*i1,dir2)
        dir2=2
        xsten2(isten,dir2)=xsten(isten+2*j1,dir2)
        if (SDIM.eq.3) then
         dir2=SDIM
         xsten2(isten,dir2)=xsten(isten+2*k1,dir2)
        endif
       enddo ! isten

       call materialdist_batch( &
        xsten2,nhalf2,dx,bfact, &
        distbatch,nmat)
       do im=1,nmat
        lsgrid(D_DECL(i1+2,j1+2,k1+2),im)=distbatch(im) 
       enddo
      enddo
      enddo
      enddo ! i1,j1,k1

      EBVOFTOL=VOFTOL
        ! in: MOF.F90
      call getvolumebatch(bfact,dx,xsten,nhalf, &
        lsgrid,vfrac,facearea, &
        centroid,areacentroid,nmat,EBVOFTOL,SDIM)
      do im=1,nmat

       if (vfrac(im).lt.zero) then
        print *,"vfrac invalid in get_initial_vfrac 1"
        stop
       else if (vfrac(im).le.VOFTOL) then
         ! if the interface is linear and LS_center>=0, then
         !  F>=1/2.  If LS_center>=0, and F<1/2 => nonlinear
         !  interface.
        LS_center=lsgrid(D_DECL(2,2,2),im)
        if (LS_center.ge.-VOFTOL*dx(1)) then
         vfrac(im)=VOFTOL_SLOPES
        endif
       else if ((vfrac(im).gt.zero).and. &
                (vfrac(im).le.one+VOFTOL)) then
        ! do nothing
       else
        print *,"vfrac invalid in get_initial_vfrac 2"
        stop
       endif

       do dir2=1,SDIM
        cenbc(im,dir2)=centroid(im,dir2)-xsten(0,dir2)
       enddo
      enddo
      deallocate(distbatch)

      return
      end subroutine get_initial_vfrac


! called if probtype.eq.53, probtype.eq.532, probtype.eq.538,
! probtype.eq.541 (2D)
! called if probtype.eq.53, probtype.eq.536, probtype.eq.537,
! probtype.eq.530,probtype.eq.532,probtype.eq.538,
! probtype.eq.541 (3D)
      subroutine get_jetbend_velocity(xsten,nhalf,dx,bfact,vel)
      IMPLICIT NONE

      INTEGER_T nhalf,bfact
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T x,y,z
      REAL_T dx(SDIM)
      REAL_T cenbc(num_materials,SDIM)
      REAL_T vel(SDIM)

      INTEGER_T dir2
      REAL_T vfrac(num_materials)
      REAL_T angle
      INTEGER_T nmat
      REAL_T xrot,yrot,xrot2,yrot2,radrot,xcen,ycen
      REAL_T dnode1,dnode2

      if (nhalf.lt.3) then
       print *,"nhalf invalid get jetbend velocity"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif

      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)

      nmat=num_materials
      do dir2=1,SDIM
       vel(dir2)=zero
      enddo

      if (probtype.eq.537) then  ! get_jetbend_velocity

       call get_jet_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,nmat)
       if (vfrac(1).gt.zero) then
        vel(SDIM)=advbot
       else
        vel(1)=adv_vel
       endif

      else if (SDIM.eq.2) then

       if ((probtype.eq.53).and.(axis_dir.ne.2)) then
       
        call get_jet_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,nmat)  
        if (vfrac(1).gt.zero) then
          ! this is plug flow
         vel(SDIM)=advbot
         if (1.eq.0) then
          ! u=A(1-(r/r0)^2)  uavg=A(r^2/2-r^4/4 (1/r0^2)) |_0^r0 /
          !                       r^2/2 |_0^r0 =
          ! A(r0^2/2-r0^2/4)/r0^2/2 = A/2
          if (abs(x).lt.radblob) then
           vel(SDIM)=two*advbot*(one-(x/radblob)**2) 
          else
           vel(SDIM)=zero
          endif
         endif
        else
         vel(1)=adv_vel
        endif

       else if ((probtype.eq.53).and.(axis_dir.eq.2)) then
         ! do nothing
       else if (probtype.eq.532) then !impinge from the sides get_jetbend_vel

        angle=0.5235988

        call get_jet_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,nmat) 

        if (vfrac(1).gt.zero) then  
         vel(SDIM)=advbot*cos(angle)
         if (x.lt.zero) then
          vel(SDIM-1)=advbot*sin(angle)
         else
          vel(SDIM-1)=-advbot*sin(angle)
         endif
        else
         vel(SDIM)=zero
        endif

        ! 2D diesel injector w/needle
       else if ((probtype.eq.538).or. & ! inputs.injA
                (probtype.eq.541)) then 

        call get_initial_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,nmat)
        if (vfrac(1).gt.zero) then
         vel(SDIM)=advbot
        endif

       else if (probtype.eq.539) then ! supnozz - jetbend_vel

        call get_initial_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,nmat)
        if (vfrac(1).gt.VOFTOL) then !initial velocity in the gap
         angle=1.07961377
         vel(1)=advbot*cos(angle)
         vel(2)=advbot*sin(angle)
        endif
  
       else
        print *,"probtype invalid in get jetbend vel 2D"
        stop
       endif

      else if (SDIM.eq.3) then

       if (probtype.eq.532) then ! impinge from the sides get_jetbend_vel

        angle=0.5235988

        call get_jet_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,nmat) 

        if (vfrac(1).gt.zero) then  
         vel(SDIM)=advbot*cos(angle)
         if (y.lt.zero) then
          vel(SDIM-1)=advbot*sin(angle)
         else
          vel(SDIM-1)=-advbot*sin(angle)
         endif
        else
         vel(SDIM)=zero
        endif

       else if (probtype.eq.530) then  ! impinge jets

        angle=0.5235988

        if (axis_dir.eq.0) then ! impinge like jets
         radrot=0.2
         xcen=xblob
         ycen=yblob+radrot
         xrot2=sin(xblob2)*radrot+xcen
         yrot2=cos(xblob2)*radrot+ycen
         xrot=xcen-sin(xblob2)*radrot
         yrot=ycen-cos(xblob2)*radrot
         dnode1=sqrt( (x-xrot)**2 + (y-yrot)**2 )
         dnode2=sqrt( (x-xrot2)**2 + (y-yrot2)**2 )

         call get_jet_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,nmat) 

         if (vfrac(1).gt.zero) then  
          vel(SDIM)=advbot*cos(angle)

          if (dnode1.lt.dnode2) then
           vel(SDIM-1)=advbot*sin(angle)*cos(xblob2)
           vel(1)=advbot*sin(angle)*sin(xblob2)
          else
           vel(SDIM-1)=-advbot*sin(angle)*cos(xblob2)
           vel(1)=-advbot*sin(angle)*sin(xblob2)
          endif
         else
          vel(SDIM)=zero
         endif

        else if (axis_dir.eq.1) then  ! impinge unlike jets

         call get_jet_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,nmat) 
         if ((vfrac(1).gt.zero).or.(vfrac(3).gt.zero)) then
          vel(SDIM)=advbot*cos(angle)
          if (vfrac(1).gt.zero) then
           vel(SDIM-1)=advbot*sin(angle)
          endif 
          if (vfrac(3).gt.zero) then
           vel(SDIM-1)=-advbot*sin(angle)
          endif 
         else
          vel(SDIM)=zero
         endif
        else
         print *,"axis_dir invalid"
         stop
        endif

         ! 3D get_jetbend_velocity - not impinging jets options
         ! 530 and 532 should not appear here.
       else if ( ((probtype.eq.53).and.(axis_dir.ne.2)).or. &  
                 (probtype.eq.536)) then

        call get_jet_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,nmat) 
        if (vfrac(1).gt.zero) then
         vel(SDIM)=advbot
        else
         vel(1)=adv_vel
        endif

        ! 3D diesel injector w/needle
       else if ((probtype.eq.538).or. & ! inputs.injA
                (probtype.eq.541)) then 

        call get_initial_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,nmat) 
        if (vfrac(1).gt.zero) then
         vel(SDIM)=advbot
        endif

        ! jetbend with nozzle and pressure bc.
       else if ((probtype.eq.53).and.(axis_dir.eq.2)) then
         ! do nothing
       else
        print *,"probtype invalid in get jetbend vel"
        stop
       endif

      else
       print *,"dimension bust"
       stop
      endif

      return
      end subroutine get_jetbend_velocity


      ! called when: 
      ! probtype.eq.53, probtype.eq.532, 
      ! probtype.eq.530, probtype.eq.538,
      ! probtype.eq.539, probtype.eq.529,
      ! probtype.eq.531, probtype.eq.536,
      ! probtype.eq.537 
      subroutine get_jet_dist(x,y,z,nmat,dist)
      use global_utility_module
      use global_distance_module

      IMPLICIT NONE

      INTEGER_T nmat
      REAL_T dist(nmat)
      REAL_T x,y,z,zmin,zmax,dist1,dist2
      REAL_T xmin,xmax
      REAL_T distsolid
      INTEGER_T im
      REAL_T xrot,yrot,xrot2,yrot2,radrot
      REAL_T xcen,ycen,zcen
      REAL_T angle
      REAL_T xcrit,ycrit,zcrit
      REAL_T xcenbase,xcritbase
      REAL_T ycenbase,ycritbase
      REAL_T y2d
      REAL_T initial_time

      INTEGER_T im_solid_jet


      im_solid_jet=im_solid_primary()

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      if (SDIM.eq.2) then
       if (abs(z-y).gt.VOFTOL) then
        print *,"expecting z=y in 2d 8"
        stop
       endif
      endif

      if (SDIM.eq.2) then
       y2d=zero
      else
       y2d=y
      endif

      initial_time=zero

      do im=1,nmat
       dist(im)=-99999.0
      enddo


      distsolid=-9999.0
      do im=1,nmat
       if (is_rigid(nmat,im).eq.1) then
         ! in get_jet_dist; positive in solid.
        call materialdistsolid(x,y2d,z,dist(im),initial_time,im)
        if (dist(im).gt.distsolid) then
         distsolid=dist(im)
        endif
       else if (is_rigid(nmat,im).eq.0) then
        ! do nothing
       else
        print *,"is_rigid invalid"
        stop
       endif
      enddo ! im=1..nmat
   
      if (probtype.eq.538) then ! get_jet_dist (inputs.injA)

        ! 2D get_jet_dist: diesel injector w/needle 
       if (SDIM.eq.2) then
        zmin=zblob-0.1
        zmax=zblob+zblob2
        xmin=xblob-radblob
        xmax=xblob+radblob
        call squaredist(x,y,xmin,xmax,zmin,zmax,dist(1))
        dist(1)=-dist(1)
        dist(2)=-dist(1)
       else if (SDIM.eq.3) then
        if (1.eq.0) then ! old
         zmin=zblob-0.1
         zmax=zblob+zblob2
        else   ! new, January 2018
         zmin=zblob
         zmax=zblob2
        endif
        call cylinderdist(x,y,z,xblob,yblob,radblob,zmin,zmax,dist(1))
        dist(1)=-dist(1)
        dist(2)=-dist(1)
       else
        print *,"dimension bust"
        stop
       endif
 
      else if (probtype.eq.537) then ! get_jet_dist

       zmin=-1.0e+10
       zmax=zblob

        ! dist>0 outside the cylinder in cylinderdist.
       call cylinderdist(x,y2d,z,xblob,yblob,radblob,zmin,zmax,dist(1))
       dist(1)=-dist(1)
       dist(2)=-dist(1)
       if ((im_solid_jet.lt.1).or. &
           (im_solid_jet.gt.nmat)) then
        print *,"im_solid_jet invalid 8"
        stop
       endif

      else if (SDIM.eq.2) then

       if (probtype.eq.541) then
        zmin=zblob-0.5
        zmax=zblob+zblob2
        xmin=xblob-radblob
        xmax=xblob+radblob
        call squaredist(x,y,xmin,xmax,zmin,zmax,dist(1))
        dist(1)=-dist(1)
        dist(2)=-dist(1)
       else if (probtype.eq.539) then ! oblique gap - get_jet_dist
         call gapdist(x,y,xblob,radblob,yblob,yblob2,xblob2,dist(1))
         dist(1)=-dist(1)
         dist(2)=-dist(1)

          ! 2D atomization problem
       else if (probtype.eq.53) then

        zmin=zblob-1.0e+10
        zmax=zblob+radblob
        xmin=xblob-radblob
        xmax=xblob+radblob
         ! dist<0 in the square.
        call squaredist(x,y,xmin,xmax,zmin,zmax,dist(1))
        dist(1)=-dist(1)
        dist(2)=-dist(1)

        if ((axis_dir.eq.1).or.(axis_dir.eq.2)) then
         if ((im_solid_jet.lt.1).or. &
             (im_solid_jet.gt.nmat)) then
          print *,"im_solid_jet invalid 9"
          stop
         endif
        else if (axis_dir.ne.0) then
         print *,"axis_dir invalid probtype=53"
         stop
        endif

       else if (probtype.eq.532) then ! impinge from the sides get_jet_dist

         ! find distance by tracing back along characteristic

        angle=0.5235988

         ! ycrit=y coordinate of point to find distance
        xcrit=abs(x)
        if (xcrit.lt.probhix-radblob) then
         xcrit=probhix-radblob
        endif
        zcrit=y

          ! given point on center axis
        xcen=probhix+radblob
        zcen=zblob

        xcenbase=tan(angle)*zcen+xcen
        xcritbase=tan(angle)*zcrit+xcrit 

        dist1=radblob-sqrt( (xcritbase-xcenbase)**2 )
        if (abs(x).lt.xcrit) then
         if (dist1.ge.zero) then
          dist1=-sqrt( (xcrit-abs(x))**2 )
         else
          dist1=-sqrt( (xcrit-abs(x))**2+dist1**2 )
         endif
        endif
        dist(1)=dist1
        dist(2)=-dist(1)
       else
        print *,"probtype invalid get_jet_dist probtype=",probtype
        stop
       endif

      else if (SDIM.eq.3) then

        ! 3d diesel injector w/needle
       if (probtype.eq.541) then 
        zmin=zblob-0.1
        zmax=zblob+zblob2
        call cylinderdist(x,y,z,xblob,yblob,radblob,zmin,zmax,dist(1))
        dist(1)=-dist(1)
        dist(2)=-dist(1)
       else if (probtype.eq.529) then  ! 3d airblast

        zmin=xblob-5*radblob
        zmax=xblob+2*radblob
        if (levelrz.eq.0) then
         call cylinderdist(z,y,x,zblob,yblob,radblob,zmin,zmax,dist(1))
         dist(1)=-dist(1)
        else
         print *,"levelrz invalid get jet dist"
         stop
        endif
        dist(2)=-dist(1)
        
          ! 3D atomization
       else if (probtype.eq.53) then  ! get_jet_dist

           ! dist>0 outside the cylinder in cylinderdist
        zmin=zblob-1.0e+10
        zmax=zblob+radblob
        if (levelrz.eq.0) then
         call cylinderdist(x,y,z,xblob,yblob,radblob,zmin,zmax,dist(1))
         dist(1)=-dist(1)
        else
         print *,"levelrz invalid get jet dist 2"
         stop
        endif 
        dist(2)=-dist(1)

        if (axis_dir.eq.100) then

         ! do nothing; this routine called from materialdist_batch 
         ! which takes into account the nozzle.  
         ! Set default values here.

        else if ((axis_dir.eq.1).or.(axis_dir.eq.2)) then
           ! cylindrical solid nozzle if axis_dir=1
         if ((im_solid_jet.lt.1).or. &
             (im_solid_jet.gt.nmat)) then
          print *,"im_solid_jet invalid 10"
          stop
         endif
        else if (axis_dir.ne.0) then
         print *,"axis_dir invalid"
         stop
        endif

       else if (probtype.eq.532) then  ! impinge from the sides get_jet_dist
         ! find distance by tracing back along characteristic

        angle=0.5235988

         ! ycrit=y coordinate of point to find distance
        ycrit=abs(y)
        if (ycrit.lt.probhiy-radblob) then
         ycrit=probhiy-radblob
        endif
        zcrit=z 

          ! given point on center axis
        ycen=probhiy+radblob
        zcen=zblob

          ! v=advbot * sin(angle)
          ! w=advbot * cos(angle)
          ! slope of center axis is dz/dy=-cos(angle)/sin(angle)
          ! or dy/dz=-tan(angle)
          ! y=-tan(angle) (z-zcen) + ycen  is equation for center axis.
          ! the equation of the characteristic going through (y*,z*)
          ! is:
          ! y=-tan(angle) (z-z*) + y*
          ! if base is at z=0, then
          ! ybase=-tan(angle)*(-z*)+y*=tan(angle)*(z*)+y*
        ycenbase=tan(angle)*zcen+ycen
        ycritbase=tan(angle)*zcrit+ycrit 

        dist1=radblob-sqrt( x**2 + (ycritbase-ycenbase)**2 )
        if (abs(y).lt.ycrit) then
         if (dist1.ge.zero) then
          dist1=-sqrt( (ycrit-abs(y))**2 )
         else
          dist1=-sqrt( (ycrit-abs(y))**2+dist1**2 )
         endif
        endif
        dist(1)=dist1
        dist(2)=-dist(1)
        
       else if (probtype.eq.530) then  ! impinging jets

        if (axis_dir.eq.0) then
         radrot=0.2
         xcen=xblob
         ycen=yblob+radrot
         xrot2=sin(xblob2)*radrot+xcen
         yrot2=cos(xblob2)*radrot+ycen
         xrot=xcen-sin(xblob2)*radrot
         yrot=ycen-cos(xblob2)*radrot
   
         zmin=zblob-1.0e+10
         zmax=zblob+radblob
         call cylinderdist(x,y,z,xrot,yrot,radblob,zmin,zmax,dist1)
         call cylinderdist(x,y,z,xrot2,yrot2,radblob,zmin,zmax,dist2)
         dist(1) = max(-dist1,-dist2)
         dist(2)=-dist(1)
        else if (axis_dir.eq.1) then ! impinging jets two materials

         if (nmat.lt.3) then
          print *,"num_materials too small"
          stop
         endif

         zmin=zblob-1.0e+10
         zmax=zblob+radblob

           ! dist>0 outside the cylinder, in cylinderdist
         call cylinderdist(x,y,z,xblob,yblob,radblob,zmin,zmax,dist1)
         yblob2=yblob+0.4
         call cylinderdist(x,y,z,xblob,yblob2,radblob,zmin,zmax,dist2)
         dist(2) = -max(-dist1,-dist2)
         dist(1)=-dist1
         dist(3)=-dist2
        else
         print *,"axis_dir invalid"
         stop
        endif

       else
        print *,"probtype invalid get_jet_dist 3d probtype=",probtype
        stop
       endif

      else
       print *,"dimension bust"
       stop
      endif

      return
      end subroutine get_jet_dist

      subroutine is_dissolution(iflag)
      IMPLICIT NONE

      INTEGER_T iflag


      if (SDIM.eq.3) then
       iflag=0
      else if (SDIM.eq.2) then
       if (probtype.eq.802) then
        iflag=1
       else 
        iflag=0
       endif
      else
       print *,"dimension bust"
       stop
      endif

      return
      end subroutine is_dissolution


      subroutine blob_array_dist(x,y,z,dist)
      IMPLICIT NONE

      REAL_T x,y,z,dist
      REAL_T hugedist
      INTEGER_T icomp,dir
      REAL_T distarr(10)
      REAL_T rr
      REAL_T xx(SDIM)

      if (SDIM.eq.2) then
       if (abs(z-y).gt.VOFTOL) then
        print *,"z=y expected if 2D (in blob_array_dist)"
        stop
       endif
      endif
      hugedist=99999.0

      dist=hugedist

      do icomp=1,10
       distarr(icomp)=hugedist
       rr=radblobarr(icomp)
       if (rr.gt.zero) then
        xx(1)=x-xblobarr(icomp)
        xx(2)=y-yblobarr(icomp)
        if (SDIM.eq.3) then
         xx(SDIM)=z-zblobarr(icomp)
        endif
        distarr(icomp)=zero
        do dir=1,SDIM
         distarr(icomp)=distarr(icomp)+xx(dir)**2
        enddo
        distarr(icomp)=sqrt(distarr(icomp))-rr
      
        dist=min(dist,distarr(icomp))
       endif ! rr>0 
      enddo ! icomp

      return
      end subroutine blob_array_dist

! dist>0 in material 1
! dist<0 in material 2
      subroutine vapordist(xsten,nhalf,dx,bfact,dist)
      use global_utility_module
      use global_distance_module
      use shockdrop
      use marangoni

      IMPLICIT NONE
      INTEGER_T bfact,nhalf
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T xparm(SDIM)
      REAL_T x,y,z,dist
      REAL_T dx(SDIM)

      REAL_T NPT,HSB,NID,NOD,CHH,scaleCHH,VRAD,dist1,dist2
      REAL_T xmin,xmax,ymin,ymax,zmin,zmax,zz,temprad
      REAL_T m,b
      INTEGER_T igeom
      REAL_T costheta,sintheta,xprime,yprime,zprime,delta
      REAL_T h1
      REAL_T hugedist
      REAL_T distbatch(num_materials)
      INTEGER_T nmat
      REAL_T initial_time
      REAL_T ypretend
      REAL_T wave_number
      REAL_T ktermx,velperturbx
      REAL_T drat,veltop,velbot,ytop,ybot,y2d

      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)

      if (SDIM.eq.2) then
       if (abs(z-y).gt.VOFTOL) then
        print *,"z=y expected if 2D (in vapordist)"
        stop
       endif
      endif

      if (nhalf.lt.1) then
       print *,"nhalf invalid vapordist"
       stop
      endif

      initial_time=zero
      nmat=num_materials

      hugedist=99999.0

      igeom=0

      dist=hugedist

       ! vapordist
      if ((probtype.eq.1).and.(axis_dir.eq.15)) then
       if (SDIM.eq.2) then
        dist=-sqrt( (x-xblob)**2 + (y-yblob)**2 )+radblob
       else
        dist=-sqrt((x-xblob)**2+(y-yblob)**2+(z-zblob)**2)+radblob
       endif
       ! vapordist 2d or 3d
       ! dist>0 in material 1
       ! dist<0 in material 2
      else if ((probtype.eq.1).and. &
               ((axis_dir.eq.150).or. &
                (axis_dir.eq.151))) then 
       call shockdrop_dropLS(x,y,z,dist, &
        xblob,yblob,zblob,radblob,axis_dir)
      else if (probtype.eq.537) then ! vapordist

        zmin=-1.0e+10
        zmax=zblob
        if (SDIM.eq.2) then
         y2d=zero
        else
         y2d=y
        endif
         ! dist>0 outside the cylinder in cylinderdist.
        call cylinderdist(x,y2d,z,xblob,yblob,radblob,zmin,zmax,dist)
        dist=-dist

      else if (probtype.eq.801) then

       ! vapordist:
       ! test problems from Welch and Wilson 2000
       ! vapor on left, water on right.

       if (axis_dir.eq.0) then
        dist=x-xblob
        if (num_materials.eq.3) then
         dist=sqrt( (x-xblob)**2 )-radblob
        endif
       else if (axis_dir.eq.1) then
        dist=y-yblob
       else if ((axis_dir.eq.2).and.(SDIM.eq.3)) then
        dist=z-zblob
       else if (axis_dir.eq.3) then
        if (SDIM.eq.2) then
         dist=sqrt( (x-xblob)**2+(y-yblob)**2 )-radblob
        else if (SDIM.eq.3) then
         dist=sqrt( (x-xblob)**2+(y-yblob)**2+(z-zblob)**2 )-radblob
        else
         print *,"dimension bust"
         stop
        endif
       else
        print *,"axis_dir invalid"
        stop
       endif

       ! vapordist: cavity boiling (2d or 3d)
      else if (probtype.eq.710) then

       xparm(1)=x  
       xparm(2)=y  
       if (SDIM.eq.3) then
        xparm(SDIM)=z
       endif
       call cavity_distf_12(levelrz+1,xparm,dist)
       dist=-dist

      else if (probtype.eq.92) then ! shock tube
       ! do nothing
      else if (probtype.eq.93) then ! shock tube with interface

       dist=xblob-x

      else if (SDIM.eq.2) then

        ! dissolution (vapordist)
       if (probtype.eq.802) then
        ktermx=two*Pi*yblob3*x/(two*radblob)
        velperturbx=one+radblob3*cos(ktermx)
        if (y.gt.yblob) then
         dist=yblob+radblob*velperturbx-y
        else 
         dist=y-(yblob-radblob*velperturbx)
        endif

         ! Rayleigh Taylor (vapordist)
       else if (probtype.eq.602) then
         ! yblob is the average height of the interface 
         ! between water and air
         ! radblob is the amplitude of the perturbation
         ! problox <= x <= probhix
         ! y=yblob+radblob*cos(2.0*pi*(x-problox)/(probhix-problox))
        if (xblob.lt.zero) then
         print *,"xblob invalid for rayleigh taylor test"
         stop
        else if (xblob.eq.zero) then
         wave_number=one
        else
         wave_number=xblob
        endif
        if ((xblob.ge.1.0D+5).and.(radblob.le.0.001*dx(1))) then
         dist=y-(yblob+half*dx(2))
        else 
         dist=y-(yblob+ &
          radblob*cos(two*Pi*wave_number*(x-problox)/(probhix-problox)))
        endif

       else if (probtype.eq.603) then  ! Benard advection (vapordist)
        dist=zblob-y

        ! driven wave problem, water on bottom, air on top.
       else if (probtype.eq.90) then
        dist=yblob-y
       else if (probtype.eq.540) then ! Rieber simulation vapordist 2D
        dist=radblob-sqrt(x**2 + (y-yblob)**2)
       
        if (radblob2.ne.zero) then
         if (radblob3.ne.zero) then
          print *,"cannot have both radblob2 and radblob3 <>0"
          stop
         endif
         dist2=radblob2-y
         if (dist2.gt.dist) then
          dist=dist2
         endif
        endif

! Roper nozzle problem
       else if (probtype.eq.102) then
        dist=half*(radblob5+radblob2)-abs(x)
        dist2=yblob+yblob2-y
        if (dist2.lt.dist) then
         dist=dist2
        endif 
       else if (probtype.eq.3) then
        dist=xblob+radblob*cos(two*Pi*y/yblob)-x
       else if (probtype.eq.4) then
        call rtdist(x,y,dist)
       else if (probtype.eq.7) then
        dist = radblob-sqrt((x-xblob)**2 + (y-yblob)**2)
        dist1 = yblob-two-y
        if (dist1.gt.dist) then
         dist=dist1
        endif
       else if (probtype.eq.8) then
        dist = -radblob+sqrt((x-xblob)**2 + (y-yblob)**2)
        dist1 = yblob+radblob-y+0.2
        if (dist1.lt.dist) then
         dist=dist1
        endif
       else if (probtype.eq.531) then  ! rigid body problem - vapordist
        if ((axis_dir.eq.0).or.(axis_dir.eq.1)) then
         dist=yblob2-y
        else if (axis_dir.eq.2) then
         dist=yblob2-y
         dist2=radblob2-sqrt((x-xblob)**2 + (y-yblob)**2)
         if (dist.lt.dist2) then
          dist=dist2
         endif 
        else if (axis_dir.eq.3) then
         dist=99999.0
        else
         print *,"axis_dir invalid probtype=531"
         stop
        endif

! microfluidics channel -- 0,3,4 Roper, 1 Comsol, 2,5 squeeze vapordist
       else if (probtype.eq.5700) then
        if (axis_dir.eq.2) then
         print *,"axis_dir=2 obsolete"
         stop
        else if (axis_dir.eq.5) then
         dist=y-yblob
        else if ((axis_dir.eq.0).or.(axis_dir.eq.1).or. &
                 (axis_dir.eq.3).or.(axis_dir.eq.4)) then
         dist=y-yblob
         if (xblob4.gt.zero) then
          if ((y.ge.yblob).and.(x.le.half*xblob4)) then
           if (y-yblob.le.x-half*xblob4) then
            dist=y-yblob
           else
            dist=half*xblob4-x
           endif
          else if ((y.le.yblob).and.(x.le.half*xblob4)) then
           dist=y-yblob
          else if (y.ge.yblob) then
           dist=half*xblob4-x
          else
           dist=-sqrt( (half*xblob4-x)**2+(y-yblob)**2 )
          endif
         endif
        else
         print *,"axis_dir invalid probtype=5700"
         stop
        endif

       else if (probtype.eq.101) then
! dist<0 inside the square
        if (axis_dir.eq.0) then
         call squaredist(x,y,xblob-radblob,xblob+radblob,yblob-radblob, &
          yblob+radblob,dist)
        else if (axis_dir.eq.1) then
         h1=1.10*radblob
         call squaredist(x,y,xblob-radblob-h1,xblob+radblob-h1,yblob-radblob, &
          yblob+radblob,dist)
         call squaredist(x,y,xblob-radblob+h1,xblob+radblob+h1,yblob-radblob, &
          yblob+radblob,dist2)
         if (dist2.lt.dist) then
          dist=dist2
         endif
        endif
       else if (probtype.eq.58) then
        dist=yblob+radblob*cos(two*Pi*x/xblob)-y
       elseif ((probtype.eq.63).or.(probtype.eq.64)) then
         if (y.ge.two*xblob10) then
          dist=half*xblob10-x
         else
          dist=half*xblob10-x+(two*xblob10-y)
         endif
       else if ((probtype.eq.1).and.(axis_dir.eq.13)) then

           ! dist<0 in the blobs.
        call blob_array_dist(x,y,z,dist)

       else if ((probtype.eq.1).and.(axis_dir.eq.11)) then ! vapordist 2d
        dist=sqrt( (x-xblob)**2 + (y-yblob)**2 )-radblob
       else if ((probtype.eq.1).and.(axis_dir.eq.12)) then ! vapordist 2d
        dist=-sqrt( (x-xblob)**2 + (y-yblob)**2 )+radblob
       else if ((probtype.eq.1).and.(axis_dir.eq.14)) then
        dist=-sqrt( (x-xblob)**2 + (y-yblob)**2 )+radblob
       else if ((probtype.eq.1).and.(axis_dir.eq.140)) then
        dist=max(-sqrt( (x-xblob)**2 + (y-yblob)**2 )+radblob, &
                 -sqrt( (x-xblob)**2 + (y-yblob2)**2 )+radblob)
       else if ((probtype.eq.1).and.(axis_dir.eq.141)) then
        dist=-sqrt( (x-xblob)**2 + (y-yblob)**2 )+radblob
       else if ((probtype.eq.1).and.(axis_dir.lt.150)) then
        dist=sqrt( (x-xblob)**2 + (y-yblob)**2 )-radblob
       else if (probtype.eq.5) then
        call ellipsedist(x,y,radblob,zblob,xblob,yblob,dist)
       else if (probtype.eq.12) then
        call legenddist(x,y,dist)
       else if (probtype.eq.13) then
        call legenddist(x,y,dist)
       else if (probtype.eq.14) then
        dist = sqrt((x-xblob)**2 + (y-yblob)**2)-radblob
       else if (probtype.eq.16) then
         if (x.le.xblob+radblob) then
          dist=yblob-y-1.0D-3
         else
          dist=sqrt((x-xblob-radblob)*(x-xblob-radblob)+ &
                    (yblob-y)*(yblob-y))
         endif
         ! vapordist
         ! water (material 3) on top
         ! diesel (material 1) on bottom
         ! for probtype=18, same liquid top or bottom
       else if ((probtype.eq.17).or.(probtype.eq.18)) then
        if ((xblob.ne.zero).or.(yblob.ne.zero).or. &
            (radblob.ne.half)) then
         print *,"set xblob=yblob=0 radblob=1/2 drop collide"
         stop
        endif
        if (probtype.eq.18) then
         drat=one
        else
         drat=fort_denconst(3)/fort_denconst(1)  ! dentop/denbot
        endif
        veltop=-one/(drat+one)
        velbot=drat/(drat+one)
        ytop=yblob+1.25*radblob
        ybot=yblob-radblob+(ytop-yblob-radblob)*velbot/veltop

        dist = radblob-sqrt((x-xblob)**2+(y-ytop)**2)  ! water (3,top)
        dist1 = radblob-sqrt((x-xblob)**2+(y-ybot)**2) ! oil (1,bot)
        if (dist1.gt.dist) then
         dist=dist1
        endif
       else if (probtype.eq.31) then ! vapordist: translating circle
        dist=sqrt( (x-xblob)**2 + (y-yblob)**2 ) - radblob
       else if (probtype.eq.23) then
        dist=yblob+radblob*cos(two*Pi*x/xblob)-y
       else if ((probtype.eq.24).or.(probtype.eq.27)) then
        dist=half-y
       else if (probtype.eq.28) then ! prescribed velocity 2D
        if (axis_dir.eq.0) then
         call zalesakdist(dist,x,y)
        else if (axis_dir.eq.1) then
         xprime=(x-xblob)/10.0
         yprime=(y-yblob)/10.0+2.0
         call Adist(xprime,yprime,dist)
        else if (axis_dir.eq.2) then
         dist=sqrt( (x-xblob)**2 + (y-yblob)**2 ) - radblob
        else if (axis_dir.eq.3) then
           ! dist<0 inside the triangle.
         call triangledist(x,y,xblob,xblob2,yblob,yblob2,dist)
        else if (axis_dir.eq.4) then
           ! dist<0 inside the polygon
         call polygondist(x,y,xblob,xblob2,yblob,yblob2, &
          xblob3,yblob3,dist)
        else
         print *,"axis_dir invalid probtype=28"
         stop
        endif
       else if (probtype.eq.29) then ! 2d single vortex, vapordist
        call deformdist(dist,x,y)
       else if ((probtype.eq.25).and.(axis_dir.eq.0)) then ! vapordist
        dist=sqrt((x-xblob)**2+(y-yblob)**2)-radblob
        dist=-dist
        ! vapordist - bubble formation
       else if ((probtype.eq.25).and.(axis_dir.ge.1).and. &
                (axis_dir.le.11)) then
        if (zblob.le.zero) then
         print *,"zblob (nozzle ht) must be positive"
         stop
        else  
          ! dist<0 in the square.
         call squaredist(x,y,-radblob,radblob,-1000.0*zblob,zblob,dist)
        endif
       else if (probtype.eq.51) then  ! vapordist oscillating column
        dist=radblob-abs(x-xblob) 
       else if (probtype.eq.43) then  ! vapordist 
        xmin=-xblob-radblob
        xmax=xblob+radblob
        ymin=-yblob/two
        ymax=yblob/two
        if (zblob.gt.zero) then
         ymin=ymin-zblob/two
         ymax=ymax+zblob/two
        endif
        call squaredist(x,y,xmin,xmax,ymin,ymax,dist)
       else if (probtype.eq.48) then
        dist1=y-yblob
        m=-one
        b=yblob-m*xblob
        dist2=y-(m*x+b)
        dist=dist1
        if (dist.lt.dist2) then
         dist=dist2
        endif
       else if (probtype.eq.11) then
        print *,"cavitation with top wall outflow cond. is deleted"
        stop
       else if (probtype.eq.47) then
        if (radblob.ne.zero) then
          dist=radblob-abs(x-half*xblob)
        else
          print *,"radblob cannot equal zero!"
          stop
        endif
       else if (probtype.eq.35) then
        dist=half*yblob-y
       else if (probtype.eq.2) then
        dist=sqrt((x-xblob)**2+(y-yblob)**2)-radblob
       else if (probtype.eq.201) then  ! vapordist stratified 2D
        dist=sqrt((x-xblob)**2+(y-yblob)**2)-radblob
       else if (probtype.eq.202) then  ! vapordist liquid lens
        dist=sqrt((x-xblob)**2+(y-yblob)**2)-radblob
       else if (probtype.eq.36) then ! vapordist 2D: bubble

        call spheredist(x,y,z,dist)  ! dist<0 in the sphere

        if ((probtype.eq.36).and.(axis_dir.eq.100)) then
         dist=-dist
        endif

        if ((probtype.eq.36).and.(axis_dir.eq.210)) then
         dist=(y+radblob*(x-xblob)-yblob)/sqrt(one+radblob**2)
        endif

        if ((probtype.eq.36).and.(axis_dir.eq.7)) then
         xmin=xblob-radblob
         xmax=xblob+radblob
         ymin=yblob-radblob
         ymax=yblob+radblob
         call squaredist(x,y,xmin,xmax,ymin,ymax,dist)
        endif
         ! marangoni (heat pipe) problem dist<0 in the bubble
        if ((probtype.eq.36).and.(axis_dir.eq.10)) then
         call dist_long_bubble(radblob,radblob2,x,y,z,dist)
        endif

        ! vapordist bubble jetting 2D - dist>0 in the water.
       else if (probtype.eq.42) then 

        dist=sqrt( (x-xblob)**2 + (y-yblob)**2 )-radblob

         ! if free surface is in the domain
        dist1=zblob+yblob-y
        if (dist1.lt.dist) then
         dist=dist1
        endif

        ! vapordist cavitation 2D - dist>0 in the water for jwl case,
        ! dist>0 in the sphere for the sphere impact case.
       else if (probtype.eq.46) then

        if ((axis_dir.ge.0).and.(axis_dir.lt.10)) then 
         call cavitation_bubble_dist(xsten,nhalf,dist,dx,bfact)
         dist=-dist

          ! if free surface is in the domain
         dist1=zblob+yblob-y
         if (dist1.lt.dist) then
          dist=dist1
         endif
        else if (axis_dir.eq.10) then
         dist=radblob-sqrt( (x-xblob)**2 + (y-yblob)**2 )

         ! CODY ESTEBE created test problem
        else if (axis_dir.eq.20) then
         dist=99999.0
        else
         print *,"axis_dir invalid"
         stop
        endif

       else if (probtype.eq.9) then  ! ship wave free surface (vapordist) 2D
        ypretend=zero
        call boatdist(x,ypretend,y,dist)
       else if (probtype.eq.37) then
        dist=radblob-sqrt( (x-xblob)**2 + (y-yblob)**2 )
       else if ((probtype.eq.22).and.(axis_dir.eq.14)) then
        call initjetparms(HSB,NOD,NPT,NID,CHH,scaleCHH)
        VRAD=scaleCHH/eight
        dist=sqrt( (x-zero)**2 + (y-zero)**2 ) - VRAD  
       else if (probtype.eq.39) then
        dist=yblob+radblob*cos(two*Pi*x/xblob)-y
! Suvorov Formation of Taylor cone...
        if (radblob3.gt.zero) then
         dist=0.2*exp(-radblob3*x*x)-y+yblob3
        endif
! pipe - vapordist 2D
       else if (probtype.eq.41) then
        call inletpipedist(x,y,z,nmat,distbatch) 
        dist=distbatch(1)
       else if (probtype.eq.44) then
         ! in 2d, y=z
        call damdist(x,z,dist,igeom)
       else if (probtype.eq.45) then
        dist=yblob+1/(2*Pi)*(radblob*cos(2*Pi*(x-0.1)/xblob)+ &
           1/2*radblob**2*cos(4*Pi*(x-0.1)/xblob)+ &
           3/8*radblob**3*cos(6*Pi*(x-0.1)/xblob))-y
       else if (probtype.eq.21) then
        dist=yblob/two-y
       else if (probtype.eq.49) then
        dist=sqrt((x-xblob)**2+(y-yblob)**2) - radblob
        dist1= 1 - (y-yblob)
        if (dist1.lt.dist) then
         dist=dist1
        endif
       else if (probtype.eq.53) then  ! 2D JICF vapordist
        call get_jet_dist(x,y,z,nmat,distbatch)
        dist=distbatch(1)
       else if (probtype.eq.532) then ! impinge from sides (vapordist)
        call get_jet_dist(x,y,z,nmat,distbatch)
        dist=distbatch(1)
         ! 2d diesel injector w/needle (vapordist)
       else if ((probtype.eq.538).or. &  ! inputs.injA
                (probtype.eq.541)) then
        call get_jet_dist(x,y,z,nmat,distbatch)
        dist=distbatch(1)
       else if (probtype.eq.701) then ! flapping wing (vapordist 2D)
        if ((axis_dir.eq.0).or.(axis_dir.eq.1)) then
         dist=zblob-y
        else if (axis_dir.eq.2) then
         dist=hugedist
        else
         print *,"axis_dir invalid"
         stop
        endif
       else if (probtype.eq.539) then ! jet w/ supersonic crossflow - vapordist
        call get_jet_dist(x,y,z,nmat,distbatch)
        dist=distbatch(1)
       else if(probtype.eq.72) then
        xmin=xblob-radblob
        xmax=xblob+radblob
        ymin=zblob-1.0e+10
        ymax=zblob+radblob
        call squaredist(x,y,xmin,xmax,ymin,ymax,dist)
        dist=-dist
       else if (probtype.eq.54) then
        xmin=-xblob
        xmax=xblob
        ymin=-yblob
        ymax=yblob+half*yblob
        call squaredist(x,y,xmin,xmax,ymin,ymax,dist)
        dist=-dist
       else if (probtype.eq.61) then
        dist=-(sqrt((x-xblob)**2+(y-yblob)**2) - radblob)
        if (axis_dir.eq.0) then
         dist1=-(3 + (y-yblob))
        else if (axis_dir.eq.1) then
         dist1=-(radblob + (y-yblob))
        else
         print *,"axis_dir invalid probtype=61"
         stop
        endif
  
        if (dist1.gt.dist) then
         dist=dist1
        endif
       else if (probtype.eq.62) then
        dist=zblob3-y
        costheta=cos(xblob2)
        sintheta=sin(xblob2)
        xprime=costheta*(x-xblob)-sintheta*(y-yblob)
        yprime=sintheta*(x-xblob)+costheta*(y-yblob)
        delta=half*(radblob2-radblob)
        temprad=1.0D+10
        call squaredist(xprime,yprime,-radblob-delta,radblob+delta, &
          -half*zblob2-delta,temprad,dist1)
        if (dist1.lt.dist) then
         dist=dist1
        endif 
       else if (probtype.eq.50) then
        xmin=-50.0
        xmax=half*twall
        ymin=-50.0
        ymax=50.0
        zmin=-50.0
        zmax=3.8
        zz=yblob
        call cubedist(xmin,xmax,ymin,ymax,zmin,zmax, &
                      x,zz,y,dist)
        dist=-dist

        xmin=-50.0
        xmax=50.0
        ymin=-50.0
        ymax=50.0
        zmin=-50.0
        zmax=0.2
        call cubedist(xmin,xmax,ymin,ymax,zmin,zmax, &
                      x,zz,y,dist1)
        dist1=-dist1

        if (dist1.gt.dist) then
         dist=dist1
        endif

       else if (probtype.eq.52) then
        dist=zblob2-y
       else if (probtype.eq.56) then
        dist=zblob2-y
       else if (probtype.eq.66) then
        call pulseheight(x,zero,dist)
        dist=dist-y
       else if (probtype.eq.38) then
        dist=yblob+radblob*cos(two*Pi*x/xblob)-y
! 2d: vapordist
       else if (probtype.eq.26) then
        if (axis_dir.eq.1) then
         dist=abs(y-half)-one/four
        else if (axis_dir.eq.0) then
         ! do nothing
        else if (axis_dir.eq.2) then ! inputs.vortex_confine
         ! do nothing
        else if (axis_dir.eq.3) then
         dist=sqrt((x-xblob)**2+(y-yblob)**2)-radblob
        else if (axis_dir.eq.10) then ! inputs.BCG
         ! do nothing
        else if (axis_dir.eq.11) then ! inputs.BCG_periodic
         ! do nothing
        else
         print *,"axis_dir 0, 1,2,3,10, or 11 expected"
         stop
        endif
! natural convection in triangular enclosure
       else if (probtype.eq.81) then
        dist=yblob2-y
! rotating annulus (vapordist 2D)
       else if (probtype.eq.82) then
        dist=hugedist
       else if (probtype.eq.110) then
!       dist=yblob-y
        call local_shallow_water_elevation(initial_time,x,dist)
        dist=dist-y
       endif

      else if (SDIM.eq.3) then

       if (probtype.eq.540) then ! Rieber simulation vapordist 3D
        dist=radblob-sqrt((x-xblob)**2 + (y-yblob)**2 + (z-zblob)**2)

        if (radblob2.ne.zero) then
         if (radblob3.ne.zero) then
          print *,"cannot have both radblob2 and radblob3 <>0"
          stop
         endif
         dist2=radblob2-z
         if (dist2.gt.dist) then
          dist=dist2
         endif
        endif
       else if (probtype.eq.5501) then  ! rough surface problem.
        if (axis_dir.ne.0) then
         print *,"axis_dir invalid"
         stop
        endif
        dist=radblob-sqrt( (x-xblob)**2 + (y-yblob)**2 + (z-zblob)**2 )

       else if (probtype.eq.4) then
        dist=sqrt((x-(xblob+0.5))**2+(y-yblob)**2+(z-zblob)**2 )-radblob
        dist1=sqrt((x-(xblob-0.5))**2+(y-yblob)**2+(z-(zblob+2.3))**2)- &
            radblob
        if (dist.gt.dist1) then
         dist=dist1
        endif
       else if (probtype.eq.5) then
        dist=sqrt((x-(xblob+radblob/two))**2+(y-yblob)**2+(z-zblob)**2)- &
           one
        dist1=sqrt((x-(xblob-radblob/two))**2+(y-yblob)**2+(z-zblob)**2)- &
           one
        if (dist.gt.dist1) then
         dist=dist1
        endif
       else if (probtype.eq.603) then  ! Benard advection (vapordist)
        dist=zblob-z
       else if (probtype.eq.28) then ! prescribed velocity 3D
        if (axis_dir.eq.2) then
         dist=sqrt( (x-xblob)**2 + (y-yblob)**2 + (z-zblob)**2 )-radblob
        else
         print *,"axis_dir invalid"
         stop
        endif
       else if (probtype.eq.29) then ! 3d deformation, vapordist
        dist=sqrt( (x-xblob)**2 + (y-yblob)**2 + (z-zblob)**2 )-radblob
       else if (probtype.eq.31) then ! vapordist: translating sphere
        dist=sqrt( (x-xblob)**2 + (y-yblob)**2 + (z-zblob)**2 ) - radblob
       else if (probtype.eq.101) then
        call cubedist(xblob-radblob,xblob+radblob,yblob-radblob,yblob+radblob, &
         zblob-radblob,zblob+radblob,x,y,z,dist)
       else if ((probtype.eq.1).and.(axis_dir.le.10)) then ! vapordist 3d
        dist=sqrt( (x-xblob)**2 + (y-yblob)**2 + (z-zblob)**2 )-radblob
       else if ((probtype.eq.1).and.(axis_dir.eq.11)) then ! vapordist 3d
        dist=sqrt( (x-xblob)**2 + (y-yblob)**2 + (z-zblob)**2 )-radblob
       else if ((probtype.eq.1).and.(axis_dir.eq.13)) then ! vapordist 3d
        ! dist<0 in the blobs.
        call blob_array_dist(x,y,z,dist)
       else if ((probtype.eq.1).and.(axis_dir.eq.12)) then
        dist=-sqrt( (x-xblob)**2 + (y-yblob)**2 + (z-zblob)**2 )+radblob
       else if (probtype.eq.35) then
        dist=half*zblob-z 
       else if (probtype.eq.2) then
        dist=sqrt((x-xblob)**2+(y-yblob)**2+(z-zblob)**2)-radblob
       else if (probtype.eq.201) then  ! vapordist stratified 3D
        dist=sqrt((x-xblob)**2+(y-yblob)**2+(z-zblob)**2)-radblob
       else if (probtype.eq.390) then ! dumbbell shape (vapordist)
        call dumbbelldist(x,y,z,xblob,yblob,zblob, &
          radblob,zblob2,radblob2,dist)
       else if (probtype.eq.36) then ! vapordist 3D

        call spheredist(x,y,z,dist)  ! dist < 0 in the sphere

        if ((probtype.eq.36).and.(axis_dir.eq.100)) then
         dist=-dist
        endif

        if ((probtype.eq.36).and.(axis_dir.eq.200)) then
         dist=sqrt((y-yblob)**2+(z-zblob)**2)-radblob
        else if ((probtype.eq.36).and.(axis_dir.eq.201)) then
         dist=sqrt((x-xblob)**2+(z-zblob)**2)-radblob
        else if ((probtype.eq.36).and.(axis_dir.eq.202)) then
         dist=sqrt((x-xblob)**2+(y-yblob)**2)-radblob
        endif

        if ((probtype.eq.36).and.(axis_dir.eq.210)) then
         dist=(z+radblob*(x-xblob)+radblob2*(y-yblob)-zblob)/ &
              sqrt(one+radblob**2+radblob2**2)
        endif

        if ((probtype.eq.36).and.(zblob10.gt.zblob)) then
         dist2=zblob10-z
         if (dist2.lt.dist) then
          dist=dist2
         endif
        endif 

       else if (probtype.eq.42) then  ! vapordist 3D
        dist=sqrt((x-xblob)**2+(y-yblob)**2+(z-zblob)**2)-radblob
! zblob2 (3d)  zblob (2d)
        dist1=zblob2+zblob-z
        if (dist1.lt.dist) then
         dist=dist1
        endif
       else if (probtype.eq.46) then
        print *,"vapordist 3D: this problem not ready in 3d"
        stop
       else if (probtype.eq.37) then
        dist=radblob-sqrt( (x-xblob)**2 + (y-yblob)**2 + (z-zblob)**2 )
       else if (probtype.eq.9) then  ! ship wave free surface (vapordist) 3D
        call boatdist(x,y,z,dist)
!
! ysl 05/12/14  ! calculate dist(2): the vapor distance to its nearest boundary
!
       else if ((probtype.eq.17).or.(probtype.eq.18)) then
        if ((xblob.ne.zero).or.(yblob.ne.zero).or. &
            (radblob.ne.half)) then
         print *,"set xblob=yblob=0 radblob=1/2 drop collide"
         stop
        endif
        if (probtype.eq.18) then
         drat=one
        else
         drat=fort_denconst(3)/fort_denconst(1)  ! dentop/denbot
        endif
        veltop=-one/(drat+one)
        velbot=drat/(drat+one)
        ytop=yblob+1.25*radblob
        ybot=yblob-radblob+(ytop-yblob-radblob)*velbot/veltop

        dist = radblob- &
         sqrt((x-xblob)**2+(y-ytop)**2+(z-zblob)**2)  ! water (3)
        dist1 = radblob- &
         sqrt((x-xblob)**2+(y-ybot)**2+(z-zblob)**2) ! oil (1)
! to dist is the nearest distance to a neighbouring fluid
        if (dist1.gt.dist) then
         dist=dist1
        endif

       else if (probtype.eq.13) then
        print *,"this option obsolete"
        stop
       else if (probtype.eq.14) then
        print *,"this option obsolete"
        stop
       else if (probtype.eq.50) then
        xmin=-50.0
        xmax=twall
        ymin=yblob-radblob
        ymax=yblob+radblob
        zmin=zblob-radblob
        zmax=zblob+radblob
        call cubedist(xmin,xmax,ymin,ymax,zmin,zmax, &
                      x,y,z,dist)
        dist=-dist

        xmin=-50.0
        xmax=50.0
        ymin=-50.0
        ymax=50.0
        zmin=-50.0
        zmax=zblob2
        call cubedist(xmin,xmax,ymin,ymax,zmin,zmax, &
                      x,y,z,dist1)
        dist1=-dist1

        if (dist1.gt.dist) then
         dist=dist1
        endif

       else if (probtype.eq.51) then
        print *,"option obsolete"
        stop
       else if (probtype.eq.52) then
        print *,"option obsolete"
        stop
! vapor level set for gear test problem. (denliquid,visunburn)
! one can have a pool of liquid and/or an incoming jet.
       else if (probtype.eq.563) then
        if (levelrz.eq.0) then
         dist=zblob2-z
         if (radblob.gt.zero) then
          call cylinderdist(y,z,x,yblob,zblob,radblob,xblob-radblob, &
           xblob+radblob,dist2)
          dist2=-dist2
          if (dist2.gt.dist) then
           dist=dist2
          endif
         endif 
        else 
         print *,"levelrz invalid vapordist"
         stop
        endif
       else if ((probtype.eq.56).or.(probtype.eq.562)) then
        dist=zblob2-z
! dog
       else if (probtype.eq.5600) then
        dist=zblob2-z
! vessel (viorel sphere)
       else if (probtype.eq.5601) then
        dist=zblob2-z
       else if (probtype.eq.5602) then ! internal inflow
        dist=zblob2-z
! microfluidics channel -- 0,3,4 Roper, 1 Comsol, 2,5 squeeze vapordist
       else if (probtype.eq.5700) then
        if (axis_dir.eq.2) then
         print *,"axis_dir=2 obsolete"
         stop
        else if (axis_dir.eq.5) then
         dist=y-yblob
        else if ((axis_dir.eq.0).or.(axis_dir.eq.1).or. &
                 (axis_dir.eq.3).or.(axis_dir.eq.4)) then
         dist=y-yblob
         if (xblob4.gt.zero) then
          if (x.ge.xblob4) then  ! oil initially in the curly cue channel
           dist=-99999.0
          endif
         endif
        else
         print *,"axis_dir invalid"
         stop
        endif
       else if (probtype.eq.57) then
        dist=zblob2-z
       else if (probtype.eq.58) then
        dist=zblob2-z
       else if (probtype.eq.529) then ! airblast with coaxial injection
        call get_jet_dist(x,y,z,nmat,distbatch)
        dist=distbatch(1)
         ! 3D jetbend problem
       else if (probtype.eq.53) then ! JICF (vapordist)
        call get_jet_dist(x,y,z,nmat,distbatch)
        dist=distbatch(1)
       else if (probtype.eq.530) then ! impinge (vapordist)
        call get_jet_dist(x,y,z,nmat,distbatch)
        dist=distbatch(1)
        ! 3d diesel injector w/needle (vapordist)
       else if ((probtype.eq.538).or. &  ! inputs.injA
                (probtype.eq.541)) then
        call get_jet_dist(x,y,z,nmat,distbatch)
        dist=distbatch(1)
       else if (probtype.eq.701) then ! flapping wing (vapordist 3D)
        dist=zblob-z
       else if (probtype.eq.532) then ! impinge from sides (vapordist)
        call get_jet_dist(x,y,z,nmat,distbatch)
        dist=distbatch(1)
       else if (probtype.eq.536) then
        zmin=zblob-1.0e+10
        zmax=zblob+1.3
        radblob2=0.85
        call cylinderdist(x,y,z,xblob,yblob,radblob2,zmin,zmax,dist)
        dist=-dist
       else if (probtype.eq.41) then ! pipe vapordist 3D
        call inletpipedist(x,y,z,nmat,distbatch) 
        dist=distbatch(1)
       else if (probtype.eq.54) then
        zmin=-1.0e+10
        zmax=zblob+zblob/four
        call cylinderdist(x,y,z,xblob,yblob,radblob,zmin,zmax,dist)
        dist=-dist
       else if (probtype.eq.62) then
        dist=zblob3-z
        costheta=cos(xblob2)
        sintheta=sin(xblob2)
        xprime=costheta*(x-xblob)-sintheta*(z-zblob)
        yprime=y-yblob
        zprime=sintheta*(x-xblob)+costheta*(z-zblob)
        delta=half*(radblob2-radblob)
        temprad=1.0D+10
        call cylinderdist(xprime,yprime,zprime,zero,zero,radblob+delta, &
          -half*zblob2-delta,temprad,dist1) 
        if (dist1.lt.dist) then
         dist=dist1
        endif 
       else if (probtype.eq.63) then
         if (z.ge.two*xblob10) then
          dist=half*xblob10-sqrt(x**2+y**2)
         else
          dist=half*xblob10-sqrt(x**2+y**2)+(two*xblob10-z)
         endif
       else if (probtype.eq.44) then
        call damdist(x,z,dist,igeom)
       else if (probtype.eq.65) then
        dist=zblob3-z
        costheta=cos(xblob2)
        sintheta=sin(xblob2)
        xprime=costheta*(x-xblob)-sintheta*(z-zblob)
        yprime=y-yblob
        zprime=sintheta*(x-xblob)+costheta*(z-zblob)
        delta=half*(radblob2-radblob)
        temprad=1.0D+10
        call tcylinderdist(xprime,yprime,zprime,zero,zero,radblob+delta, &
          -half*zblob2-delta,temprad,dist1) 
        dist1 = -dist1
        if ((dist1.gt.dist).and.(z > zblob3)) then
         dist=dist1
        endif 
       else if (probtype.eq.66) then
        xprime=sqrt(three*radblob/(four*zblob*zblob*zblob))
        dist=zblob+radblob/(cosh(x*xprime)**2)-z
       else if (probtype.eq.61) then
        dist=-(sqrt((x-xblob)**2+(y-yblob)**2+(z-zblob)**2) - radblob)
        dist1=-(3 + (z-zblob))
        if (axis_dir.eq.2) then
         dist1=-(z-zblob2) 
        endif
        if (dist1.gt.dist) then
         dist=dist1
        endif
       else if (probtype.eq.26) then ! 3D: vapordist
! x-y plane
        if (axis_dir.eq.3) then
         dist=abs(y-half)-one/four
! x-z plane
        else if (axis_dir.eq.2) then
         dist=abs(z-half)-one/four
! y-z plane
        else if (axis_dir.eq.1) then
         dist=abs(z-half)-one/four
        else if (axis_dir.eq.0) then
         ! do nothing
        else if (axis_dir.eq.4) then
         ! do nothing
        else if (axis_dir.eq.5) then
         dist=sqrt((x-xblob)**2+(y-yblob)**2+(z-zblob)**2)-radblob
        else if (axis_dir.eq.11) then
         ! do nothing
        else
         print *,"axis_dir 0,1,2,3,4,5, or 11 expected"
         stop
        endif
! rotating annulus (vapordist 3D)
       else if (probtype.eq.82) then
        dist=hugedist
       endif

      else
       print *,"dimension bust"
       stop
      endif

      return
      end subroutine vapordist


! negative on the inside of the triangle!
      subroutine triangledist(x,y,xlo,xhi,ylo,yhi,dist)
      IMPLICIT NONE

      REAL_T x,y,xlo,xhi,ylo,yhi,dist,dist1,dist2,dist3
      REAL_T m,b

      if ((xlo.ge.xhi-1.0D-10).or.(ylo.ge.yhi-1.0D-10)) then 
       print *,"invalid parameters triangle dist",xlo,xhi,ylo,yhi
       stop
      endif
      dist1=xlo-x
      dist2=ylo-y
      m=(yhi-ylo)/(xlo-xhi)
      b=yhi-m*xlo
      dist3=y-(m*x+b)
      dist=dist1
      if (dist2.gt.dist) then
       dist=dist2
      endif
      if (dist3.gt.dist) then
       dist=dist3
      endif
  
      return
      end subroutine triangledist

! negative on the inside of the polygon!
      subroutine polygondist(x,y,xlo,xhi,ylo,yhi,xwid,ywid,dist)
      IMPLICIT NONE

      REAL_T x,y,xlo,xhi,ylo,yhi,xwid,ywid,dist,dist1,dist2,dist3
      REAL_T dist4,dist5
      REAL_T m,b

      if ((xlo.ge.xhi-1.0D-10).or.(ylo.ge.yhi-1.0D-10)) then 
       print *,"invalid parameters triangle dist",xlo,xhi,ylo,yhi
       stop
      endif
      dist1=xlo-xwid-x
      dist2=ylo-ywid-y
      m=(yhi-ylo)/(xlo-xhi)
      b=yhi-m*xlo
      dist3=y-(m*x+b)
      dist4=y-yhi
      dist5=x-xhi
      dist=dist1
      if (dist2.gt.dist) then
       dist=dist2
      endif
      if (dist3.gt.dist) then
       dist=dist3
      endif
      if (dist4.gt.dist) then
       dist=dist4
      endif
      if (dist5.gt.dist) then
       dist=dist5
      endif
  
      return
      end subroutine polygondist



      subroutine airgunsolid(x,y,xcen,ycen,xhole,yhole, &
                             height,width,gunthick,dist)
      use global_utility_module
      use global_distance_module

      IMPLICIT NONE

!        width/2
! ____    ____  
!  ___|  |__  |  
!  |        | | height/2
! _|        |_|          
! _          _  2yhole
!  |        | | 
!  |__    __| |
!  ___|  |____| gunthick  
!     2xhole
! Negative on the inside of the L-shaped solids!
! The subroutine below is intended to take advantage
! of axisymmetry so we only draw the right portion.
!
      REAL_T x,y,xcen,ycen,xhole,yhole
      REAL_T dist
      REAL_T height,width,gunthick
      REAL_T xlo1,xhi1,ylo1,yhi1
      REAL_T xlo2,xhi2,ylo2,yhi2
      REAL_T xlo3,xhi3,ylo3,yhi3
      REAL_T xlo4,xhi4,ylo4,yhi4
      
      if ( (xhole.lt.zero).or.(yhole.lt.zero).or. &
          (height.le.zero).or.(width.le.zero).or. &
          (gunthick.le.zero) ) then 
       print *,"These parameters must be positive ",xhole, &
                yhole,height,width,gunthick
       stop
      endif
! bottom horizontal rectangle
      xlo1=xcen+xhole
      xhi1=xcen+xhole+half*width
      ylo1=ycen-half*height-yhole
      yhi1=ycen-half*height-yhole+gunthick
! top horizontal rectangle
      xlo2=xcen+xhole
      xhi2=xcen+xhole+half*width
      ylo2=ycen+half*height+yhole-gunthick
      yhi2=ycen+half*height+yhole
! bottom-right vertical rectangle
      xlo3=xcen+xhole+half*width-gunthick
      xhi3=xcen+xhole+half*width
      ylo3=ycen-half*height-yhole+gunthick
      yhi3=ycen-yhole
! top-right vertical rectangle
      xlo4=xcen+xhole+half*width-gunthick
      xhi4=xcen+xhole+half*width
      ylo4=ycen+yhole
      yhi4=ycen+half*height+yhole-gunthick
      
      if (y.le.yhi1) then
       call squaredist(x,y,xlo1,xhi1,ylo1,yhi1,dist)       
      endif
      if (y.gt.ylo2) then 
       call squaredist(x,y,xlo2,xhi2,ylo2,yhi2,dist)       
      endif
      if ((y.ge.ylo3).and.(y.le.(yhi3+yhole))) then
       call squaredist(x,y,xlo3,xhi3,ylo3,yhi3,dist)          
      endif
      if ((y.le.yhi4).and.(y.ge.(ylo4-yhole))) then
       call squaredist(x,y,xlo4,xhi4,ylo4,yhi4,dist)       
      endif
      
      return
      end subroutine



! dist>0 inside of gap
      subroutine gapdist(x,y,xcen,gap,ymin,ymax,tana,dist)
      IMPLICIT NONE


      REAL_T x,y,xcen,gap,dist
      REAL_T ymin,ymax,tana ! tangent of direction angle

      if (ymin.ge.ymax-1.0E-10) then
       print *,"invalid parameters ",ymin,ymax
       stop
      endif
      dist=abs(x-xcen-tana*(y-ymin))-gap
      if (y.ge.ymax) then
       if (dist.le.zero) then
        dist=y-ymax
       else
        dist=sqrt(dist**2+(y-ymax)**2)
       endif
      else if (y.le.ymin) then
       if (dist.le.zero) then
        dist=ymin-y
       else
        dist=sqrt(dist**2+(ymin-y)**2)
       endif
      endif

      return
      end subroutine





! dist>0 inside of droplet
      subroutine legenddist(x,y,dist)
      IMPLICIT NONE

      REAL_T x,y,dist,mag,costheta,sintheta
      REAL_T cos2theta,sin2theta

      mag=sqrt((x-xblob)**2+(y-yblob)**2)
      if (mag.lt.1.0D-5) then
       dist=radblob+zblob
      else
       costheta=(y-yblob)/mag
       sintheta=(x-xblob)/mag
       cos2theta=costheta**2-sintheta**2
       sin2theta=two*costheta*sintheta
       if (levelrz.eq.0) then
        dist=radblob+zblob*(two*(costheta**2)-one)/two - mag
       else if (levelrz.eq.1) then 
        dist=radblob+zblob*(three*(costheta**2)-one)/two - mag
!       dist=radblob+zblob*(three*(cos2theta**2)-one)/two - mag
       else
        print *,"levelrz invalid legenddist"
        stop
       endif
      endif

      return
      end subroutine

! dist>0 inside of the ellipse
      subroutine ellipsedist(x,y,a,b,xc,yc,dist)
      IMPLICIT NONE

      REAL_T x,y,a,b,xc,yc,dist
      REAL_T xprime,yprime,xcritical,ycritical
      REAL_T factor

      xprime=x-xc
      yprime=y-yc
      if (xprime.lt.zero) then
       xprime=-xprime
      endif
      if (yprime.lt.zero) then
       yprime=-yprime
      endif
      if ((xprime.eq.zero).and.(yprime.eq.zero)) then
       dist=a
       if (dist.gt.b) then
        dist=b
       endif
      else if (xprime.gt.yprime) then
       factor=one/a**2 + (yprime/(xprime*b))**2
       xcritical=one/sqrt(factor)
       ycritical=yprime*xcritical/xprime
      else 
       factor=one/b**2 + (xprime/(yprime*a))**2
       ycritical=one/sqrt(factor)
       xcritical=xprime*ycritical/yprime
      endif
      dist=sqrt(xcritical**2+ycritical**2)- &
           sqrt(xprime**2+yprime**2)

      return
      end subroutine
     
      subroutine get_bump_dist(x,y,z,nmat,dist,time)
      use global_utility_module
      use global_distance_module

      IMPLICIT NONE

      INTEGER_T nmat
      REAL_T dist(nmat)
      REAL_T x,y,z,time
      REAL_T distsolid
      REAL_T distleft,distright
      REAL_T xleft,xright,elev
      INTEGER_T im_solid_bump

      im_solid_bump=im_solid_primary()

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif
      if ((im_solid_bump.lt.1).or. &
          (im_solid_bump.gt.nmat)) then
       print *,"im_solid_bump invalid in get_bump_dist"
       stop
      endif
      if (probtype.ne.110) then
       print *,"probtype invalid"
       stop
      endif
      if ((SDIM.eq.2).and.(abs(z-y).gt.VOFTOL)) then
       print *,"z <> y in get_bump_dist"
       stop
      endif

      xleft=-594.36
      xright=502.92
      call get_left_elevationIOWA(time,distleft)
      call get_right_elevationIOWA(time,distright)
      call local_shallow_water_elevation(time,x,elev)
      dist(1)=elev-y
      dist(2)=-dist(1)

        ! pos in solid (get_bump_dist)
      call materialdistsolid(x,y,z,distsolid,time,im_solid_bump)
      dist(im_solid_bump)=distsolid

      return
      end subroutine get_bump_dist


 
      subroutine get_bump_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,time,nmat)
      use geometry_intersect_module
      IMPLICIT NONE

      INTEGER_T nmat,bfact,nhalf
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T xsten2(-1:1,SDIM)

      REAL_T time
      INTEGER_T im
      REAL_T dx(SDIM)
      REAL_T vfrac(nmat)
      REAL_T cenbc(nmat,SDIM)

      INTEGER_T dir2,i1,j1,k1,k1lo,k1hi,isten
      REAL_T centroid(nmat,SDIM)
      REAL_T areacentroid(nmat,SDIM)
      REAL_T lsgrid(D_DECL(3,3,3),nmat)
      REAL_T facearea(nmat)
      REAL_T distbatch(nmat)
      REAL_T EBVOFTOL
      INTEGER_T nhalf2

      nhalf2=1
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (nhalf.lt.3) then
       print *,"nhalf invalid get bump vfrac"
       stop
      endif


      if (probtype.ne.110) then
       print *,"probtype invalid"
       stop
      endif

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      if (SDIM.eq.2) then
       k1lo=0
       k1hi=0
      else if (SDIM.eq.3) then
       k1lo=-1
       k1hi=1
      else
       print *,"dimension bust"
       stop
      endif

      do i1=-1,1
      do j1=-1,1
      do k1=k1lo,k1hi
       do isten=-1,1
        dir2=1
        xsten2(isten,dir2)=xsten(isten+2*i1,dir2)
        dir2=2
        xsten2(isten,dir2)=xsten(isten+2*j1,dir2)
        if (SDIM.eq.3) then
         dir2=SDIM
         xsten2(isten,dir2)=xsten(isten+2*k1,dir2)
        endif
       enddo ! isten

       call get_bump_dist(xsten2(0,1),xsten2(0,2), &
        xsten2(0,SDIM),nmat,distbatch,time)
       do im=1,nmat
        lsgrid(D_DECL(i1+2,j1+2,k1+2),im)=distbatch(im) 
       enddo
 
      enddo
      enddo
      enddo

      EBVOFTOL=VOFTOL
      call getvolumebatch(bfact,dx,xsten,nhalf, &
        lsgrid,vfrac, &
        facearea,centroid,areacentroid,nmat,EBVOFTOL,SDIM)

      do im=1,nmat
       do dir2=1,SDIM
        cenbc(im,dir2)=centroid(im,dir2)-xsten(0,dir2)
       enddo
      enddo

      return
      end subroutine get_bump_vfrac


      subroutine get_bump_velocity(xsten,nhalf,dx,bfact,vel,time)
      IMPLICIT NONE

      INTEGER_T nhalf,bfact
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T time
      REAL_T dx(SDIM)
      REAL_T vel

      REAL_T VOF(num_materials)
      REAL_T cenbc(num_materials,SDIM)
      INTEGER_T nmat
      REAL_T xleft,xright
      REAL_T velleft,velright

      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (nhalf.lt.3) then
       print *,"nhalf invalid get bump velocity"
       stop
      endif
      nmat=num_materials

      if (probtype.ne.110) then
       print *,"probtype invalid"
       stop
      endif

      xleft=-594.36
      xright=502.92
      call get_left_velocityIOWA(time,velleft)
      call get_right_velocityIOWA(time,velright)

      call get_bump_vfrac(xsten,nhalf,dx,bfact,VOF,cenbc,time,nmat)  

      if (VOF(1).gt.zero) then

       call local_shallow_water_velocity(time,xsten(0,1),vel)

      else
       vel=zero
      endif

      return
      end subroutine get_bump_velocity

      subroutine mask_velocity(xsten,nhalf,dx,bfact,velcell,time,nmat)
      use global_utility_module

      IMPLICIT NONE

      INTEGER_T nhalf,bfact
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T time
      REAL_T dx(SDIM)
      REAL_T velcell(SDIM)
      INTEGER_T nmat

      REAL_T VOF(nmat)
      REAL_T cenbc(nmat,SDIM)
      INTEGER_T im

      if (nhalf.lt.3) then
       print *,"nhalf invalid mask velocity"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      call get_initial_vfrac(xsten,nhalf,dx,bfact,VOF,cenbc,nmat)

      do im=1,nmat
       if (is_prescribed(nmat,im).eq.1) then
        if (is_rigid(nmat,im).eq.1) then
         if (VOF(im).gt.zero) then
          call velsolid(xsten(0,1),xsten(0,2),xsten(0,SDIM),velcell,time,im,dx)
         endif
        else
         print *,"is_rigid(nmat,im) invalid"
         stop
        endif
       else if (is_prescribed(nmat,im).eq.0) then
        ! do nothing
       else
        print *,"is_prescribed invalid"
        stop
       endif
      enddo ! im=1..nmat

      return
      end subroutine mask_velocity

      subroutine normal_FILL(time,x,dir,side,normal,iten,nten)
      use global_utility_module
      IMPLICIT NONE

      INTEGER_T dir,side,iten,nten
      REAL_T time
      REAL_T normal(SDIM)
      REAL_T x(SDIM)
      INTEGER_T nmat
      REAL_T RR,mag

      nmat=num_materials
      if (nten.ne.((nmat-1)*(nmat-1)+nmat-1)/2) then
       print *,"nten invalid"
       stop
      endif
      if ((iten.lt.1).or.(iten.gt.nten)) then
       print *,"iten invalid"
       stop
      endif
      if ((dir.lt.0).or.(dir.gt.SDIM-1)) then
       print *,"dir invalid"
       stop
      endif
      if ((side.ne.1).and.(side.ne.2)) then
       print *,"side invalid"
       stop
      endif
      if ((probtype.eq.36).and.(axis_dir.eq.210)) then
       if (SDIM.eq.2) then
        normal(1)=radblob
        normal(2)=one
       else if (SDIM.eq.3) then
        normal(1)=radblob
        normal(2)=radblob2
        normal(SDIM)=one
       else
        print *,"dimension bust"
        stop
       endif
       RR=x(1)
       call prepare_normal(normal,RR,mag)
      endif

      return
      end subroutine normal_FILL

   
      subroutine mofBC(time,dir,side,VOF,VOFwall, &
       xsten,nhalf,dx,bfact,im)
      IMPLICIT NONE

      INTEGER_T dir,side,im,bfact,nhalf
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T time,VOF,xwall,VOFwall,x,y,z
      REAL_T dx(SDIM)

      if (nhalf.lt.1) then
       print *,"nhalf invalid mofbc"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)
      if (dir.eq.1) then
       if (side.eq.1) then
        xwall=problox
       else
        xwall=probhix
       endif
      else if (dir.eq.2) then
       if (side.eq.1) then
        xwall=probloy
       else
        xwall=probhiy
       endif
      else if ((dir.eq.3).and.(SDIM.eq.3)) then
       if (side.eq.1) then
        xwall=probloz
       else
        xwall=probhiz
       endif
      else
       print *,"dir invalid mofbc"
       stop
      endif

      if ((im.lt.0).or.(im.ge.num_materials)) then
       print *,"im invalid77"
       stop
      endif
      if ((dir.eq.1).and.(side.eq.1)) then
       if (xwall.lt.x) then
        print *,"xwall,x invalid"
        stop
       endif
       VOF=VOFwall
      else if ((dir.eq.1).and.(side.eq.2)) then
       if (xwall.gt.x) then
        print *,"xwall,x invalid"
        stop
       endif
       VOF=VOFwall
      else if ((dir.eq.2).and.(side.eq.1)) then
       if (xwall.lt.y) then
        print *,"xwall,y invalid"
        stop
       endif
       VOF=VOFwall
      else if ((dir.eq.2).and.(side.eq.2)) then
       if (xwall.gt.y) then
        print *,"xwall,y invalid"
        stop
       endif
       VOF=VOFwall
      else if ((dir.eq.3).and.(side.eq.1)) then
       if (xwall.lt.z) then
        print *,"xwall,z invalid"
        stop
       endif
       VOF=VOFwall
      else if ((dir.eq.3).and.(side.eq.2)) then
       if (xwall.gt.z) then
        print *,"xwall,z invalid"
        stop
       endif
       VOF=VOFwall
      else
       print *,"dir side invalid"
       stop
      endif

      return
      end subroutine mofBC

      subroutine copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
      IMPLICIT NONE

      INTEGER_T nmat
      REAL_T VOF(nmat*ngeom_raw)
      REAL_T VOFwall(nmat*ngeom_raw)
      REAL_T cenbc(nmat,SDIM)
      REAL_T vofarray(nmat)
      INTEGER_T im,vofcomp,dir2

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      do im=1,nmat
       vofcomp=(im-1)*(ngeom_raw)+1
       if ((FSI_flag(im).eq.0).or. & ! fluid
           (FSI_flag(im).eq.1).or. & ! prescribed solid - (EUL)
           (FSI_flag(im).eq.3).or. & ! ice
           (FSI_flag(im).eq.5)) then ! FSI rigid solid (EUL)
        VOF(vofcomp)=vofarray(im)
        do dir2=1,SDIM
         VOF(vofcomp+dir2)=cenbc(im,dir2)
        enddo
       else if ((FSI_flag(im).eq.2).or. & ! prescribed solid CAD
                (FSI_flag(im).eq.6).or. & ! ice - from CAD
                (FSI_flag(im).eq.7).or. & ! fluid - from CAD
                (FSI_flag(im).eq.4)) then ! CTML FSI
        VOF(vofcomp)=VOFwall(vofcomp)
        do dir2=1,SDIM
         VOF(vofcomp+dir2)=VOFwall(vofcomp+dir2)
        enddo
       else
        print *,"FSI_flag invalid"
        stop
       endif
      enddo ! im=1..nmat

      return
      end subroutine copy_mofbc_to_result

      subroutine check_lsbc_extrap(LS,LSwall,nmat)
      IMPLICIT NONE

      INTEGER_T nmat
      REAL_T LS(nmat)
      REAL_T LSwall(nmat)
      INTEGER_T im

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      do im=1,nmat
       if ((FSI_flag(im).eq.0).or. & ! fluid
           (FSI_flag(im).eq.1).or. & ! prescribed solid - (EUL)
           (FSI_flag(im).eq.3).or. & ! ice
           (FSI_flag(im).eq.5)) then ! FSI rigid solid (EUL)
        ! do nothing
       else if ((FSI_flag(im).eq.2).or. & ! prescribed solid CAD
                (FSI_flag(im).eq.6).or. & ! ice - from CAD
                (FSI_flag(im).eq.7).or. & ! fluid - from CAD
                (FSI_flag(im).eq.4)) then ! CTML FSI
        LS(im)=LSwall(im)
       else
        print *,"FSI_flag invalid"
        stop
       endif
      enddo ! im=1..nmat

      return
      end subroutine check_lsbc_extrap


! inflow, outflow, slipwall, noslipwall bcs have ext dir; i.e.
! this routine called for inflow, outflow, slipwall, noslipwall

      subroutine groupmofBC(time,dir,side,VOF,VOFwall, &
        xsten,nhalf,dx,bfact,nmat)
      use global_utility_module
      use randomNG
      use rainControl_module, only : get_rain_vfrac,get_rain_velocity
      use bubbleControl_module, only : get_pack_vfrac
      use hydrateReactor_module
      use unimaterialChannel_module
      use River
      IMPLICIT NONE

      INTEGER_T nmat,bfact,nhalf
      REAL_T xsten(-nhalf:nhalf,SDIM)
      INTEGER_T dir,side
      REAL_T VOF(nmat*ngeom_raw)
      REAL_T VOFwall(nmat*ngeom_raw)
      REAL_T time,xwall,x,y,z
      REAL_T dx(SDIM)
      REAL_T cenbc(nmat,SDIM)
      REAL_T LS
      REAL_T vofarray(nmat)
      INTEGER_T im
      INTEGER_T vofcomp
      INTEGER_T dir2

      REAL_T vof_sum_check
      INTEGER_T im_solid_mofbc

      im_solid_mofbc=im_solid_primary()

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif
      if (nhalf.lt.1) then
       print *,"nhalf invalid group mof bc"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)

      if (dir.eq.1) then
       if (side.eq.1) then
        xwall=problox
       else
        xwall=probhix
       endif
      else if (dir.eq.2) then
       if (side.eq.1) then
        xwall=probloy
       else
        xwall=probhiy
       endif
      else if ((dir.eq.3).and.(SDIM.eq.3)) then
       if (side.eq.1) then
        xwall=probloz
       else
        xwall=probhiz
       endif
      else
       print *,"dir invalid group mof bc 0"
       stop
      endif

      if ((dir.lt.1).or.(dir.gt.SDIM)) then
       print *,"dir invalid in group mof bc 1"
       stop
      endif

      do im=1,nmat*ngeom_raw
       VOF(im)=zero
      enddo

      vof_sum_check=zero

      do im=1,nmat
       vofcomp=(im-1)*ngeom_raw+1
       VOF(vofcomp)=VOFwall(vofcomp)
       do dir2=1,SDIM
        VOF(vofcomp+dir2)=VOFwall(vofcomp+dir2)
        cenbc(im,dir2)=zero
       enddo
       vofarray(im)=VOFwall(vofcomp)

       vof_sum_check=vof_sum_check+vofarray(im)
      enddo ! im=1..nmat

      if (vof_sum_check.lt.half) then
       print *,"vof_sum_check failed"
       print *,"vof_sum_check=",vof_sum_check
       print *,"time=",time
       print *,"dir,side ",dir,side
       print *,"xsten(0) ",xsten(0,1),xsten(0,2),xsten(0,SDIM)
       print *,"nhalf ",nhalf
       print *,"dx= ",dx(1),dx(2),dx(SDIM)
       print *,"bfact=",bfact
       print *,"nmat=",nmat
       stop
      endif

      if (is_in_probtype_list().eq.1) then
       call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
       call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)

      else if (probtype.eq.411) then
       call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
       call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)

      else if (probtype.eq.401) then
       call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
       call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)

      else if (probtype.eq.412) then
       call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
       call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)

      else if (probtype.eq.311) then ! user defined

       call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
       call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)

      else if (probtype.eq.199) then !hydrates (groupmofBC)
       print *,"this code must be upgrated"
       stop
       do im=1,nmat
        if ((FSI_flag(im).ne.2).and. &
            (FSI_flag(im).ne.4)) then
         vofcomp=(im-1)*ngeom_raw+1
         call HYD_VOLF_BC(time,dir,side,VOF(vofcomp), &
          xwall,VOFwall(vofcomp),x,y,z,dx,im)
         call HYD_MOMF_BC(time,dir,side,VOF(vofcomp+1), &
          xwall,VOFwall(vofcomp+1),x,y,z,dx,im)
        endif
       enddo ! im=1..nmat

       ! in: groupmofBC
      else if (probtype.eq.220) then !UNIMATERIAL problem

       do im=1,nmat-1
        vofcomp=(im-1)*ngeom_raw+1
        call UNIMAT_VOLF_BC(time,dir,side,VOF(vofcomp), &
         xwall,VOFwall(vofcomp),x,y,z,dx,im)
        call UNIMAT_MOMF_BC(time,dir,side,VOF(vofcomp+1), &
         xwall,VOFwall(vofcomp+1),x,y,z,dx,im)
       enddo

       im=nmat
       vofcomp=(im-1)*ngeom_raw+1
       if (FSI_flag(im).eq.4) then
        VOF(vofcomp)=zero
        do dir2=1,SDIM
         VOF(vofcomp+dir2)=zero
        enddo
       else
        print *,"expecting last material to be a CTML material"
        stop
       endif
        
      else if ((probtype.eq.299).or. &
               (probtype.eq.301)) then !melting (boundary conditions for F,X)
       call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
       call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
      else if (probtype.eq.209) then ! River
       call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
       call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        ! marangoni (heat pipe) problem
      else if ((probtype.eq.36).and.(axis_dir.eq.10)) then
       call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
       call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)

       ! sanity check: curvature for a plane should be 0
      else if ((probtype.eq.36).and.(axis_dir.eq.210)) then
       call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
       call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
      else
 
       if ((dir.eq.1).and.(side.eq.1)) then  ! xlo
        if (xwall.lt.x) then
         print *,"xwall,x invalid"
         stop
        endif

        if (SDIM.eq.2) then

        if (probtype.eq.58) then
         LS=yblob2-y
         if (LS.lt.zero) then
          vofarray(1)=zero
         else
          vofarray(1)=one
         endif
         vofarray(2)=one-vofarray(1)
         do im=3,nmat
          vofarray(im)=zero
         enddo
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.6) then
         vofarray(1)=zero
         vofarray(2)=one-vofarray(1)
         do im=3,nmat
          vofarray(im)=zero
         enddo
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.110) then
           ! xlo
         call get_bump_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,time,nmat) 
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if ((probtype.eq.59).or. &
                 (probtype.eq.710)) then  ! xlo dir=1 side=1 groupmofBC 2d
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
         ! xlo groupmofBC 2d
        else if ((probtype.eq.801).and.(axis_dir.eq.dir-1)) then 
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.802) then ! xlo - dissolution
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.5700) then ! xlo
         call get_microfluidic_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.9) then  ! xlo, groupmofBC, 2D
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.41) then
         call get_pipe_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)  ! xlo
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.532) then ! xlo
         call get_jet_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)   
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.539) then ! xlo, sup injector - groupmofBC
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.202) then ! xlo, liquidlens - groupmofbc
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.701) then  ! xlo dir=1 side=1 groupmofBC rain
         if ((axis_dir.eq.0).or. &
             (axis_dir.eq.1)) then
          call get_rain_vfrac(x,y,z,dx,vofarray,cenbc,time,nmat,dir,adv_vel)
          call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
         else if (axis_dir.eq.2) then
          do im=1,nmat
           if ((FSI_flag(im).ne.2).and. &
               (FSI_flag(im).ne.4)) then
            vofcomp=(im-1)*(ngeom_raw)+1
            if (im.eq.1) then
             VOF(vofcomp)=one
            else 
             VOF(vofcomp)=zero
            endif
            do dir2=1,SDIM
             VOF(vofcomp+dir2)=zero
            enddo
           endif
          enddo ! im=1..nmat
         else
          print *,"axis_dir invalid"
          stop
         endif
        endif

        else if (SDIM.eq.3) then

        if (probtype.eq.50) then
         vofarray(1)=one
         vofarray(2)=one-vofarray(1)
         do im=3,nmat
          vofarray(im)=zero
         enddo
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.58) then
         LS=zblob2-z
         if (LS.lt.zero) then
          vofarray(1)=zero
         else
          vofarray(1)=one
         endif
         vofarray(2)=one-vofarray(1)
         do im=3,nmat
          vofarray(im)=zero
         enddo
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.41) then ! xlo 3D
         call get_pipe_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)  ! xlo
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.5700) then ! xlo
         call get_microfluidic_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat) 
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
          ! airblast
        else if (probtype.eq.529) then  ! dir=1 side=1 groupmofBC
         call get_jet_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if ((probtype.eq.59).or. &
                 (probtype.eq.710)) then  ! xlo dir=1 side=1 groupmofBC 3d
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.5501) then  ! xlo, groupmofBC
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.9) then  ! xlo, groupmofBC, 3D
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        endif

        else
         print *,"dimension bust"
         stop
        endif

       else if ((dir.eq.1).and.(side.eq.2)) then  ! xhi
        if (xwall.gt.x) then
         print *,"xwall,x invalid"
         stop
        endif

        if (SDIM.eq.2) then

        if (probtype.eq.110) then
            ! xhi
         call get_bump_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,time,nmat)  
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if ((probtype.eq.59).or. &
                 (probtype.eq.710)) then  ! dir=1 side=2 (xhi) 2d
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)

         ! outflow or inflow=EXT_DIR; for microfluid channels, 
         ! want extrap bc either case.
         ! so this code is disabled
        else if ((probtype.eq.5700).and.(1.eq.0)) then ! xhi
         call get_microfluidic_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.9) then ! xhi, groupmofbc, 2D
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.41) then
         call get_pipe_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)  ! xhi
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.532) then ! xhi
         call get_jet_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat) 
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.539) then ! xhi, sup injector
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.202) then ! xhi, liquidlens, groupmofbc
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if ((probtype.eq.25).and.(axis_dir.gt.0)) then ! xhi, bubble frm.
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        endif

        else if (SDIM.eq.3) then

         ! outflow or inflow=EXT_DIR; for microfluid channels, 
         ! want extrap bc either case.
         ! so this code is disabled
        if ((probtype.eq.5700).and.(1.eq.0)) then ! xhi
         call get_microfluidic_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat) 
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if ((probtype.eq.59).or. &
                 (probtype.eq.710)) then  ! dir=1 side=2 (xhi) 3d groupmofBC
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.5501) then  ! xhi groupmofBC
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.9) then  ! xhi, groupmofBC, 3D
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        endif

        else 
         print *,"dimension bust"
         stop
        endif

       else if ((dir.eq.2).and.(side.eq.1)) then ! ylo
        if (xwall.lt.y) then
         print *,"xwall,y invalid"
         stop
        endif

        if (SDIM.eq.2) then

        if ((probtype.eq.25).and.(axis_dir.gt.0)) then  ! ylo2D bubble formation

         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)

         ! ylo dir=2 side=1 groupmofBC 
        else if(probtype.eq.bubbleInPackedColumn)then  
         call get_pack_vfrac(x,y,z,dx,vofarray,cenbc,time,nmat,dir)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
         ! ylo 2D groupmofBC
        else if ((probtype.eq.801).and.(axis_dir.eq.dir-1)) then 
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.5700) then  ! ylo 2D
         call get_microfluidic_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.41) then
         call get_pipe_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)  ! ylo
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.72) then
         if (abs(x-xblob).gt.radblob) then
          vofarray(1)=zero
         else
          vofarray(1)=one
         endif
         vofarray(2)=one-vofarray(1)
         do im=3,nmat
          vofarray(im)=zero
         enddo
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if ((probtype.eq.53).or.(probtype.eq.537)) then !ylo 2D,groupmofBC
         call get_jet_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat) 
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if ((probtype.eq.538).or. &
                 (probtype.eq.539).or. &
                 (probtype.eq.541)) then ! ylo 2D, diesel injector, groupmofBC

         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)

         ! 540 Rieber problem
         ! ylo dir=2 side=1 2d groupmofBC
        else if ((probtype.eq.59).or. &
                 (probtype.eq.710).or. &
                 (probtype.eq.540)) then  
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.9) then ! ylo, groupmofbc, 2D
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        endif

        else if (SDIM.eq.3) then

        if (probtype.eq.5700) then  ! ylo
         call get_microfluidic_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat) 
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if ((probtype.eq.59).or. &
                 (probtype.eq.710)) then  ! ylo dir=2 side=1 3d groupmofbc
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.5501) then  ! ylo groupmofBC
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.9) then  ! ylo, groupmofBC, 3D
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.532) then  ! impinge from side, ylo
         call get_jet_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        endif

        else
         print *,"dimension bust"
         stop
        endif

       else if ((dir.eq.2).and.(side.eq.2)) then ! yhi
        if (xwall.gt.y) then
         print *,"xwall,y invalid"
         stop
        endif

        if (SDIM.eq.2) then

        if (probtype.eq.62) then
         vofarray(1)=zero
         vofarray(2)=one
         do im=3,nmat
          vofarray(im)=zero
         enddo
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.5700) then ! yhi
         call get_microfluidic_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if ((probtype.eq.14).or.(probtype.eq.16).or. &
          ((probtype.eq.25).and.(axis_dir.eq.0)) ) then
         if (probtype.eq.25) then
          vofarray(1)=one
          vofarray(2)=zero
         else if (probtype.eq.16) then
          vofarray(1)=zero
          vofarray(2)=one
         endif
         do im=3,nmat
          vofarray(im)=zero
         enddo
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
         ! top (y=yhi)  y=ymax wall
        else if (probtype.eq.41) then
         call get_pipe_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat) 
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.540) then  ! Rieber problem y=yhi
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.539) then ! yhi, sup injector
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.9) then ! yhi, groupmofBC, 2D
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if ((probtype.eq.701).and.(1.eq.0)) then ! yhi, groupmofBC 2D
         call get_rain_vfrac(x,y,z,dx,vofarray,cenbc,time,nmat,dir,adv_vel)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        endif

        else if (SDIM.eq.3) then

        if (probtype.eq.5700) then ! yhi
         call get_microfluidic_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat) 
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.5501) then  ! yhi groupmofBC
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if ((probtype.eq.59).or. &
                 (probtype.eq.710)) then  ! yhi dir=2 side=2 3d groupmofBC
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.9) then ! yhi, groupmofBC, 3D
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.532) then  ! impinge from side, yhi
         call get_jet_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        endif

        else 
         print *,"dimension bust"
         stop
        endif

       else if ((dir.eq.3).and.(side.eq.1).and.(SDIM.eq.3)) then  ! zlo
        if (xwall.lt.z) then
         print *,"xwall,z invalid"
         stop
        endif

         ! called at inflow and outflow bc

        if ((probtype.eq.538).or. &  ! inputs.injA
            (probtype.eq.541)) then  ! zlo, diesel injector

         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)   
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
         
        else if ((probtype.eq.53).or.(probtype.eq.531).or. &  ! zlo 3D
                 (probtype.eq.530).or.(probtype.eq.536).or. &
                 (probtype.eq.537).or.(probtype.eq.532)) then
         call get_jet_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)   
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
         ! 540 Rieber problem
         ! zlo dir=3 side=1 groupmofBC (3D)
        else if ((probtype.eq.59).or. &
                 (probtype.eq.710).or. &
                 (probtype.eq.540)) then  
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.5501) then  ! zlo groupmofBC
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.9) then  ! zlo, groupmofBC
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.5700) then  ! microfluidics zlo
         do im=1,nmat
          vofarray(im)=zero
         enddo
         if ((im_solid_mofbc.le.0).or. &
             (im_solid_mofbc.gt.num_materials)) then
          print *,"im_solid_mofbc invalid 12"
          stop
         endif
         vofarray(im_solid_mofbc)=one
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        endif

       else if ((dir.eq.3).and.(side.eq.2).and.(SDIM.eq.3)) then ! zhi
        if (xwall.gt.z) then
         print *,"xwall,z invalid"
         stop
        endif
        if ((probtype.eq.62).or.(probtype.eq.65)) then
         vofarray(1)=zero
         vofarray(2)=one-vofarray(1)
         do im=3,nmat
          vofarray(im)=zero
         enddo
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.540) then  ! Rieber problem z=zhi
         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.9) then  ! zhi, groupmofBC

         call get_initial_vfrac(xsten,nhalf,dx,bfact,vofarray,cenbc,nmat)
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        else if (probtype.eq.5700) then  ! microfluidics zhi
         do im=1,nmat
          vofarray(im)=zero
         enddo
         if ((im_solid_mofbc.lt.1).or. &
             (im_solid_mofbc.gt.nmat)) then
          print *,"im_solid_mofbc invalid 13"
          stop
         endif
         vofarray(im_solid_mofbc)=one
         call copy_mofbc_to_result(VOF,vofarray,cenbc,VOFwall,nmat)
        endif

       else
        print *,"dir side invalid"
        stop
       endif

      endif ! non-hydrate materials

      return
      end subroutine groupmofBC


      subroutine lsBC(time,dir,side,VOF,VOFwall, &
        xsten,nhalf,dx,bfact,im)
      use hydrateReactor_module
      use unimaterialChannel_module
      use River

      IMPLICIT NONE

      INTEGER_T dir,side,im,nhalf,bfact
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T time,VOF,xwall,VOFwall,x,y,z
      REAL_T dx(SDIM)

      if (nhalf.lt.1) then
       print *,"nhalf invalid ls bc"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if ((im.lt.0).or.(im.ge.num_materials)) then
       print *,"im invalid78"
       stop
      endif
      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)

      if (dir.eq.1) then
       if (side.eq.1) then
        xwall=problox
       else
        xwall=probhix
       endif
      else if (dir.eq.2) then
       if (side.eq.1) then
        xwall=probloy
       else
        xwall=probhiy
       endif
      else if ((dir.eq.3).and.(SDIM.eq.3)) then
       if (side.eq.1) then
        xwall=probloz
       else
        xwall=probhiz
       endif
      else
       print *,"dir invalid lsbc"
       stop
      endif

      print *,"lsBC is a placeholder, call GROUP_LSFILL instead"
      print *,"GROUP_LSFILL calls grouplsBC"
      stop

      return
      end subroutine lsBC

! inflow, outflow, slipwall, noslipwall bcs have ext dir; i.e.
! this routine called for inflow, outflow, slipwall, noslipwall
! input: LSwall (LS just inside the domain)
! output: LS
      subroutine grouplsBC(time,dir,side,LS,LSwall, &
        xsten,nhalf,dx,bfact,nmat)
      use global_utility_module
      use rainControl_module
      use bubbleControl_module
      use hydrateReactor_module
      use unimaterialChannel_module
      use USERDEF_module
      use CAV3D_module
      use HELIX_module
      use TSPRAY_module
      use CAV2Dstep_module
      use ZEYU_droplet_impact_module
      use CONE3D_module
      use WAVY_Channel_module
      use rigid_FSI_module
      use sinking_particle_module

      IMPLICIT NONE

      INTEGER_T nmat,nhalf,bfact
      REAL_T xsten(-nhalf:nhalf,SDIM)
      INTEGER_T dir,side
      REAL_T LS(nmat)
      REAL_T LSwall(nmat)
      REAL_T time,xwall,x,y,z
      REAL_T dx(SDIM)
      REAL_T local_LS
      INTEGER_T im,im_opp,imls
      REAL_T bigdist
      INTEGER_T im_solid_lsbc
      REAL_T xvec(SDIM)
      INTEGER_T local_dir
      INTEGER_T iprob

      im_solid_lsbc=im_solid_primary()

       ! coordinate of cell center that is outside the domain.
      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)
      do local_dir=1,SDIM
       xvec(local_dir)=xsten(0,local_dir)
      enddo

      if (SDIM.eq.2) then
       if (abs(z-y).gt.VOFTOL) then
        print *,"y=z expected in 2D 3"
        stop
       endif
      endif

      bigdist=three*dx(1)

      if (nhalf.lt.1) then
       print *,"nhalf invalid group ls bc"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif

      if (dir.eq.1) then
       if (side.eq.1) then
        xwall=problox
       else
        xwall=probhix
       endif
      else if (dir.eq.2) then
       if (side.eq.1) then
        xwall=probloy
       else
        xwall=probhiy
       endif
      else if ((dir.eq.3).and.(SDIM.eq.3)) then
       if (side.eq.1) then
        xwall=probloz
       else
        xwall=probhiz
       endif
      else
       print *,"dir invalid grouplsbc"
       stop
      endif

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      do imls=1,nmat
       LS(imls)=LSwall(imls)
      enddo

      if (is_in_probtype_list().eq.1) then
       if (1.eq.0) then
        print *,"probtype= ",probtype
        print *,"probtype_list_size= ",probtype_list_size
        do iprob=1,probtype_list_size
         print *,"iprob,used_probtypes(iprob) ",iprob, &
                 used_probtypes(iprob)
        enddo
        stop
       endif
       call SUB_LS_BC(xwall,xvec,time,LS,LSwall,dir,side,dx, &
        num_materials)
       call check_lsbc_extrap(LS,LSWALL,nmat)
      else if (probtype.eq.411) then
       call CAV3D_LS_BC(xwall,xvec,time,LS,LSwall,dir,side,dx)
       call check_lsbc_extrap(LS,LSWALL,nmat)
      else if (probtype.eq.401) then
       call HELIX_LS_BC(xwall,xvec,time,LS,LSwall,dir,side,dx)
       call check_lsbc_extrap(LS,LSWALL,nmat)
      else if (probtype.eq.402) then
       call TSPRAY_LS_BC(xwall,xvec,time,LS,LSwall,dir,side,dx)
       call check_lsbc_extrap(LS,LSWALL,nmat)
      else if (probtype.eq.412) then ! step
       call CAV2Dstep_LS_BC(xwall,xvec,time,LS,LSwall,dir,side,dx)
       call check_lsbc_extrap(LS,LSWALL,nmat)
      else if (probtype.eq.413) then ! zeyu
       call ZEYU_droplet_impact_LS_BC(xwall,xvec,time,LS,LSwall,dir,side,dx)
       call check_lsbc_extrap(LS,LSWALL,nmat)
      else if (probtype.eq.533) then
       call rigid_FSI_LS_BC(xwall,xvec,time,LS,LSwall,dir,side,dx)
       call check_lsbc_extrap(LS,LSWALL,nmat)
      else if (probtype.eq.534) then
       call sinking_FSI_LS_BC(xwall,xvec,time,LS,LSwall,dir,side,dx)
       call check_lsbc_extrap(LS,LSWALL,nmat)

      else if (probtype.eq.311) then ! user defined problem

       call USERDEF_LS_BC(xwall,xvec,time,LS,LSwall,dir,side,dx)
       call check_lsbc_extrap(LS,LSWALL,nmat)

      else if (probtype.eq.222) then ! cone3d in grouplsBC

       call CONE3D_LS_BC(xwall,xvec,time,LS,LSwall,dir,side,dx)
       call check_lsbc_extrap(LS,LSWALL,nmat)

      else if (probtype.eq.915) then ! wavy channel

       call WAVY_LS_BC(xwall,xvec,time,LS,LSwall,dir,side,dx)
       call check_lsbc_extrap(LS,LSWALL,nmat)

       ! curvature sanity check (line in 2D, plane in 3D)
      else if ((probtype.eq.36).and.(axis_dir.eq.210)) then

       call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
       call check_lsbc_extrap(LS,LSWALL,nmat)

      else if (probtype.eq.199) then  ! in grouplsBC

       do imls=1,nmat
        im=imls
        call HYD_LVLS_BC(time,dir,side,LS(imls), &
         xwall,LSwall(imls),x,y,z,dx,im)
       enddo
       call check_lsbc_extrap(LS,LSWALL,nmat)

       ! in: grouplsBC
      else if (probtype.eq.220) then  ! UNIMATERIAL problem

       do imls=1,nmat-1
        im=imls
        call UNIMAT_LVLS_BC(time,dir,side,LS(imls), &
         xwall,LSwall(imls),x,y,z,dx,im)
       enddo
       imls=nmat
       if (FSI_flag(imls).eq.4) then
        LS(imls)=-ten
       else
        print *,"expecting FSI_flag equal to 4"
        stop
       endif

      else if ((probtype.eq.299).or. &
               (probtype.eq.301)) then !melting (boundary condition LS)

       call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
       call check_lsbc_extrap(LS,LSWALL,nmat)

      else if (probtype.eq.209) then  ! River
       call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
       call check_lsbc_extrap(LS,LSWALL,nmat)

       ! marangoni (heat pipe) problem
      else if ((probtype.eq.36).and.(axis_dir.eq.10)) then
       call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
       call check_lsbc_extrap(LS,LSWALL,nmat)
      else

       if ((dir.eq.1).and.(side.eq.1)) then  ! xlo
         if (xwall.lt.x) then
          print *,"xwall,x invalid"
          stop
         endif

         if (SDIM.eq.2) then

         if (probtype.eq.58) then
          local_LS=yblob2-y
          LS(1)=local_LS
          LS(2)=-local_LS
          do im=3,nmat
           LS(im)=-bigdist
          enddo
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.6) then
          LS(1)=-bigdist
          LS(2)=bigdist
          do im=3,nmat
           LS(im)=-bigdist
          enddo
          call check_lsbc_extrap(LS,LSWALL,nmat)

          ! ysl add level set function for BC 
         else if (probtype.eq.701) then ! xlo grouplsBC
          if ((axis_dir.eq.0).or.(axis_dir.eq.1)) then
           call xloLS_rain(x,y,z,nmat,LS,adv_vel,time,bigdist)
          else if (axis_dir.eq.2) then
           LS(1)=bigdist
           LS(2)=-bigdist
          else
           print *,"axis_dir invalid"
           stop
          endif
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if ((probtype.eq.bubbleInPackedColumn).and.(1.eq.2)) then ! xlo 
          call xloLS_pack(x,y,z,nmat,LS,adv_vel,time,bigdist)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.110) then
          call get_bump_dist(x,y,z,nmat,LS,time)
          call check_lsbc_extrap(LS,LSWALL,nmat)
          ! xlo 2d - grouplsBC
         else if ((probtype.eq.801).and.(axis_dir.eq.dir-1)) then 
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.802) then ! xlo: dissolution grouplsBC
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if ((probtype.eq.59).or. &
                  (probtype.eq.710)) then  !  xlo: dir=1 side=1 grouplsBC 2d
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.5700) then ! xlo
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.9) then  ! xlo, groupLSBC, 2d
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.41) then ! xlo, groupLSBC, 2d
          call inletpipedist(x,y,z,nmat,LS)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.532) then ! xlo
          call get_jet_dist(x,y,z,nmat,LS)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.539) then ! xlo, sup injector - grouplsBC
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.202) then ! xlo, liquidlens - grouplsbc
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         endif

         else if (SDIM.eq.3) then

         if (probtype.eq.50) then
          LS(1)=bigdist
          LS(2)=-bigdist
          do im=3,nmat
           LS(im)=-bigdist
          enddo
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.58) then
          local_LS=zblob2-z
          LS(1)=local_LS
          LS(2)=-local_LS
          do im=3,nmat
           LS(im)=-bigdist
          enddo
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.41) then ! xlo 3D, grouplsbc
          call inletpipedist(x,y,z,nmat,LS)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.5700) then ! xlo
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)

           ! airblast
         else if (probtype.eq.529) then  ! dir=1 side=1 grouplsBC
          call get_jet_dist(x,y,z,nmat,LS)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if ((probtype.eq.59).or. &
                  (probtype.eq.710)) then  ! xlo dir=1 side=1 grouplsBC 3d
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.5501) then  ! xlo, grouplsBC
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.9) then  ! xlo, grouplsBC, 3D
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         endif

         else
          print *,"dimension bust"
          stop
         endif

       else if ((dir.eq.1).and.(side.eq.2)) then ! xhi
         if (xwall.gt.x) then
          print *,"xwall,x invalid"
          stop
         endif
          ! outflow or inflow=EXT_DIR; for microfluid channels, 
          ! want extrap bc either case.
          ! so this code is disabled

         if (SDIM.eq.2) then

         if (probtype.eq.110) then
          call get_bump_dist(x,y,z,nmat,LS,time)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if ((probtype.eq.59).or. &
                  (probtype.eq.710)) then  ! dir=1 side=2 (xhi) grouplsBC 2d
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if ((probtype.eq.5700).and.(1.eq.0)) then ! xhi
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.9) then  ! xhi, groupLSBC, 2D
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.532) then ! xhi
          call get_jet_dist(x,y,z,nmat,LS)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.539) then ! xhi, sup injector
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.41) then  ! xhi
          call inletpipedist(x,y,z,nmat,LS)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.202) then ! xhi, liquidlens, grouplsbc
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if ((probtype.eq.25).and.(axis_dir.gt.0)) then ! xhi, bubble frm.
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         endif

         else if (SDIM.eq.3) then

         if ((probtype.eq.5700).and.(1.eq.0)) then ! xhi
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if ((probtype.eq.59).or. &
                  (probtype.eq.710)) then  ! xhi dir=1 side=2 3d
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.5501) then  ! xhi grouplsBC
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.9) then  ! xhi grouplsBC, 3D
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         endif

         else
          print *,"dimension bust"
          stop
         endif

       else if ((dir.eq.2).and.(side.eq.1)) then  ! ylo
         if (xwall.lt.y) then
          print *,"xwall,y invalid"
          stop
         endif

         if (SDIM.eq.2) then

          !ylo 2D bubble formation
         if ((probtype.eq.25).and.(axis_dir.gt.0)) then 
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
          ! ylo 2D grouplsBC
         else if ((probtype.eq.801).and.(axis_dir.eq.dir-1)) then
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.5700) then  ! ylo
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.41) then ! ylo
          call inletpipedist(x,y,z,nmat,LS)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.72) then
          local_LS=abs(x-xblob)-radblob
          LS(1)=-local_LS
          LS(2)=local_LS
          do im=3,nmat
           LS(im)=-bigdist
          enddo
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if ((probtype.eq.53).or.(probtype.eq.537)) then ! ylo 2D
          call get_jet_dist(x,y,z,nmat,LS)
          call check_lsbc_extrap(LS,LSWALL,nmat)
           ! 2D ylo, diesel injector, grouplsBC
         else if ((probtype.eq.538).or. &
                  (probtype.eq.539).or. &
                  (probtype.eq.541)) then
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
          ! 540 Rieber problem
         else if (probtype.eq.540) then !dir=2 side=1,2d
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if ((probtype.eq.59).or. &
                  (probtype.eq.710)) then !ylo dir=2 side=1,2d
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.9) then ! ylo, groupLSBC, 2D
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.bubbleInPackedColumn) then ! ylo grouplsBC
          call yloLS_pack(x,y,z,nmat,LS,adv_vel,time,bigdist)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         endif

         else if (SDIM.eq.3) then

         if (probtype.eq.5700) then  ! ylo
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if ((probtype.eq.59).or. &
                  (probtype.eq.710)) then  ! ylo dir=2 side=1 3d
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.5501) then  ! ylo grouplsBC
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.9) then  ! ylo, groupLSBC, 3D
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.532) then  ! impinge from side, ylo
          call get_jet_dist(x,y,z,nmat,LS)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         endif

         else
          print *,"dimension bust"
          stop
         endif

       else if ((dir.eq.2).and.(side.eq.2)) then  ! yhi
         if (xwall.gt.y) then
          print *,"xwall,y invalid"
          stop
         endif

         if (SDIM.eq.2) then

         if (probtype.eq.62) then
          LS(1)=-bigdist
          LS(2)=bigdist
          do im=3,nmat
           LS(im)=-bigdist
          enddo
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.5700) then ! yhi 2D
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if ((probtype.eq.14).or.(probtype.eq.16).or. &
               ((probtype.eq.25).and.(axis_dir.eq.0)) ) then
          if (probtype.eq.25) then
           LS(1)=bigdist
           LS(2)=-bigdist
          else if (probtype.eq.16) then
           LS(1)=-bigdist
           LS(2)=bigdist
          endif
          do im=3,nmat
           LS(im)=-bigdist
          enddo
          call check_lsbc_extrap(LS,LSWALL,nmat)
          ! top y=ymax wall
         else if (probtype.eq.41) then
          call inletpipedist(x,y,z,nmat,LS)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.540) then  ! Rieber problem y=yhi
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.539) then ! yhi, sup injector
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.9) then ! yhi, groupLSBC, 2D
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.701) then ! yhi, groupLSBC, 2D
          if ((axis_dir.eq.0).or.(axis_dir.eq.1)) then
           call yhiLS_rain(x,y,z,nmat,LS,adv_vel,time,bigdist)
           call check_lsbc_extrap(LS,LSWALL,nmat)
          else if (axis_dir.eq.2) then
           ! do nothing
          else
           print *,"axis_dir invalid"
           stop
          endif
         endif

         else if (SDIM.eq.3) then

         if (probtype.eq.5700) then ! yhi
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.5501) then  ! yhi grouplsBC
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if ((probtype.eq.59).or. &
                  (probtype.eq.710)) then  ! yhi dir=2 side=2 3d
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.9) then ! yhi, groupLSBC, 3D
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.532) then  ! impinge from side, yhi
          call get_jet_dist(x,y,z,nmat,LS)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         endif

         else
          print *,"dimension bust"
          stop
         endif

       else if ((dir.eq.3).and.(side.eq.1).and.(SDIM.eq.3)) then  ! zlo
         if (xwall.lt.z) then
          print *,"xwall,z invalid"
          stop
         endif

          ! called at inflow and outflow bc

         if ((probtype.eq.538).or. &
             (probtype.eq.541)) then  ! zlo, diesel injector

          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         
         else if ((probtype.eq.53).or.(probtype.eq.531).or. &  ! zlo 3D
                  (probtype.eq.530).or.(probtype.eq.536).or. &
                  (probtype.eq.537).or.(probtype.eq.532)) then
          call get_jet_dist(x,y,z,nmat,LS)
          call check_lsbc_extrap(LS,LSWALL,nmat)

          ! 540 Rieber problem
         else if (probtype.eq.540) then  ! dir=3 side=1
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if ((probtype.eq.59).or. &
                  (probtype.eq.710)) then  ! zlo dir=3 side=1 groupLSBC
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.5501) then  ! zlo grouplsBC
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.9) then  ! zlo grouplsBC
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.5700) then  ! microfluidics zlo
          do im=1,nmat
           LS(im)=-bigdist
          enddo
          if ((im_solid_lsbc.le.0).or. &
              (im_solid_lsbc.gt.num_materials)) then
           print *,"im_solid_lsbc invalid 15"
           stop
          endif
          LS(im_solid_lsbc)=bigdist
          call check_lsbc_extrap(LS,LSWALL,nmat)
         endif

       else if ((dir.eq.3).and.(side.eq.2).and.(SDIM.eq.3)) then ! zhi
         if (xwall.gt.z) then
          print *,"xwall,z invalid"
          stop
         endif
         if ((probtype.eq.62).or.(probtype.eq.65)) then
          LS(1)=-bigdist
          LS(2)=bigdist
          do im=3,nmat
           LS(im)=-bigdist
          enddo
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.540) then  ! Rieber problem z=zhi
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.9) then  ! zhi, groupLSBC
          call materialdist_batch(xsten,nhalf,dx,bfact,LS,nmat)
          call check_lsbc_extrap(LS,LSWALL,nmat)
         else if (probtype.eq.5700) then  ! microfluidics zhi
          do im=1,nmat
           LS(im)=-bigdist
          enddo
          if ((im_solid_lsbc.lt.1).or. &
              (im_solid_lsbc.gt.num_materials)) then
           print *,"im_solid_lsbc invalid 16"
           stop
          endif
          LS(im_solid_lsbc)=bigdist
          call check_lsbc_extrap(LS,LSWALL,nmat)
         endif

       else
         print *,"dir side invalid"
         stop
       endif

      endif ! not hydrates

      if (ls_homflag.eq.0) then
       ! do nothing
      else if (ls_homflag.eq.1) then
       do im=1,nmat
        if (is_rigid(nmat,im).eq.1) then
         if (LS(im).ge.zero) then ! point is in the solid
          do im_opp=1,nmat
           if (im.ne.im_opp) then
            if (is_rigid(nmat,im_opp).eq.0) then
             LS(im_opp)=LSwall(im_opp)  ! default 90 degree contact angle.
            else if (is_rigid(nmat,im_opp).eq.1) then
             ! do nothing
            else
             print *,"is_rigid invalid"
             stop
            endif
           else if (im.eq.im_opp) then
            ! do nothing
           else
            print *,"im_opp invalid"
            stop
           endif
          enddo ! im_opp=1..nmat
         else if (LS(im).lt.zero) then
          ! do nothing
         else
          print *,"in: subroutine grouplsBC"
          print *,"time,dir,side,bfact,nmat ",time,dir,side,bfact,nmat
          print *,"probtype,axis_dir ",probtype,axis_dir
          print *,"ls_homflag=",ls_homflag
          print *,"dimension= ",SDIM
          print *,"LS(im) invalid: im, LS(im)= ",im,LS(im)
          do imls=1,nmat
           print *,"imls,LSwall(imls) ",imls,LSwall(imls)
          enddo
          print *,"x,y,z ",x,y,z
          print *,"bigdist=",bigdist
          stop
         endif
        else if (is_rigid(nmat,im).eq.0) then
         ! do nothing
        else
         print *,"is_rigid invalid"
         stop
        endif
       enddo ! im=1..nmat

      else
       print *,"ls_homflag invalid"
       stop
      endif

      return
      end subroutine grouplsBC

      subroutine eval_face_coeff( &
       caller_id, &
       level,finest_level, &
       cc,cc_ice,cc_group, &
       dd,dd_group, &
       visc_coef, &
       nsolve,nsolveMM,im_vel,dir,veldir,project_option, &
       constant_viscosity,side,local_presbc,local_wt)
              
      IMPLICIT NONE

      INTEGER_T, intent(in) :: caller_id
      INTEGER_T, intent(in) :: level,finest_level
      REAL_T, intent(in) :: cc,cc_ice
      REAL_T, intent(out) :: cc_group
      REAL_T, intent(in) :: dd
      REAL_T :: ddfactor
      REAL_T, intent(out) :: dd_group
      REAL_T, intent(in) :: visc_coef
      INTEGER_T, intent(in) :: nsolve,nsolveMM,im_vel,dir,veldir,project_option
      INTEGER_T, intent(in) :: constant_viscosity,side,local_presbc
      REAL_T, intent(out) :: local_wt(nsolve)
      INTEGER_T :: at_RZ_boundary

      if ((cc.ge.zero).and. &
          (cc.le.one).and. &
          (cc_ice.ge.zero).and. &
          (cc_ice.le.one).and. &
          (dd.ge.zero).and. &
          (visc_coef.ge.zero).and. &
          (nsolve.ge.1).and. &
          (nsolveMM.ge.1).and. &
          (im_vel.ge.1).and. &
          (veldir.ge.1).and. &
          (veldir.le.nsolve).and. &
          (dir.ge.0).and. &
          (dir.lt.SDIM).and. &
          (project_option.ge.0).and. &
          (constant_viscosity.ge.0).and. &
          (side.ge.0).and. &
          (level.ge.0).and. &
          (level.le.finest_level)) then

       at_RZ_boundary=0
       if (SDIM.eq.2) then
        if (dir.eq.0) then
         if (side.eq.1) then
          if (local_presbc.eq.REFLECT_EVEN) then
           at_RZ_boundary=1
          else if ((local_presbc.eq.INT_DIR).or. &
                   (local_presbc.eq.EXT_DIR).or. &
                   (local_presbc.eq.REFLECT_ODD).or. &
                   (local_presbc.eq.FOEXTRAP)) then
           ! do nothing
          else
           print *,"local_presbc invalid"
           stop
          endif
         else if ((side.eq.0).or.(side.eq.2)) then
          ! do nothing
         else
          print *,"side invalid"
          stop
         endif
        else if (dir.eq.1) then
         ! do nothing
        else
         print *,"dir invalid"
         stop
        endif
       else if (SDIM.eq.3) then
        ! do nothing
       else
        print *,"dimension bust"
        stop
       endif

       local_wt(veldir)=zero
       cc_group=cc
       dd_group=dd

       if ((project_option.eq.0).or. &  !regular project
           (project_option.eq.1).or. &  !initial project
           (project_option.eq.10).or. & !sync project
           (project_option.eq.13).or. & !FSI_material_exists 1st project
           (project_option.eq.11)) then !FSI_material_exists 2nd project

        if (project_option.eq.0) then !regular pressure projection
         cc_group=cc
        else if (project_option.eq.13) then !FSI_material_exists 1st project
         cc_group=cc*cc_ice  ! cc_ice comes from LOCAL_ICEFACECUT_MF
        else if (project_option.eq.1) then ! initial projection
         cc_group=cc*cc_ice
        else if ((project_option.eq.10).or. & !sync project (advection)
                 (project_option.eq.11)) then !FSI_material_exists 2nd project
         cc_group=cc*cc_ice
        else
         print *,"project_option invalid"
         stop
        endif

        if ((nsolveMM.ne.1).or.(nsolve.ne.1)) then
         print *,"nsolveMM or nsolve invalid"
         stop
        endif

        if (at_RZ_boundary.eq.1) then
         local_wt(veldir)=zero
        else if (at_RZ_boundary.eq.0) then
         if ((dd_group.gt.zero).and.(cc_group.ge.zero)) then
          local_wt(veldir)=dd_group*cc_group
          if (side.eq.0) then
           ! do nothing
          else if ((side.eq.1).or.(side.eq.2)) then
           if ((local_presbc.eq.REFLECT_EVEN).or. &
               (local_presbc.eq.FOEXTRAP)) then
            local_wt(veldir)=zero
           else if ((local_presbc.eq.INT_DIR).or. &
                    (local_presbc.eq.EXT_DIR)) then
            ! do nothing
           else
            print *,"local_presbc invalid"
            stop
           endif
          else
           print *,"side invalid"
           stop
          endif
         else
          print *,"dd_group or cc_group invalid1"
          print *,"dd_group= ",dd_group
          print *,"cc_group= ",cc_group
          print *,"cc,cc_ice,dd,nsolve,dir,side ", &
             cc,cc_ice,dd,nsolve,dir,side
          print *,"level,finest_level,caller_id ", &
            level,finest_level,caller_id
          print *,"at_RZ_boundary ",at_RZ_boundary
          print *,"local_presbc ",local_presbc
          print *,"project_option= ",project_option
          stop
         endif
        else
         print *,"at_RZ_boundary invalid"
         stop
        endif

       else if (project_option.eq.12) then ! pressure extrapolation
        if ((nsolveMM.ne.1).or.(nsolve.ne.1)) then
         print *,"nsolveMM or nsolve invalid"
         stop
        endif
        cc_group=cc*cc_ice

        if (at_RZ_boundary.eq.1) then
         local_wt(veldir)=zero
        else if (at_RZ_boundary.eq.0) then
         if ((dd_group.gt.zero).and. &
             (cc_group.ge.zero)) then
          if (cc_group.gt.zero) then
           local_wt(veldir)=zero
          else if (cc_group.eq.zero) then
           local_wt(veldir)=one
          else
           print *,"cc_group invalid"
           stop
          endif
          if (side.eq.0) then
           ! do nothing
          else if ((side.eq.1).or.(side.eq.2)) then
           if (local_presbc.eq.INT_DIR) then
            ! do nothing (periodic BC)
           else if (local_presbc.eq.EXT_DIR) then !pressure extrap case
            ! do nothing (same BC as regular pressue)
           else if ((local_presbc.eq.REFLECT_EVEN).or. &
                    (local_presbc.eq.FOEXTRAP)) then
            local_wt(veldir)=zero ! pressure extrap case
           else
            print *,"local_presbc invalid"
            stop
           endif
          else
           print *,"side invalid"
           stop
          endif
         else
          print *,"dd_group or cc_group invalid2"
          print *,"dd_group= ",dd_group
          print *,"cc_group= ",cc_group
          print *,"project_option=",project_option
          stop
         endif
        else
         print *,"at_RZ_boundary invalid"
         stop
        endif

       else if ((project_option.eq.2).or. & ! temperature
                ((project_option.ge.100).and. &
                 (project_option.lt.100+num_species_var))) then
        if ((nsolveMM.ne.num_materials_scalar_solve).or.(nsolve.ne.1)) then
         print *,"nsolveMM or nsolve invalid"
         stop
        endif
        cc_group=one  ! rely on solid coefficient at solid
        if ((dd_group.ge.zero).and. &
            (cc_group.eq.one)) then
         local_wt(veldir)=dd_group*cc_group
         if (side.eq.0) then
          ! do nothing
         else if ((side.eq.1).or.(side.eq.2)) then
          if (local_presbc.eq.INT_DIR) then
           ! do nothing
          else if (local_presbc.eq.EXT_DIR) then
           ! do nothing
          else if (local_presbc.eq.REFLECT_EVEN) then
           local_wt(veldir)=zero
          else if (local_presbc.eq.FOEXTRAP) then
           local_wt(veldir)=zero
          else
           print *,"local_presbc invalid"
           stop
          endif
         else
          print *,"side invalid"
          stop
         endif
        else
         print *,"dd_group or cc_group invalid3"
         print *,"dd_group= ",dd_group
         print *,"cc_group= ",cc_group
         print *,"project_option=",project_option
         stop
        endif
       else if (project_option.eq.3) then ! viscosity
        if ((nsolveMM.ne.SDIM).or.(nsolve.ne.SDIM)) then
         print *,"nsolveMM or nsolve invalid"
         stop
        endif
        dd_group=dd*visc_coef
        cc_group=one
        ddfactor=one
        if ((dd_group.ge.zero).and. &
            (cc_group.eq.one)) then
         if (constant_viscosity.eq.0) then
          if (dir+1.eq.veldir) then
           ddfactor=two
          endif
         else if (constant_viscosity.eq.1) then
          ! do nothing
         else
          print *,"constant_viscosity invalid"
          stop
         endif

         local_wt(veldir)=dd_group*cc_group*ddfactor

         if (side.eq.0) then
          ! do nothing
         else if ((side.eq.1).or.(side.eq.2)) then
          if (local_presbc.eq.INT_DIR) then
           ! do nothing
          else if (local_presbc.eq.EXT_DIR) then
           ! do nothing
          else if (local_presbc.eq.REFLECT_ODD) then
           ! do nothing
          else if (local_presbc.eq.REFLECT_EVEN) then
           local_wt(veldir)=zero
          else if (local_presbc.eq.FOEXTRAP) then
           local_wt(veldir)=zero
          else
           print *,"local_presbc invalid"
           stop
          endif
         else
          print *,"side invalid"
          stop
         endif
        else
         print *,"dd_group or cc_group invalid4"
         print *,"dd_group= ",dd_group
         print *,"cc_group= ",cc_group
         print *,"project_option=",project_option
         stop
        endif
       else
        print *,"project_option invalid eval_face_coeff"
        stop
       endif

      else 
       print *,"coefficients bust"
       print *,"cc=",cc
       print *,"cc_ice=",cc_ice
       print *,"dd=",dd
       print *,"visc_coef=",visc_coef
       print *,"nsolve=",nsolve
       print *,"nsolveMM=",nsolveMM
       print *,"im_vel=",im_vel
       print *,"veldir=",veldir
       print *,"dir=",dir
       print *,"side=",side
       print *,"project_option=",project_option
       print *,"constant_viscosity=",constant_viscosity
       stop
      endif

      return
      end subroutine eval_face_coeff

! operation_flag=0  pressure gradient on MAC grid
! operation_flag=1  interpolate pressure from cell to MAC grid.
! operation_flag=2  potential gradient on MAC grid, 
!                   interpolate potential from cell to MAC grid
!                   surface tension on MAC grid
!                   left and right surface tension on MAC grid.
! operation_flag=3  unew^MAC=unew^CELL->MAC
! operation_flag=4  unew^MAC=uSOLID^MAC or uFLUID^MAC
! operation_flag=5  unew^MAC=unew^MAC+beta diffuse_ref^CELL->MAC
! operation_flag=6  evaluate tensor values.
! operation_flag=7  advection.
! operation_flag=8  reserved for coupling terms in CROSSTERM
! operation_flag=9  den CELL->MAC
! operation_flag=10 unew^MAC=unew^CELL,MAC -> MAC
! operation_flag=11 unew^MAC=unew^CELL DIFF,MAC -> MAC
      subroutine SEM_CELL_TO_MAC( &
       conservative_div_uu, &
       ncomp_xp, &  ! number of amrsync components if op=0,3,5,6,7,9,10,11
       simple_AMR_BC_flag_in, &
       nsolveMM_FACE, &
       num_materials_face, &
       level, &
       finest_level, &
       nmat, &
       operation_flag, &
       energyflag, &
       temperature_primitive_variable, &
       project_option, &
       SEM_upwind, &
       SEM_advection_algorithm, &
       beta, &
       visc_coef, &
       time, &
       dt, &
       i,j,k, &
       tilelo,tilehi, &
       fablo,fabhi, &
       xlo,dx, &
       dir, &
       bfact,bfact_c,bfact_f, &
       presbc_in, &
       velbc_in, &
       scomp, &
       scomp_bc, &
       dcomp, &
       update_right_flux, &
       ncomp_dest, &
       ncomp_source, &
       ncomp_xgp, &
       ncphys, &
       spectral_loop, &
       ncfluxreg, &
       semflux,DIMS(semflux), &
       maskCF,DIMS(maskCF), & !maskCF=1.0 at interior fine bc ghost cells
       maskcov,DIMS(maskcov), & ! 1=not cov. or outside domain  
       vel,DIMS(vel), & 
       pres,DIMS(pres), & 
       den,DIMS(den), & 
       xface,DIMS(xface), & 
       xgp,DIMS(xgp), &  ! holds Umac_old if operation_flag==5 or 11.
       xcut,DIMS(xcut), & 
       xp,DIMS(xp), &  ! holds amrsync if op==0,3,5,6,7,9,10,11
       xvel,DIMS(xvel), & 
       maskSEM,DIMS(maskSEM) )
      use global_utility_module

      IMPLICIT NONE

      INTEGER_T, intent(in) :: conservative_div_uu
      INTEGER_T, intent(in) :: ncomp_xp
      INTEGER_T, intent(in) :: simple_AMR_BC_flag_in
      INTEGER_T :: simple_AMR_BC_flag
      INTEGER_T :: local_AMR_BC_flag
      INTEGER_T, intent(in) :: num_materials_face
      INTEGER_T, intent(in) :: level
      INTEGER_T, intent(in) :: finest_level
      INTEGER_T, intent(in) :: nmat
      INTEGER_T, intent(in) :: nsolveMM_FACE
      REAL_T, intent(in) :: time
      REAL_T, intent(in) :: dt
      REAL_T, intent(in) :: beta,visc_coef
      INTEGER_T, intent(in) :: operation_flag
      INTEGER_T, intent(in) :: energyflag
      INTEGER_T, intent(in) :: temperature_primitive_variable(nmat)
      INTEGER_T, intent(in) :: project_option
      INTEGER_T, intent(in) :: SEM_upwind
      INTEGER_T, intent(in) :: SEM_advection_algorithm
      INTEGER_T, intent(in) :: i,j,k
      INTEGER_T, intent(in) :: dir
      INTEGER_T, intent(in) :: bfact,bfact_c,bfact_f
      INTEGER_T, intent(in) :: scomp,scomp_bc
      INTEGER_T, intent(in) :: dcomp
      INTEGER_T, intent(in) :: update_right_flux
      INTEGER_T, intent(in) :: ncomp_dest
      INTEGER_T, intent(in) :: ncomp_source
      INTEGER_T, intent(in) :: ncomp_xgp
      INTEGER_T, intent(in) :: ncphys
      INTEGER_T, intent(in) :: spectral_loop
      INTEGER_T, intent(in) :: ncfluxreg
      INTEGER_T, intent(in) :: tilelo(SDIM),tilehi(SDIM)
      INTEGER_T, intent(in) :: fablo(SDIM),fabhi(SDIM)
      REAL_T, intent(in) :: xlo(SDIM)
      REAL_T, intent(in) :: dx(SDIM)
      INTEGER_T, intent(in) :: presbc_in(SDIM,2,nmat*num_state_material)
      INTEGER_T, intent(in) :: velbc_in(SDIM,2,SDIM*num_materials_face)
      INTEGER_T, intent(in) :: DIMDEC(semflux)
      INTEGER_T, intent(in) :: DIMDEC(maskCF)
      INTEGER_T, intent(in) :: DIMDEC(maskcov)
      INTEGER_T, intent(in) :: DIMDEC(vel)
      INTEGER_T, intent(in) :: DIMDEC(pres)
      INTEGER_T, intent(in) :: DIMDEC(den)
      INTEGER_T, intent(in) :: DIMDEC(maskSEM)
      INTEGER_T, intent(in) :: DIMDEC(xface)
      INTEGER_T, intent(in) :: DIMDEC(xcut)
      INTEGER_T, intent(in) :: DIMDEC(xgp)
      INTEGER_T, intent(in) :: DIMDEC(xp)
      INTEGER_T, intent(in) :: DIMDEC(xvel)
      REAL_T, intent(inout) :: semflux(DIMV(semflux),ncfluxreg)
      REAL_T, intent(in) :: maskCF(DIMV(maskCF)) ! 1=fine-fine  0=coarse-fine
      REAL_T, intent(in) :: maskcov(DIMV(maskcov))
      REAL_T, intent(in) :: maskSEM(DIMV(maskSEM))
      REAL_T, intent(in) :: vel(DIMV(vel),SDIM*num_materials_face)
      REAL_T, intent(in) :: pres(DIMV(pres),num_materials_face)
      REAL_T, intent(in) :: den(DIMV(den),nmat*num_state_material)
      REAL_T, intent(inout) :: xface(DIMV(xface),ncphys) 
       !xgp is usually a dest variable except that it holds umac_old if 
       !op==11 or op 5
      REAL_T, intent(inout) :: xgp(DIMV(xgp),ncomp_xgp) 
      REAL_T, intent(inout) :: xcut(DIMV(xcut)) 
      REAL_T, intent(inout) :: xp(DIMV(xp),ncomp_xp) 
      REAL_T, intent(inout) :: xvel(DIMV(xvel),nsolveMM_FACE) 

      INTEGER_T local_bctype(2)
      INTEGER_T local_bctype_den(2)
      REAL_T x_sep(2)
      REAL_T local_bcval(2)
      REAL_T local_bcval_den(2)
      INTEGER_T cen_maskSEM
      REAL_T local_vel(0:bfact)
      REAL_T RRface(0:bfact)
      REAL_T local_data(bfact)
      REAL_T local_data_side(2)
      REAL_T local_data_den(bfact)
      REAL_T local_data_side_den(2)
      REAL_T local_grad(bfact+1)
      REAL_T local_grad_den(bfact+1)
      REAL_T local_interp(bfact+1)
      REAL_T local_interp_den(bfact+1)
      INTEGER_T ii,jj,kk
      REAL_T xsten(-3:3,SDIM)
      REAL_T xsten_coarse(-3:3,SDIM)
      REAL_T xsten_fine(-3:3,SDIM)
      REAL_T xsten_face(-3:3,SDIM)
      INTEGER_T nhalf,nc
      INTEGER_T side
       ! 0=fine-fine neighbor  1=fine-wall neighbor  
       ! -1=fine (current) -coarse neighbor -2=coarse (current) -fine neighbor
      INTEGER_T nbr_outside_domain_flag(2)
      INTEGER_T cen_outside_domain_flag
      INTEGER_T strip_outside_fab_flag
      INTEGER_T isten
      INTEGER_T dir2
      INTEGER_T sideidx(SDIM)
      INTEGER_T i_out,j_out,k_out
      INTEGER_T mask_out
      INTEGER_T local_maskcov
      INTEGER_T local_maskCF
      INTEGER_T shared_face ! in: fort_sem_cell_to_mac
      REAL_T shared_face_value
      INTEGER_T i_in,j_in,k_in
      INTEGER_T ic,jc,kc
      INTEGER_T icoarse,jcoarse,kcoarse
      INTEGER_T iface_out,jface_out,kface_out
      INTEGER_T ifine,jfine,kfine
      INTEGER_T ibase
      INTEGER_T ngroup,fluxbase
      INTEGER_T indexlo(SDIM)
      INTEGER_T indexhi(SDIM)
      INTEGER_T indexmid(SDIM)
      INTEGER_T index_edge(SDIM)
      INTEGER_T index_opp(SDIM)
      REAL_T denlocal,templocal,DeDT
      INTEGER_T test_maskSEM
      REAL_T shared_xcut
      INTEGER_T velcomp
      INTEGER_T prescomp
      INTEGER_T nbase
      INTEGER_T ntensor
      INTEGER_T ntensorMM
      INTEGER_T nsolveMM_FACE_test
      INTEGER_T local_incomp
      INTEGER_T testbc
      REAL_T problo(SDIM),probhi(SDIM),problen(SDIM)
      REAL_T dx_c(SDIM),dx_f(SDIM)
      INTEGER_T domlo(SDIM)
      INTEGER_T bctype_tag
      REAL_T inside_flux,outside_flux
      REAL_T udotn_boundary

      simple_AMR_BC_flag=simple_AMR_BC_flag_in
      if (1.eq.0) then
       simple_AMR_BC_flag=1
      endif

      problo(1)=problox 
      problo(2)=probloy
      probhi(1)=probhix 
      probhi(2)=probhiy
      if (SDIM.eq.3) then
       problo(SDIM)=probloz
       probhi(SDIM)=probhiz
      endif

      do dir2=1,SDIM
       problen(dir2)=probhi(dir2)-problo(dir2)
       if (problen(dir2).gt.zero) then
        ! do nothing
       else
        print *,"problen invalid"
        stop
       endif
       dx_c(dir2)=dx(dir2)
       dx_f(dir2)=dx(dir2)
       if (level.gt.0) then
        dx_c(dir2)=two*dx(dir2)
       endif
       if (level.lt.finest_level) then
        dx_f(dir2)=half*dx(dir2)
       endif
       domlo(dir2)=0
      enddo ! dir2=1..sdim

      if ((simple_AMR_BC_flag.eq.0).or. &
          (simple_AMR_BC_flag.eq.1)) then
       ! do nothing
      else
       print *,"simple_AMR_BC_flag invalid"
       stop
      endif

      if (ncomp_xp.lt.1) then
       print *,"ncomp_xp invalid"
       stop
      endif
      if (ncomp_xgp.lt.1) then
       print *,"ncomp_xgp invalid"
       stop
      endif
      if (num_materials_vel.ne.1) then
       print *,"num_materials_vel invalid"
       stop
      endif
 
      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif
      if (ncphys.lt.1) then
       print *,"ncphys invalid"
       stop
      endif
      if (bfact.lt.2) then
       print *,"bfact invalid200"
       stop
      endif
      if ((bfact_c.ne.bfact).and.(bfact_c.ne.2*bfact)) then
       print *,"bfact_c invalid"
       stop
      endif
      if ((bfact_f.ne.bfact).and.(bfact.ne.2*bfact_f)) then
       print *,"bfact_f invalid"
       stop
      endif
      if ((SEM_upwind.ne.0).and.(SEM_upwind.ne.1)) then
       print *,"SEM_upwind invalid"
       stop
      endif
      if ((SEM_advection_algorithm.eq.0).or. &
          (SEM_advection_algorithm.eq.1)) then
       ! do nothing
      else
       print *,"SEM_advection_algorithm invalid"
       stop
      endif

      if ((update_right_flux.ne.0).and. &
          (update_right_flux.ne.1)) then
       print *,"update_right_flux invalid"
       stop
      endif
      nsolveMM_FACE_test=num_materials_face
      if (num_materials_face.eq.1) then
       ! do nothing
      else if (num_materials_face.eq.nmat) then
       nsolveMM_FACE_test=nsolveMM_FACE_test*2
      else
       print *,"num_materials_face invalid"
       stop
      endif
      if (nsolveMM_FACE_test.ne.nsolveMM_FACE) then
       print *,"nsolveMM_FACE invalid"
       stop
      endif

      ntensor=SDIM*SDIM
      ntensorMM=ntensor*num_materials_vel

      if ((level.lt.0).or. &
          (level.gt.finest_level)) then
       print *,"level invalid sem cell to mac"
       stop
      endif

      if ((dir.lt.1).or.(dir.gt.SDIM)) then
       print *,"dir invalid sem cell to mac1"
       stop
      endif

      ngroup=(ncfluxreg/SDIM)
      if (ngroup*SDIM.ne.ncfluxreg) then
       print *,"ncfluxreg invalid1 ",ncfluxreg
       stop
      endif
      fluxbase=(dir-1)*ngroup

      cen_maskSEM=NINT(maskSEM(D_DECL(i,j,k)))
      local_maskcov=NINT(maskcov(D_DECL(i,j,k)))
      if (local_maskcov.ne.1) then
       print *,"local_maskcov invalid in sem_cell_to_mac"
       stop
      endif
      if ((cen_maskSEM.lt.0).or.(cen_maskSEM.gt.nmat)) then
       print *,"cen_maskSEM invalid"
       stop
      endif

      if (operation_flag.eq.6) then ! tensor

       if (ncomp_xgp.ne.ntensorMM) then
        print *,"ncomp_xgp invalid1"
        stop
       endif
       if (ncomp_xp.ne.SDIM) then
        print *,"ncomp_xp invalid (it is supposed to be sdim)"
        stop
       endif
       if (update_right_flux.ne.0) then
        print *,"update_right_flux invalid"
        stop
       endif
       if (energyflag.ne.0) then
        print *,"energyflag invalid"
        stop
       endif
       if (project_option.ne.3) then
        print *,"project_option invalid"
        stop
       endif
        ! number of components for flux synchronization.
       if (ncfluxreg.ne.ntensor) then
        print *,"ncfluxreg invalid2 ",ncfluxreg
        stop
       endif
! compute u_x,v_x,w_x, u_y,v_y,w_y, u_z,v_z,w_z;  

       nbase=dcomp-1

       if ((nbase.ne.0).and.(nbase.ne.SDIM).and. &
           (nbase.ne.(SDIM-1)*SDIM)) then
        print *,"nbase invalid"
        stop
       endif

       if (scomp.ne.1) then
        print *,"scomp invalid"
        stop
       endif
       if (ncomp_source.ne.num_materials_vel*SDIM) then
        print *,"ncomp_source invalid"
        stop
       endif
       if (ncomp_dest.ne.SDIM) then
        print *,"ncomp_dest invalid"
        stop
       endif
       if (scomp_bc.ne.1) then
        print *,"scomp_bc invalid"
        stop
       endif

      else if (operation_flag.eq.7) then ! advection

       if (ncomp_xp.ne.SDIM+2) then
        print *,"ncomp_xp invalid"
        stop
       endif
       if (ncomp_xgp.ne.SDIM+2) then
        print *,"ncomp_xgp invalid2"
        stop
       endif
       if (energyflag.ne.0) then
        print *,"energyflag invalid"
        stop
       endif
       if (update_right_flux.ne.0) then
        print *,"update_right_flux invalid"
        stop
       endif
       if (ncfluxreg.ne.SDIM*(SDIM+num_state_base)) then
        print *,"ncfluxreg invalid operation_flag.eq.7"
        stop
       endif
       if ((scomp.ne.1).or. &
           (dcomp.ne.1).or. &
           (ncomp_dest.ne.ncphys).or. &
           (ncphys.ne.SDIM+num_state_base).or. &
           (ncomp_source.ne.SDIM*num_materials_face).or. &
           (scomp_bc.ne.1)) then
        print *,"parameters invalid for op=7"
        stop
       endif
       if ((cen_maskSEM.ge.1).and.(cen_maskSEM.le.nmat)) then
        ! do nothing
       else
        print *,"cen_maskSEM invalid"
        stop
       endif

      else if (operation_flag.eq.0) then ! grad p

       if (ncomp_xgp.ne.nsolveMM_FACE) then
        print *,"ncomp_xgp invalid3"
        stop
       endif
       if ((energyflag.ne.0).and. & ! regular solver
           (energyflag.ne.2)) then  ! for SDC
        print *,"energyflag invalid"
        stop
       endif
       if (num_materials_face.eq.1) then
        if ((scomp.ne.1).or.(dcomp.ne.1)) then
         print *,"parameters invalid for op=0"
         stop
        endif
        if (update_right_flux.ne.0) then
         print *,"update_right_flux invalid"
         stop
        endif
       else if (num_materials_face.eq.nmat) then
        if (update_right_flux.ne.1) then
         print *,"update_right_flux invalid"
         stop
        endif
        if ((scomp.ne.cen_maskSEM).or. &
            (dcomp.ne.cen_maskSEM)) then
         print *,"parameters invalid for op=0"
         stop
        endif
       else
        print *,"num_materials_face invalid"
        stop
       endif
       if ((ncomp_dest.ne.1).or. &
           (ncomp_source.ne.1).or. &
           (scomp_bc.ne.1)) then
        print *,"parameters invalid for op=0"
        stop
       endif

      else if (operation_flag.eq.1) then ! pressure cell->mac
  
       if (ncomp_xgp.ne.1) then
        print *,"ncomp_xgp invalid4"
        stop
       endif
       if (ncomp_xp.ne.3) then
        print *,"ncomp_xp invalid"
        stop
       endif
       if (energyflag.ne.0) then
        print *,"energyflag invalid"
        stop
       endif
       if (num_materials_face.ne.1) then
        print *,"num_materials_face invalid"
        stop
       endif
       if (update_right_flux.ne.0) then
        print *,"update_right_flux invalid"
        stop
       endif
       if ((scomp.ne.1).or. &
           (dcomp.ne.3)) then
        print *,"parameters invalid for op=1"
        stop
       endif
       if ((ncomp_dest.ne.1).or.(ncomp_source.ne.1).or. &
           (scomp_bc.ne.1)) then
        print *,"parameters invalid for op=1"
        stop
       endif

      else if (operation_flag.eq.2) then ! potential cell->mac, grad ppot

       if (ncomp_xgp.ne.nsolveMM_FACE) then
        print *,"ncomp_xgp invalid5"
        stop
       endif
       if (ncomp_xp.ne.3) then
        print *,"ncomp_xp invalid5"
        stop
       endif
       if (ncomp_xgp.ne.1) then
        print *,"ncomp_xgp invalid"
        stop
       endif

       if (update_right_flux.ne.0) then
        print *,"update_right_flux invalid"
        stop
       endif
       if (energyflag.ne.0) then
        print *,"energyflag invalid"
        stop
       endif
       if ((ncomp_dest.ne.1).or. &
           (ncomp_source.ne.1).or. &
           (scomp.ne.1).or. &
           (dcomp.ne.1).or. &
           (scomp_bc.ne.1)) then
        print *,"parameters invalid for op=2"
        stop
       endif

      else if (operation_flag.eq.9) then ! den CELL->MAC

       if (ncomp_xgp.ne.nsolveMM_FACE) then
        print *,"ncomp_xgp invalid6"
        stop
       endif
       if (energyflag.ne.0) then
        print *,"energyflag invalid"
        stop
       endif
       if (update_right_flux.ne.0) then
        print *,"update_right_flux invalid"
        stop
       endif
       if ((scomp.ne.(cen_maskSEM-1)*num_state_material+1).or. &
           (dcomp.ne.1)) then
        print *,"parameters invalid for op=9"
        stop
       endif
       if ((ncomp_dest.ne.1).or. &
           (ncomp_source.ne.nmat*num_state_material).or. &
           (scomp_bc.ne.1)) then
        print *,"parameters invalid for op=9"
        stop
       endif

      else if ((operation_flag.eq.3).or. & !unew^CELL->MAC
               (operation_flag.eq.10).or. &!unew^MAC,CELL->MAC
               (operation_flag.eq.11).or. &!unew^MAC,CELL DIFF->MAC
               (operation_flag.eq.5)) then !umac=umac+beta diff^CELL->MAC

       if (ncomp_xgp.ne.nsolveMM_FACE) then
        print *,"ncomp_xgp invalid7"
        stop
       endif
       if (energyflag.ne.0) then
        print *,"energyflag invalid"
        stop
       endif
       if (num_materials_face.ne.1) then
        print *,"num_materials_face invalid"
        stop
       endif

       if (update_right_flux.ne.0) then
        print *,"update_right_flux invalid"
        stop
       endif
       if ((scomp.ne.dir).or. &
           (dcomp.ne.1)) then
        print *,"parameters invalid for op=3,10,11,5"
        stop
       endif
       if ((ncomp_dest.ne.1).or. &
           (ncomp_source.ne.1).or. &
           (scomp_bc.ne.dir)) then
        print *,"parameters invalid for op=3"
        stop
       endif

      else if (operation_flag.eq.4) then ! umac->umac

       print *,"op=4 disallowed"
       stop

      else
       print *,"operation_flag invalid20"
       stop
      endif

      nhalf=3

      ii=0
      jj=0
      kk=0
      if (dir.eq.1) then
       ii=1
       if ((i/bfact)*bfact.ne.i) then
        print *,"i invalid"
        stop
       endif
       if (i.lt.0) then
        print *,"i invalid"
        stop
       endif
      else if (dir.eq.2) then
       jj=1
       if ((j/bfact)*bfact.ne.j) then
        print *,"j invalid"
        stop
       endif
       if (j.lt.0) then
        print *,"j invalid"
        stop
       endif
      else if ((dir.eq.3).and.(SDIM.eq.3)) then
       kk=1
       if ((k/bfact)*bfact.ne.k) then
        print *,"k invalid SEM_CELL_TO_MAC"
        stop
       endif
       if (k.lt.0) then
        print *,"k invalid SEM_CELL_TO_MAC"
        stop
       endif
      else
       print *,"dir invalid sem cell to mac2"
       stop
      endif

      do dir2=1,SDIM
       if (fablo(dir2).lt.0) then
        print *,"fablo invalid"
        stop
       endif
      enddo ! dir2

      if ((dir.lt.1).or.(dir.gt.SDIM).or. &
          (bfact.lt.2)) then
       print *,"SEM_CELL_TO_MAC parms corrupt"
       stop
      endif

      if (1.eq.0) then
       if (operation_flag.eq.0) then ! pressure gradient on MAC grid
        if (project_option.eq.10) then
         if (level.eq.3) then
          if ((j.eq.0).and.(i.eq.120).and.(k.eq.18)) then
           print *,"TO_MAC: i,j,k ",i,j,k
           print *,"dir,spectral_loop ",dir,spectral_loop
           print *,"presbc(dir,1) ",presbc_in(dir,1,1)  
           print *,"presbc(dir,2) ",presbc_in(dir,2,1)  
           print *,"maskCF0123 ", &
            maskCF(D_DECL(i-ii,j-jj,k-kk)), &
            maskCF(D_DECL(i,j,k)), &
            maskCF(D_DECL(i+ii,j+jj,k+kk)), &
            maskCF(D_DECL(i+2*ii,j+2*jj,k+2*kk))
           print *,"xcut012 ", &
            xcut(D_DECL(i,j,k)), &
            xcut(D_DECL(i+ii,j+jj,k+kk)), &
            xcut(D_DECL(i+2*ii,j+2*jj,k+2*kk))
           print *,"maskSEM0123 ", &
            maskSEM(D_DECL(i-ii,j-jj,k-kk)), &
            maskSEM(D_DECL(i,j,k)), &
            maskSEM(D_DECL(i+ii,j+jj,k+kk)), &
            maskSEM(D_DECL(i+2*ii,j+2*jj,k+2*kk))
          endif
         endif
        endif
       endif
      endif  ! debugging

       ! local_incomp presently not used.
      local_incomp=0

       ! do nothing unless the strip is a spectral element strip.
      if ((cen_maskSEM.ge.1).and. &
          (cen_maskSEM.le.nmat)) then

       if ((fort_material_type(cen_maskSEM).eq.0).or. &
           (is_rigid(nmat,cen_maskSEM).eq.1).or. &
           (fort_material_type(cen_maskSEM).eq.999).or. &
           (is_FSI_rigid(nmat,cen_maskSEM).eq.1).or. &
           (is_ice(nmat,cen_maskSEM).eq.1)) then
        if (temperature_primitive_variable(cen_maskSEM).ne.1) then
         print *,"temperature_primitive_variable(cen_maskSEM) invalid"
         stop
        endif
        local_incomp=1
       else if ((fort_material_type(cen_maskSEM).gt.0).and. &
                (is_rigid(nmat,cen_maskSEM).eq.0).and. &
                (fort_material_type(cen_maskSEM).ne.999).and. &
                (is_FSI_rigid(nmat,cen_maskSEM).eq.0).and. &
                (is_ice(nmat,cen_maskSEM).eq.0)) then
        if ((temperature_primitive_variable(cen_maskSEM).eq.0).or. &
            (temperature_primitive_variable(cen_maskSEM).eq.1)) then
         ! do nothing
        else
         print *,"temperature_primitive_variable(cen_maskSEM) invalid"
         stop
        endif
       else
        print *,"fort_material_type(cen_maskSEM) or is_rigid invalid"
        stop
       endif

      else if (cen_maskSEM.eq.0) then
       ! do nothing
      else
       print *,"cen_maskSEM invalid sem_cell_to_mac: ",cen_maskSEM
       print *,"i,j,k : ",i,j,k
       stop
      endif

       ! ncomp_dest=SDIM if operation_flag==6  (du/dn, dv/dn, dw/dn)
      do nc=1,ncomp_dest

        ! do nothing if element is not a spectral element
       if ((cen_maskSEM.ge.1).and. &
           (cen_maskSEM.le.nmat)) then

        indexlo(1)=i
        indexlo(2)=j
        if (SDIM.eq.3) then
         indexlo(SDIM)=k
        endif

        do dir2=1,SDIM
         indexhi(dir2)=indexlo(dir2)
        enddo ! dir2
        indexhi(dir)=indexlo(dir)+bfact-1

        strip_outside_fab_flag=0

        cen_outside_domain_flag=0

        do dir2=1,SDIM
 
         side=1
         if (indexlo(dir2).lt.fablo(dir2)) then
          if (dir2.eq.dir) then
           print *,"indexlo(dir) invalid; strip must at least"
           print *,"be alongside a strip that is in the domain"
           stop
          endif

          strip_outside_fab_flag=1

          if (velbc_in(dir2,side,dir2).ne.INT_DIR) then
           cen_outside_domain_flag=1
          endif
         endif

         side=2
         if (indexhi(dir2).gt.fabhi(dir2)) then
          if (dir2.eq.dir) then
           print *,"indexhi(dir) invalid; strip must at least"
           print *,"be alongside a strip that is in the domain"
           stop
          endif

          strip_outside_fab_flag=1

          if (velbc_in(dir2,side,dir2).ne.INT_DIR) then
           cen_outside_domain_flag=1
          endif
         endif

        enddo ! dir2=1..sdim

        if (cen_outside_domain_flag.eq.1) then

         ! do nothing

        else if (cen_outside_domain_flag.eq.0) then

         ibase=num_state_material*(cen_maskSEM-1)
     
         do side=1,2

          nbr_outside_domain_flag(side)=0

          do dir2=1,SDIM
           sideidx(dir2)=indexlo(dir2)
          enddo

          if (side.eq.1) then

           sideidx(dir)=indexlo(dir)-1

           local_maskcov= &
            NINT(maskcov(D_DECL(sideidx(1),sideidx(2),sideidx(SDIM))))
           
           do dir2=1,SDIM
            if (sideidx(dir2).lt.fablo(dir2)) then
             testbc=velbc_in(dir2,side,dir2)
             if ((testbc.eq.INT_DIR).and.(dir2.eq.dir)) then
              local_maskCF= &
               NINT(maskCF(D_DECL(sideidx(1),sideidx(2),sideidx(SDIM))))
              if (local_maskCF.eq.1) then ! fine-fine
               ! do nothing
              else if (local_maskCF.eq.0) then ! fine (current) -coarse
               nbr_outside_domain_flag(side)=-1
              else
               print *,"local_maskCF invalid"
               stop
              endif
             else if ((testbc.eq.INT_DIR).and.(dir2.ne.dir)) then
              nbr_outside_domain_flag(side)=0
              if (operation_flag.eq.6) then
               ! do nothing (we expect this case for grad U)
              else
               print *,"operation_flag invalid"
               stop
              endif
             else if ((testbc.eq.EXT_DIR).or. &
                      (testbc.eq.REFLECT_EVEN).or. &
                      (testbc.eq.REFLECT_ODD).or. &
                      (testbc.eq.FOEXTRAP)) then
              nbr_outside_domain_flag(side)=1
             else
              print *,"testbc invalid"
              stop 
             endif
            else if (sideidx(dir2).ge.fablo(dir2)) then
             if (local_maskcov.eq.1) then
              ! do nothing
             else if (local_maskcov.eq.0) then ! coarse(current) - fine
              nbr_outside_domain_flag(side)=-2
             else
              print *,"local_maskcov invalid"
              stop
             endif
            else
             print *,"sideidx bust"
             stop 
            endif
           enddo ! dir2=1..sdim

           i_out=indexlo(1)-ii
           j_out=indexlo(2)-jj
           k_out=indexlo(SDIM)-kk

           iface_out=indexlo(1)
           jface_out=indexlo(2)
           kface_out=indexlo(SDIM)

          else if (side.eq.2) then

           sideidx(dir)=indexhi(dir)+1

           local_maskcov= &
            NINT(maskcov(D_DECL(sideidx(1),sideidx(2),sideidx(SDIM))))

           do dir2=1,SDIM
            if (sideidx(dir2).gt.fabhi(dir2)) then
             testbc=velbc_in(dir2,side,dir2)
             if ((testbc.eq.INT_DIR).and.(dir2.eq.dir)) then
              local_maskCF= &
               NINT(maskCF(D_DECL(sideidx(1),sideidx(2),sideidx(SDIM))))
              if (local_maskCF.eq.1) then ! fine-fine
               ! do nothing
              else if (local_maskCF.eq.0) then ! fine (current) -coarse
               nbr_outside_domain_flag(side)=-1
              else
               print *,"local_maskCF invalid"
               stop
              endif
             else if ((testbc.eq.INT_DIR).and.(dir2.ne.dir)) then
              nbr_outside_domain_flag(side)=0
              if (operation_flag.eq.6) then
               ! do nothing (we expect this case for grad U)
              else
               print *,"operation_flag invalid"
               stop
              endif
             else if ((testbc.eq.EXT_DIR).or. &
                      (testbc.eq.REFLECT_EVEN).or. &
                      (testbc.eq.REFLECT_ODD).or. &
                      (testbc.eq.FOEXTRAP)) then
              nbr_outside_domain_flag(side)=1
             else
              print *,"testbc invalid"
              stop 
             endif
            else if (sideidx(dir2).le.fabhi(dir2)) then
             if (local_maskcov.eq.1) then
              ! do nothing
             else if (local_maskcov.eq.0) then ! coarse(current) - fine
              nbr_outside_domain_flag(side)=-2
             else
              print *,"local_maskcov invalid"
              stop
             endif
            else
             print *,"sideidx bust"
             stop 
            endif
           enddo ! dir2=1..sdim

           i_out=indexhi(1)+ii
           j_out=indexhi(2)+jj
           k_out=indexhi(SDIM)+kk

           iface_out=i_out
           jface_out=j_out
           kface_out=k_out
          else 
           print *,"side invalid"
           stop
          endif

          call gridsten(xsten,xlo, &
           i_out,j_out,k_out, &
           fablo,bfact,dx,nhalf)

          call gridstenMAC(xsten_face,xlo, &
           iface_out,jface_out,kface_out, &
           fablo,bfact,dx,nhalf,dir)

           ! fine-fine boundary or element properly contained in grid.
          if (nbr_outside_domain_flag(side).eq.0) then

           local_bctype(side)=0 ! interior

           local_bcval(side)=zero
            
           ic=i_out
           jc=j_out
           kc=k_out

           if (operation_flag.eq.7) then ! advection (values outside elem)

            denlocal=den(D_DECL(ic,jc,kc),ibase+1)
            templocal=den(D_DECL(ic,jc,kc),ibase+2)

            if ((nc.ge.1).and.(nc.le.SDIM)) then
             if (num_materials_vel.ne.1) then
              print *,"num_materials_vel invalid"
              stop
             endif
             if (num_materials_face.ne.1) then
              print *,"num_materials_face invalid"
              stop
             endif
             velcomp=nc
             ! u_{i+1/2}S_{i+1/2}-u_{i-1/2}S_{i-1/2}=
             ! (S_{i+1/2}+S_{i-1/2})(u_{i+1/2}-u_{i-1/2})/2 +
             ! (u_{i+1/2}+u_{i-1/2})(S_{i+1/2}-S_{i-1/2})/2
             ! u dot grad u = div(umac u)-I(umac) div umac
             if ((conservative_div_uu.eq.0).or. &
                 (conservative_div_uu.eq.1).or. &
                 (conservative_div_uu.eq.2)) then
              local_data_side(side)= &
               vel(D_DECL(ic,jc,kc),velcomp) ! NONCONSERVATIVE
             else
              print *,"conservative_div_uu invalid"
              stop
             endif

             ! I(umac) dot grad rho
            else if (nc.eq.SDIM+1) then ! density: NONCONSERVATIVE
             local_data_side(side)=denlocal

             ! I(umac) dot grad T
            else if (nc.eq.SDIM+2) then 
             local_data_side(side)=templocal ! temperature: NONCONSERVATIVE
            else
             print *,"nc invalid"
             stop
            endif

           else if (operation_flag.eq.6) then ! tensor derivatives

            if (num_materials_vel.ne.1) then
             print *,"num_materials_vel invalid"
             stop
            endif

            if ((nc.ge.1).and.(nc.le.SDIM)) then
             velcomp=nc
             local_data_side(side)=vel(D_DECL(ic,jc,kc),velcomp)
            else
             print *,"nc invalid"
             stop
            endif

           else if (operation_flag.eq.0) then ! MAC pressure gradient
            if (nc.eq.1) then
             if ((scomp.eq.1).or.(scomp.eq.cen_maskSEM)) then
              prescomp=scomp
              local_data_side(side)=pres(D_DECL(ic,jc,kc),prescomp)
             else
              print *,"scomp invalid"
              stop
             endif
            else
             print *,"nc invalid"
             stop
            endif
           else if (operation_flag.eq.1) then ! MAC pressure 
            if (nc.eq.1) then
             if (scomp.eq.1) then
              prescomp=scomp
              local_data_side(side)=pres(D_DECL(ic,jc,kc),prescomp)
             else
              print *,"scomp invalid"
              stop
             endif
            else
             print *,"nc invalid"
             stop
            endif
           else if (operation_flag.eq.2) then ! MAC potential grad, ppot^MAC
            if (nc.eq.1) then
             if (scomp.eq.1) then
              local_data_side(side)=pres(D_DECL(ic,jc,kc),1)
              local_data_side_den(side)=den(D_DECL(ic,jc,kc),1)
              if ((abs(local_data_side(side)).lt.1.0D+20).and. &
                  (local_data_side_den(side).gt.zero).and. &
                  (abs(local_data_side_den(side)).lt.1.0D+20)) then
               ! do nothing
              else
               print *,"local_data_side or local_data_side_den invalid"
               stop
              endif
             else
              print *,"scomp invalid"
              stop
             endif
            else
             print *,"nc invalid"
             stop
            endif
           else if (operation_flag.eq.9) then ! den: CELL->MAC
            if (nc.eq.1) then
             if (scomp.eq.(cen_maskSEM-1)*num_state_material+1) then
              local_data_side(side)=den(D_DECL(ic,jc,kc),scomp)
              if ((local_data_side(side).gt.zero).and. &
                  (abs(local_data_side(side)).lt.1.0D+20)) then
               ! do nothing
              else
               print *,"local_data_side invalid"
               stop
              endif
             else
              print *,"scomp invalid"
              stop
             endif
            else
             print *,"nc invalid"
             stop
            endif
           else if ((operation_flag.eq.3).or. & !unew^CELL->MAC
                    (operation_flag.eq.10).or. &!unew^MAC,CELL->MAC
                    (operation_flag.eq.11).or. &!unew^MAC,CELL DIFF->MAC
                    (operation_flag.eq.5)) then !umac=umac+beta diff^CELL->MAC
            if (nc.eq.1) then
             if (scomp.eq.dir) then
              local_data_side(side)=vel(D_DECL(ic,jc,kc),scomp)
             else
              print *,"scomp invalid"
              stop
             endif
            else
             print *,"nc invalid"
             stop
            endif
           else
            print *,"operation_flag invalid21"
            stop
           endif

           ! element touches the domain wall
          else if (nbr_outside_domain_flag(side).eq.1) then 

           local_data_side(side)=zero

           if (velbc_in(dir,side,dir).eq.INT_DIR) then
            print *,"velbc_in bust "
            print *,"cen_outside_domain_flag= ",cen_outside_domain_flag
            print *,"nbr_outside_domain_flag= ",nbr_outside_domain_flag(side)
            stop
           endif

           if (operation_flag.eq.6) then ! grad U

            if (velbc_in(dir,side,nc).eq.REFLECT_EVEN) then
             local_bctype(side)=3 ! reflect even
             local_bcval(side)=zero
            else if (velbc_in(dir,side,nc).eq.FOEXTRAP) then
             local_bctype(side)=2 ! neumann
             local_bcval(side)=zero
            else if (velbc_in(dir,side,nc).eq.REFLECT_ODD) then
             local_bctype(side)=4
             local_bcval(side)=zero
            else if (velbc_in(dir,side,nc).eq.EXT_DIR) then
             local_bctype(side)=1 ! dirichlet

             if (num_materials_face.ne.1) then
              print *,"num_materials_face invalid"
              stop
             endif

             velcomp=nc
             local_bcval(side)=vel(D_DECL(i_out,j_out,k_out),velcomp)
            else
             print *,"velbc_in is corrupt"
             stop
            endif

           else if ((operation_flag.eq.3).or. & ! U cell to MAC
                    (operation_flag.eq.10).or. & ! U MAC,cell to MAC
                    (operation_flag.eq.11).or. & ! U MAC,cell diff to MAC
                    (operation_flag.eq.5)) then ! UMAC=UMAC+(U cell to MAC)

            if (velbc_in(dir,side,scomp_bc).eq.REFLECT_EVEN) then
             local_bctype(side)=3 ! reflect even
             local_bcval(side)=zero
            else if (velbc_in(dir,side,scomp_bc).eq.FOEXTRAP) then
             local_bctype(side)=2 ! neumann
             local_bcval(side)=zero
            else if (velbc_in(dir,side,scomp_bc).eq.REFLECT_ODD) then
             local_bctype(side)=4
             local_bcval(side)=zero
            else if (velbc_in(dir,side,scomp_bc).eq.EXT_DIR) then
             local_bctype(side)=1 ! dirichlet
             velcomp=scomp
             local_bcval(side)=vel(D_DECL(i_out,j_out,k_out),velcomp)
            else
             print *,"velbc_in is corrupt"
             stop
            endif

           else if (operation_flag.eq.7) then ! advection (bc's)

             ! normal points out of the computational domain.
            if (side.eq.1) then
             udotn_boundary=-vel(D_DECL(i_out,j_out,k_out),dir)
            else if (side.eq.2) then
             udotn_boundary=vel(D_DECL(i_out,j_out,k_out),dir)
            else
             print *,"side invalid"
             stop
            endif

            if ((nc.ge.1).and.(nc.le.SDIM)) then ! velocity

             if (velbc_in(dir,side,nc).eq.REFLECT_EVEN) then
              local_bctype(side)=3 ! reflect
              local_bcval(side)=zero
             else if (velbc_in(dir,side,nc).eq.FOEXTRAP) then
              local_bctype(side)=2 ! neumann
              local_bcval(side)=zero
             else if (velbc_in(dir,side,nc).eq.REFLECT_ODD) then
              local_bctype(side)=4
              local_bcval(side)=zero
             else if (velbc_in(dir,side,nc).eq.EXT_DIR) then

               ! normal points out of the computational domain.
               ! udotn<0 => characteristics enter into the domain.
              if (udotn_boundary.lt.zero) then
               local_bctype(side)=1 ! dirichlet
               denlocal=den(D_DECL(i_out,j_out,k_out),ibase+1)

               if (num_materials_vel.ne.1) then
                print *,"num_materials_vel invalid"
                stop
               endif

               velcomp=nc
               if ((conservative_div_uu.eq.0).or. &
                   (conservative_div_uu.eq.1).or. &
                   (conservative_div_uu.eq.2)) then
                local_bcval(side)= &
                 vel(D_DECL(i_out,j_out,k_out),velcomp) !NONCONSERVATIVE
               else
                print *,"conservative_div_uu invalid"
                stop
               endif
              else if (udotn_boundary.ge.zero) then
               local_bctype(side)=2 ! neumann
               local_bcval(side)=zero
              else
               print *,"udotn_boundary invalid"
               stop
              endif

             else
              print *,"velbc_in is corrupt"
              stop
             endif

            else if (nc.eq.SDIM+1) then ! density

             if (presbc_in(dir,side,ibase+1).eq.REFLECT_EVEN) then
              local_bctype(side)=3 ! reflect even
              local_bcval(side)=zero 
             else if (presbc_in(dir,side,ibase+1).eq.FOEXTRAP) then
              local_bctype(side)=2 ! neumann
              local_bcval(side)=zero 
             else if (presbc_in(dir,side,ibase+1).eq.REFLECT_ODD) then
              print *,"cannot have reflect odd BC for density"
              stop
              local_bctype(side)=4
              local_bcval(side)=zero 
             else if (presbc_in(dir,side,ibase+1).eq.EXT_DIR) then
              if (udotn_boundary.lt.zero) then
               denlocal=den(D_DECL(i_out,j_out,k_out),ibase+1)
               local_bctype(side)=1 ! dirichlet
               local_bcval(side)=denlocal
              else if (udotn_boundary.ge.zero) then
               local_bctype(side)=2 ! neumann
               local_bcval(side)=zero
              else
               print *,"udotn_boundary invalid"
               stop
              endif
             else
              print *,"presbc_in is corrupt"
              stop
             endif

            else if (nc.eq.SDIM+2) then ! energy: NONCONSERVATIVE

             if (presbc_in(dir,side,ibase+2).eq.REFLECT_EVEN) then
              local_bctype(side)=3 ! reflect even
              local_bcval(side)=zero 
             else if (presbc_in(dir,side,ibase+2).eq.FOEXTRAP) then
              local_bctype(side)=2 ! neumann
              local_bcval(side)=zero 
             else if (presbc_in(dir,side,ibase+2).eq.REFLECT_ODD) then
              print *,"cannot have reflect odd BC for temperature"
              stop
              local_bctype(side)=4
              local_bcval(side)=zero 
             else if (presbc_in(dir,side,ibase+2).eq.EXT_DIR) then
              if (udotn_boundary.lt.zero) then
               templocal=den(D_DECL(i_out,j_out,k_out),ibase+2)
               local_bctype(side)=1 ! dirichlet
               local_bcval(side)=templocal
              else if (udotn_boundary.ge.zero) then
               local_bctype(side)=2 ! neumann
               local_bcval(side)=zero
              else
               print *,"udotn_boundary invalid"
               stop
              endif
             else
              print *,"presbc_in is corrupt"
              stop
             endif
            else
             print *,"nc invalid"
             stop
            endif

           else if (operation_flag.eq.9) then ! den: CELL->MAC

            if (nc.eq.1) then 

             if (presbc_in(dir,side,1).eq.REFLECT_EVEN) then
              local_bctype(side)=3 ! reflect even
              local_bcval(side)=zero 
             else if (presbc_in(dir,side,1).eq.FOEXTRAP) then
              local_bctype(side)=2 ! neumann
              local_bcval(side)=zero 
             else if (presbc_in(dir,side,1).eq.REFLECT_ODD) then
              local_bctype(side)=4
              local_bcval(side)=zero 
              print *,"cannot have reflect odd conditions for density"
              stop
             else if (presbc_in(dir,side,1).eq.EXT_DIR) then
              if (scomp.eq.(cen_maskSEM-1)*num_state_material+1) then
               denlocal=den(D_DECL(i_out,j_out,k_out),scomp)
              else
               print *,"scomp invalid"
               stop
              endif
              local_bctype(side)=1 ! dirichlet
              local_bcval(side)=denlocal
              if (denlocal.le.zero) then
               print *,"denlocal invalid"
               stop
              endif
             else
              print *,"presbc_in is corrupt"
              stop
             endif

            else
             print *,"nc invalid"
             stop
            endif

           else if ((operation_flag.eq.0).or. & ! pressure grad on MAC
                    (operation_flag.eq.1).or. & ! interp pressure to MAC
                    (operation_flag.eq.2)) then ! potential grad and value

            if (presbc_in(dir,side,1).eq.REFLECT_EVEN) then
             local_bctype(side)=3 ! reflect even
             local_bcval(side)=zero
            else if (presbc_in(dir,side,1).eq.FOEXTRAP) then
             local_bctype(side)=2 ! neumann
             local_bcval(side)=zero
            else if (presbc_in(dir,side,1).eq.EXT_DIR) then
             local_bctype(side)=1 ! dirichlet
             prescomp=scomp
             local_bcval(side)=pres(D_DECL(i_out,j_out,k_out),prescomp)
            else
             print *,"presbc_in is corrupt"
             stop
            endif
           else
            print *,"operation_flag invalid22"
            stop
           endif

           ! -1=fine(current) next to coarse
           ! -2=coarse(current) next to fine
          else if ((nbr_outside_domain_flag(side).eq.-1).or. &
                   (nbr_outside_domain_flag(side).eq.-2)) then

           local_bctype(side)=0 ! interior (default)
           local_bcval(side)=zero
           ic=i_out
           jc=j_out
           kc=k_out
                
            ! fine(current) next to coarse 
           if (nbr_outside_domain_flag(side).eq.-1) then 
            bctype_tag=-3
            if (level.ge.1) then
             if (side.eq.1) then
              icoarse=(sideidx(1)-1)/2
              jcoarse=(sideidx(2)-1)/2
              kcoarse=(sideidx(SDIM)-1)/2
             else if (side.eq.2) then
              icoarse=sideidx(1)/2
              jcoarse=sideidx(2)/2
              kcoarse=sideidx(SDIM)/2
             else
              print *,"side invalid"
              stop
             endif
            
             call gridsten(xsten_coarse,problo, &
              icoarse,jcoarse,kcoarse, &
              domlo,bfact_c,dx_c,nhalf)

             if (side.eq.1) then
              x_sep(side)=two*(xsten_face(0,dir)-xsten_coarse(0,dir))/ &
               (dx(dir)*bfact)
              if ((x_sep(side).le.zero).or. &
                  (x_sep(side).ge.two)) then
               print *,"x_sep(side) invalid"
               stop
              endif
             else if (side.eq.2) then
              x_sep(side)=two*(xsten_coarse(0,dir)-xsten_face(0,dir))/ &
               (dx(dir)*bfact)
              if ((x_sep(side).le.zero).or. &
                  (x_sep(side).ge.two)) then
               print *,"x_sep(side) invalid"
               stop
              endif
             else
              print *,"side invalid"
              stop
             endif
            else
             print *,"level invalid 44"
             print *,"level=",level
             print *,"side=",side
             print *,"operation_flag=",operation_flag
             print *,"finest_level=",finest_level
             print *,"dir=",dir
             stop
            endif
             
             ! coarse(current) next to fine
           else if (nbr_outside_domain_flag(side).eq.-2) then
            bctype_tag=-2
            if (level.lt.finest_level) then
             if (side.eq.1) then
              ifine=2*sideidx(1)+1
              jfine=2*sideidx(2)+1
              kfine=2*sideidx(SDIM)+1
             else if (side.eq.2) then
              ifine=2*sideidx(1)
              jfine=2*sideidx(2)
              kfine=2*sideidx(SDIM)
             else
              print *,"side invalid"
              stop
             endif
            
             call gridsten(xsten_fine,problo, &
              ifine,jfine,kfine, &
              domlo,bfact_f,dx_f,nhalf)

             if (side.eq.1) then
              x_sep(side)=two*(xsten_face(0,dir)-xsten_fine(0,dir))/ &
               (dx(dir)*bfact)
              if ((x_sep(side).le.zero).or. &
                  (x_sep(side).ge.half)) then
               print *,"x_sep(side) invalid"
               stop
              endif
             else if (side.eq.2) then
              x_sep(side)=two*(xsten_fine(0,dir)-xsten_face(0,dir))/ &
               (dx(dir)*bfact)
              if ((x_sep(side).le.zero).or. &
                  (x_sep(side).ge.half)) then
               print *,"x_sep(side) invalid"
               stop
              endif
             else
              print *,"side invalid"
              stop
             endif
            else
             print *,"level invalid 45"
             stop
            endif

           else
            print *,"nbr_outside_domain_flag invalid 2"
            stop
           endif

           if (operation_flag.eq.7) then ! advection

            if (simple_AMR_BC_flag.eq.0) then
             local_bctype(side)=bctype_tag
             denlocal=xp(D_DECL(iface_out,jface_out,kface_out),SDIM+1)
             templocal=xp(D_DECL(iface_out,jface_out,kface_out),SDIM+2)

             if ((nc.ge.1).and.(nc.le.SDIM)) then
              if (num_materials_vel.ne.1) then
               print *,"num_materials_vel invalid"
               stop
              endif
              if (num_materials_face.ne.1) then
               print *,"num_materials_face invalid"
               stop
              endif
              velcomp=nc
              if ((conservative_div_uu.eq.0).or. &
                  (conservative_div_uu.eq.1).or. &
                  (conservative_div_uu.eq.2)) then
               local_data_side(side)= &
                xp(D_DECL(iface_out,jface_out,kface_out),velcomp)
              else
               print *,"conservative_div_uu invalid"
               stop
              endif
             else if (nc.eq.SDIM+1) then ! density: NONCONSERVATIVE
              local_data_side(side)=denlocal
             else if (nc.eq.SDIM+2) then ! temperature: NONCONSERVATIVE
              local_data_side(side)=templocal
             else
              print *,"nc invalid"
              stop
             endif
            else if (simple_AMR_BC_flag.eq.1) then

             denlocal=den(D_DECL(ic,jc,kc),ibase+1)
             templocal=den(D_DECL(ic,jc,kc),ibase+2)

             if ((nc.ge.1).and.(nc.le.SDIM)) then
              if (num_materials_vel.ne.1) then
               print *,"num_materials_vel invalid"
               stop
              endif
              if (num_materials_face.ne.1) then
               print *,"num_materials_face invalid"
               stop
              endif
              velcomp=nc
              local_data_side(side)= &
               vel(D_DECL(ic,jc,kc),velcomp) ! NONCONSERVATIVE
             else if (nc.eq.SDIM+1) then ! density: NONCONSERVATIVE
              local_data_side(side)=denlocal
             else if (nc.eq.SDIM+2) then ! temperature: NONCONSERVATIVE
              local_data_side(side)=templocal
             else
              print *,"nc invalid"
              stop
             endif

            else
             print *,"simple_AMR_BC_flag invalid"
             stop
            endif

            if ((abs(local_data_side(side)).lt.1.0D+20).and. &
                (abs(denlocal).lt.1.0D+20).and. &
                (abs(templocal).lt.1.0D+20)) then
             ! do nothing
            else
             print *,"data overflow SEM nc=",nc
             print *,"local_data_side(side)=",local_data_side(side)
             print *,"denlocal=",denlocal
             print *,"templocal=",templocal
             print *,"DeDT=",DeDT
             print *,"side=",side
             print *,"simple_AMR_BC_flag=",simple_AMR_BC_flag
             print *,"local_bctype(side) ",local_bctype(side)
             print *,"iface_out,jface_out,kface_out ", &
                iface_out,jface_out,kface_out
             print *,"ic,jc,kc ",ic,jc,kc
             print *,"level ",level
             print *,"finest_level ",finest_level
             print *,"bfact,bfact_c,bfact_f ",bfact,bfact_c,bfact_f
             print *,"den(D_DECL(ic,jc,kc),ibase+1) ", &
               den(D_DECL(ic,jc,kc),ibase+1)
             print *,"den(D_DECL(ic,jc,kc),ibase+2) ", &
               den(D_DECL(ic,jc,kc),ibase+2)
             print *,"ibase= ",ibase
             print *,"cen_maskSEM= ",cen_maskSEM
             stop
            endif

           else if (operation_flag.eq.6) then ! tensor derivatives

            if (num_materials_vel.ne.1) then
             print *,"num_materials_vel invalid"
             stop
            endif

            local_AMR_BC_flag=simple_AMR_BC_flag

            if (cen_outside_domain_flag.eq.0) then

             if (strip_outside_fab_flag.eq.0) then
              ! do nothing
             else if (strip_outside_fab_flag.eq.1) then
              local_AMR_BC_flag=1
             else
              print *,"strip_outside_fab_flag invalid"
              stop
             endif

            else 
             print *,"cen_outside_domain_flag invalid"
             stop
            endif

            if (local_AMR_BC_flag.eq.0) then
             local_bctype(side)=bctype_tag
             if ((nc.ge.1).and.(nc.le.SDIM)) then
              velcomp=nc
              local_data_side(side)= &
               xp(D_DECL(iface_out,jface_out,kface_out),velcomp)
             else
              print *,"nc invalid"
              stop
             endif
            else if (local_AMR_BC_flag.eq.1) then
             if ((nc.ge.1).and.(nc.le.SDIM)) then
              velcomp=nc
              local_data_side(side)=vel(D_DECL(ic,jc,kc),velcomp)
             else
              print *,"nc invalid"
              stop
             endif
            else
             print *,"local_AMR_BC_flag invalid"
             stop
            endif

           else if (operation_flag.eq.0) then ! MAC pressure gradient

            if (simple_AMR_BC_flag.eq.0) then
             local_bctype(side)=bctype_tag
             if (nc.eq.1) then
              if ((scomp.eq.1).or.(scomp.eq.cen_maskSEM)) then
               local_data_side(side)= &
                xp(D_DECL(iface_out,jface_out,kface_out),scomp)
              else
               print *,"scomp invalid"
               stop
              endif
             else
              print *,"nc invalid"
              stop
             endif
            else if (simple_AMR_BC_flag.eq.1) then
             if (nc.eq.1) then
              if ((scomp.eq.1).or.(scomp.eq.cen_maskSEM)) then
               prescomp=scomp
               local_data_side(side)=pres(D_DECL(ic,jc,kc),prescomp)
              else
               print *,"scomp invalid"
               stop
              endif
             else
              print *,"nc invalid"
              stop
             endif
            else
             print *,"simple_AMR_BC_flag invalid"
             stop
            endif
           else if (operation_flag.eq.1) then ! MAC pressure 

            if (simple_AMR_BC_flag.eq.0) then
             local_bctype(side)=bctype_tag
             if (nc.eq.1) then
              if (dcomp.eq.3) then
               local_data_side(side)= &
                xgp(D_DECL(iface_out,jface_out,kface_out),nc) 
               if (abs(local_data_side(side)).lt.1.0D+20) then
                ! do nothing
               else
                print *,"SEM data overflow"
                stop
               endif
              else
               print *,"dcomp invalid"
               stop
              endif
             else
              print *,"nc invalid"
              stop
             endif
            else if (simple_AMR_BC_flag.eq.1) then
             if (nc.eq.1) then
              if (scomp.eq.1) then
               prescomp=scomp
               local_data_side(side)=pres(D_DECL(ic,jc,kc),prescomp)
              else
               print *,"scomp invalid"
               stop
              endif
             else
              print *,"nc invalid"
              stop
             endif
            else
             print *,"simple_AMR_BC_flag invalid"
             stop
            endif

            if (abs(local_data_side(side)).lt.1.0D+20) then
             ! do nothing
            else
             print *,"SEM data overflow"
             stop
            endif

           else if (operation_flag.eq.2) then ! MAC potential grad,ppot^MAC

            if (simple_AMR_BC_flag.eq.1) then

             if (nc.eq.1) then
              if (scomp.eq.1) then
               prescomp=scomp
               local_data_side(side)=pres(D_DECL(ic,jc,kc),prescomp)
               local_data_side_den(side)=den(D_DECL(ic,jc,kc),1)
              else
               print *,"scomp invalid"
               stop
              endif
             else
              print *,"nc invalid"
              stop
             endif

            else
             print *,"simple_AMR_BC_flag invalid"
             stop
            endif

            if ((abs(local_data_side(side)).lt.1.0D+20).and. &
                (local_data_side_den(side).gt.zero).and. &
                (abs(local_data_side_den(side)).lt.1.0D+20)) then
             ! do nothing
            else
             print *,"local_data_side or local_data_side_den invalid"
             stop
            endif

           else if (operation_flag.eq.9) then ! den: CELL->MAC
            if (simple_AMR_BC_flag.eq.0) then
             local_bctype(side)=bctype_tag
             if (nc.eq.1) then
              if (dcomp.eq.1) then
               local_data_side(side)= &
                xp(D_DECL(iface_out,jface_out,kface_out),dcomp)
              else
               print *,"dcomp invalid"
               stop
              endif
             else if (simple_AMR_BC_flag.eq.1) then
              if (nc.eq.1) then
               if (scomp.eq.(cen_maskSEM-1)*num_state_material+1) then
                local_data_side(side)=den(D_DECL(ic,jc,kc),scomp)
               else
                print *,"scomp invalid"
                stop
               endif
              else
               print *,"nc invalid"
               stop
              endif
             else
              print *,"simple_AMR_BC_flag invalid"
              stop
             endif

             if ((local_data_side(side).gt.zero).and. &
                 (abs(local_data_side(side)).lt.1.0D+20)) then
              ! do nothing
             else
              print *,"local_data_side invalid"
              stop
             endif
            else
             print *,"nc invalid"
             stop
            endif
           else if ((operation_flag.eq.3).or. & !unew^CELL->MAC
                    (operation_flag.eq.10).or. &!unew^MAC,CELL->MAC
                    (operation_flag.eq.11).or. &!unew^MAC,CELL DIFF->MAC
                    (operation_flag.eq.5)) then !umac=umac+beta diff^CELL->MAC
            if (simple_AMR_BC_flag.eq.0) then
             local_bctype(side)=bctype_tag
             if (nc.eq.1) then
              if (scomp.eq.dir) then
               ! AMRSYNC_VEL_MF passed in as xp
               local_data_side(side)= &
                xp(D_DECL(iface_out,jface_out,kface_out),1)
              else
               print *,"scomp invalid"
               stop
              endif
             else
              print *,"nc invalid"
              stop
             endif
            else if (simple_AMR_BC_flag.eq.1) then
             if (nc.eq.1) then
              if (scomp.eq.dir) then
               local_data_side(side)=vel(D_DECL(ic,jc,kc),scomp)
              else
               print *,"scomp invalid"
               stop
              endif
             else
              print *,"nc invalid"
              stop
             endif
            else
             print *,"simple_AMR_BC_flag invalid"
             stop
            endif
            if (abs(local_data_side(side)).lt.1.0D+20) then
             ! do nothing
            else
             print *,"SEM data overflow"
             stop
            endif

           else
            print *,"operation_flag invalid21"
            stop
           endif

          else
           print *,"nbr_outside_domain_flag invalid 3"
           stop
          endif

         enddo ! side=1..2

         do isten=0,bfact-1

          do dir2=1,SDIM
           indexmid(dir2)=indexlo(dir2)
          enddo
          indexmid(dir)=indexlo(dir)+isten

          ic=indexmid(1)
          jc=indexmid(2)
          kc=indexmid(SDIM)

          call gridsten(xsten,xlo, &
           ic,jc,kc, &
           fablo,bfact,dx,nhalf)

          if (operation_flag.eq.6) then ! face grad U

           if ((nc.ge.1).and.(nc.le.SDIM)) then

            if (num_materials_vel.ne.1) then
             print *,"num_materials_vel.ne.1"
             stop
            endif

            velcomp=nc
            local_data(isten+1)=vel(D_DECL(ic,jc,kc),velcomp)
           else
            print *,"nc invalid"
            stop
           endif

          else if ((operation_flag.eq.3).or. & !unew^CELL->MAC
                   (operation_flag.eq.10).or. &!unew^MAC,CELL->MAC
                   (operation_flag.eq.11).or. &!unew^MAC,CELL DIFF->MAC
                   (operation_flag.eq.5)) then !umac=umac+beta diff^CELL->MAC

           if (nc.eq.1) then
            if (scomp.eq.dir) then
             local_data(isten+1)=vel(D_DECL(ic,jc,kc),scomp)
            else
             print *,"scomp invalid"
             stop
            endif
           else
            print *,"nc invalid"
            stop
           endif
         
          else if (operation_flag.eq.0) then ! pressure grad on MAC

           if (nc.eq.1) then
            prescomp=scomp
            local_data(isten+1)=pres(D_DECL(ic,jc,kc),prescomp)
           else
            print *,"nc invalid"
            stop
           endif

          else if (operation_flag.eq.1) then ! interp pressure to MAC

           if (nc.eq.1) then
            prescomp=scomp
            local_data(isten+1)=pres(D_DECL(ic,jc,kc),prescomp)
           else
            print *,"nc invalid"
            stop
           endif

          else if (operation_flag.eq.2) then !potential grad/den and value

           if (nc.eq.1) then
            local_data(isten+1)=pres(D_DECL(ic,jc,kc),1)
            local_data_den(isten+1)=den(D_DECL(ic,jc,kc),1)
           else
            print *,"nc invalid"
            stop
           endif

          else if (operation_flag.eq.9) then !den: cell->mac

           if (nc.eq.1) then
            if (scomp.eq.(cen_maskSEM-1)*num_state_material+1) then
             local_data(isten+1)=den(D_DECL(ic,jc,kc),scomp)
             if ((local_data(isten+1).gt.zero).and. &
                 (abs(local_data(isten+1)).lt.1.0D+20)) then
              ! do nothing
             else
              print *,"local_data invalid"
              stop
             endif
            else
             print *,"scomp invalid"
             stop
            endif
           else
            print *,"nc invalid"
            stop
           endif

          else if (operation_flag.eq.7) then ! advection (values inside elem)

           denlocal=den(D_DECL(ic,jc,kc),ibase+1)
           templocal=den(D_DECL(ic,jc,kc),ibase+2)

            ! u dot grad u = div(umac u)-u div umac
           if ((nc.ge.1).and.(nc.le.SDIM)) then ! velocity

            if (num_materials_vel.ne.1) then
             print *,"num_materials_vel invalid"
             stop
            endif
            velcomp=nc

            if ((conservative_div_uu.eq.0).or. &
                (conservative_div_uu.eq.1).or. &
                (conservative_div_uu.eq.2)) then
             local_data(isten+1)= &
              vel(D_DECL(ic,jc,kc),velcomp) !NONCONSERVATIVE
            else
             print *,"conservative_div_uu invalid"
             stop
            endif

           else if (nc.eq.SDIM+1) then ! density: NONCONSERVATIVE

            local_data(isten+1)=denlocal

           else if (nc.eq.SDIM+2) then ! temperature: NONCONSERVATIVE

            local_data(isten+1)=templocal

           else
            print *,"nc invalid"
            stop
           endif

          else
           print *,"operation_flag invalid23"
           stop
          endif
         enddo ! isten=0..bfact-1

         do isten=0,bfact
          indexmid(dir)=indexlo(dir)+isten
          ic=indexmid(1)
          jc=indexmid(2)
          kc=indexmid(SDIM)

          call gridstenMAC(xsten,xlo, &
           ic,jc,kc, &
           fablo,bfact,dx,nhalf,dir)

          RRface(isten)=xsten(0,1)

          if (num_materials_vel.eq.1) then
           velcomp=1
          else
           print *,"num_materials_vel invalid"
           stop
          endif

          local_vel(isten)=xvel(D_DECL(ic,jc,kc),velcomp)
         enddo ! isten=0..bfact

         if (spectral_loop.eq.0) then

          ! if operation_flag.eq.7 (advection),
          ! then velocity flux might be multiplied by umac (local_vel) in
          ! lineGRAD (not density and temperature though).
          ! u u_x + v u_y + w u_z = (u umac)_x + (u vmac)_y + (u wmac)_z -
          !                         u umac_x - u vmac_y - u wmac_z
          call lineGRAD( &
           conservative_div_uu, &
           levelrz, &
           dir, &
           nc, &
           RRface, &
           local_bctype, &
           local_bcval, &
           local_vel, &
           local_data,local_data_side,  &
           local_grad,local_interp, &
           bfact, &
           dx(dir), &
           x_sep, &
           operation_flag)

          if (operation_flag.eq.2) then !need den. for potential gradient term

           do side=1,2
            local_bcval_den(side)=one  ! will not be used since "extrap" bc.
            local_bctype_den(side)=local_bctype(side)
            if (local_bctype_den(side).ne.0) then
             local_bctype_den(side)=-1 ! extrap
            endif
           enddo
           call lineGRAD( &
            conservative_div_uu, &
            levelrz, &
            dir, &
            nc, &
            RRface, &
            local_bctype_den, &
            local_bcval_den, &
            local_vel, &
            local_data_den,local_data_side_den, &
            local_grad_den,local_interp_den, &
            bfact, &
            dx(dir), &
            x_sep, &
            operation_flag)

          else if ((operation_flag.ge.0).and. &
                   (operation_flag.le.11)) then
           ! do nothing
          else
           print *,"operation_flag invalid24"
           stop
          endif

         else if (spectral_loop.eq.1) then
          ! do nothing
         else
          print *,"spectral_loop invalid"
          stop
         endif

         do isten=0,bfact

          ! prevent race condition if tiling
          ! if two "pure" elements are neighbors and separate tiles, then we
          ! update the left most flux of each element.  The right
          ! most flux on the right most tile can be updated too.
          shared_face=0

          indexlo(1)=i
          indexlo(2)=j
          if (SDIM.eq.3) then
           indexlo(SDIM)=k
          endif

          do dir2=1,SDIM
           indexmid(dir2)=indexlo(dir2)
          enddo ! dir2
          indexmid(dir)=indexlo(dir)+isten ! isten=0..bfact

          ic=indexmid(1)
          jc=indexmid(2)
          kc=indexmid(SDIM)

          do dir2=1,SDIM
           index_edge(dir2)=indexmid(dir2)
           index_opp(dir2)=indexmid(dir2)
          enddo

          side=0

          if (isten.eq.0) then ! left most GL node

           side=1
           index_edge(dir)=indexlo(dir) ! left most G node
           index_opp(dir)=index_edge(dir)-1 ! right most G node of left elem.

          else if (isten.eq.bfact) then  ! right most GL node

           side=2
           index_edge(dir)=indexlo(dir)+bfact-1 ! right most G node
           index_opp(dir)=index_edge(dir)+1 ! left most G node of right elem.

          else if ((isten.ge.1).and.(isten.lt.bfact)) then
           ! do nothing
          else
           print *,"isten invalid isten=",isten
           stop
          endif

          i_in=index_edge(1)
          j_in=index_edge(2)
          k_in=index_edge(SDIM)
   
          i_out=index_opp(1)
          j_out=index_opp(2)
          k_out=index_opp(SDIM)

          test_maskSEM=NINT(maskSEM(D_DECL(i_out,j_out,k_out)))
          local_maskcov=NINT(maskcov(D_DECL(i_out,j_out,k_out)))

          if (side.eq.2) then ! right side of the element

           if ((index_edge(dir).ge.fablo(dir)).and. & !can conflict w/rt nbr.
               (index_edge(dir).lt.fabhi(dir)).and. &
               (test_maskSEM.eq.cen_maskSEM).and. &
               (local_maskcov.eq.1)) then
            shared_face=1
           else if ((index_edge(dir).eq.fabhi(dir)).or. &
                    (test_maskSEM.ne.cen_maskSEM).or. & !neighbor elem low ord?
                    (local_maskcov.eq.0)) then ! neighbor elem covered?
            ! do nothing
           else
            print *,"index_edge,test_maskSEM, or local_maskcov invalid"
            stop
           endif

          else if (side.eq.1) then
           ! do nothing (left side of element)
          else if (side.eq.0) then
           ! do nothing
          else
           print *,"side invalid"
           stop
          endif

          mask_out=1

          if (operation_flag.eq.7) then ! advection
           do dir2=1,SDIM
            if (dir2.ne.dir) then
             if ((index_opp(dir2).lt.fablo(dir2)).or. &
                 (index_opp(dir2).gt.fabhi(dir2))) then
              print *,"index_opp invalid"
              stop
             endif
            else if (dir2.eq.dir) then
             if ((index_opp(dir2).lt.fablo(dir2)-1).or. &
                 (index_opp(dir2).gt.fabhi(dir2)+1)) then
              print *,"index_opp invalid"
              stop
             endif
            else
             print *,"dir2 invalid"
             stop
            endif
           enddo ! dir2=1..sdim
           if (index_opp(dir).eq.fablo(dir)-1) then
            if (side.eq.1) then
             if (nbr_outside_domain_flag(side).eq.1) then
              mask_out=0
             else if (nbr_outside_domain_flag(side).eq.0) then
              ! do nothing (fine next to fine)
             else if (nbr_outside_domain_flag(side).eq.-1) then
              ! do nothing (fine(current) next to coarse)
             else if (nbr_outside_domain_flag(side).eq.-2) then
              ! do nothing (coarse(current) next to fine)
              ! (this case will be masked off below)
             else
              print *,"nbr_outside_domain_flag invalid4"
              print *,"nbr_outside_domain_flag(side)=", &
                nbr_outside_domain_flag(side)
              print *,"dir,side ",dir,side
              stop
             endif
            else
             print *,"side invalid"
             stop
            endif
           else if (index_opp(dir).eq.fabhi(dir)+1) then
            if (side.eq.2) then
             if (nbr_outside_domain_flag(side).eq.1) then
              mask_out=0
             else if (nbr_outside_domain_flag(side).eq.0) then
              ! do nothing (fine next to fine)
             else if (nbr_outside_domain_flag(side).eq.-1) then
              ! do nothing (fine(current) next to coarse)
             else if (nbr_outside_domain_flag(side).eq.-2) then
              ! do nothing (coarse(current) next to fine)
              ! (this case will be masked off below)
             else
              print *,"nbr_outside_domain_flag invalid5"
              stop
             endif
            else
             print *,"side invalid"
             stop
            endif
           else if ((index_opp(dir).ge.fablo(dir)).and. &
                    (index_opp(dir).le.fabhi(dir))) then
            ! do nothing
           else
            print *,"index_opp invalid"
            stop
           endif

           ! except for advection:
           ! do not average with flux from neighboring coarse grid or
           ! from outside the domain.
           ! maskCF==0 at coarse/fine   maskCF==1 at fine/fine
          else if ((operation_flag.ge.0).and. &
                   (operation_flag.le.11)) then

           do dir2=1,SDIM
            if ((index_opp(dir2).lt.fablo(dir2)).or. &
                (index_opp(dir2).gt.fabhi(dir2))) then
             mask_out=NINT(maskCF(D_DECL(i_out,j_out,k_out)))
            endif
           enddo ! dir2

          else
           print *,"operation_flag invalid"
           stop
          endif

           ! do not average with flux from 
           ! an element that is covered. (avgDownEdge will handle this case)
          if (local_maskcov.eq.1) then
           ! do nothing
          else if (local_maskcov.eq.0) then
           mask_out=0
          else
           print *,"local_maskcov invalid"
           stop
          endif

           ! do not average with flux from 
           ! a low order  element.
          if (test_maskSEM.ne.cen_maskSEM) then
           mask_out=0
          endif

           ! shared_face=1 for faces on right side of elements and not
           !  touching the right side of the grid, not touching
           !  a maskSEM==0 element, and not touching a covered element.
           ! shared_face=0 for faces on the left side of elements and for
           !  the face touching the right side of the grid or touching
           !  a maskSEM!=cen_maskSEM element, or touching a covered element.
          if (shared_face.eq.1) then
           mask_out=0 
          else if (shared_face.eq.0) then
           ! do nothing
          else
           print *,"shared_face invalid"
           stop
          endif

          if (operation_flag.eq.7) then ! advection

           if (spectral_loop.eq.0) then

            if (shared_face.eq.0) then

             if ((nc.ge.1).and.(nc.le.SDIM)) then ! u * velocity (if cons)

              xface(D_DECL(ic,jc,kc),nc)=local_interp(isten+1)

             else if (nc.eq.SDIM+1) then ! density (NONCONSERVATIVE)

              xface(D_DECL(ic,jc,kc),nc)=local_interp(isten+1)

               ! temperature (NONCONSERVATIVE)
             else if (nc.eq.SDIM+2) then ! temperature

              xface(D_DECL(ic,jc,kc),nc)=local_interp(isten+1)

             else
              print *,"nc invalid"
              stop
             endif

            else if (shared_face.eq.1) then
             ! do nothing
            else
             print *,"shared_face invalid"
             stop
            endif

             ! semflux is a cell centered FAB with 1 ghost cell.
             ! fluxbase=(dir-1)*ngroup
            if ((side.eq.1).or.(side.eq.2)) then
             semflux(D_DECL(i_in,j_in,k_in),fluxbase+nc)=local_interp(isten+1)
            else if (side.eq.0) then
             ! do nothing
            else
             print *,"side invalid"
             stop
            endif

           else if (spectral_loop.eq.1) then

             ! 1. neighbor element is not a low order element
             ! 2. shared_face==0
            if (mask_out.eq.1) then

             if (side.eq.0) then
              ! do nothing
             else if ((side.eq.1).or.(side.eq.2)) then
               ! fine(current) next to coarse
              if (nbr_outside_domain_flag(side).eq.-1) then
               outside_flux=xgp(D_DECL(ic,jc,kc),nc) ! interpolated flux.
              else if (nbr_outside_domain_flag(side).eq.0) then
               outside_flux=semflux(D_DECL(i_out,j_out,k_out),fluxbase+nc)
              else
               print *,"nbr_outside_domain_flag invalid6"
               stop
              endif
              inside_flux=semflux(D_DECL(i_in,j_in,k_in),fluxbase+nc)

              if ((abs(inside_flux).lt.1.0D+20).and. &
                  (abs(outside_flux).lt.1.0D+20)) then

               if (SEM_upwind.eq.1) then

                if (((side.eq.1).and.(local_vel(0).ge.zero)).or. &
                    ((side.eq.2).and.(local_vel(bfact).le.zero))) then
                 xface(D_DECL(ic,jc,kc),nc)=outside_flux
                else if (((side.eq.1).and.(local_vel(0).le.zero)).or. &
                         ((side.eq.2).and.(local_vel(bfact).ge.zero))) then
                 xface(D_DECL(ic,jc,kc),nc)=inside_flux
                else
                 print *,"side invalid"
                 stop
                endif

               else if (SEM_upwind.eq.0) then

                if ((side.eq.1).or.(side.eq.2)) then
                 xface(D_DECL(ic,jc,kc),nc)=half*(outside_flux+inside_flux)
                else
                 print *,"side invalid"
                 stop
                endif

               else
                print *,"SEM_upwind invalid"
                stop
               endif

              else
               print *,"inside_flux or outside_flux overflow"
               stop
              endif

             else
              print *,"side invalid"
              stop
             endif

            else if (mask_out.eq.0) then
             ! do nothing
            else
             print *,"mask_out invalid"
             stop
            endif

           else
            print *,"spectral_loop invalid"
            stop
           endif

           ! tensor derivatives
          else if (operation_flag.eq.6) then 

           if (spectral_loop.eq.0) then

            if (shared_face.eq.0) then
             xgp(D_DECL(ic,jc,kc),dcomp+nc-1)=local_grad(isten+1)
            else if (shared_face.eq.1) then
             ! do nothing
            else
             print *,"shared_face invalid"
             stop
            endif

            if ((side.eq.1).or.(side.eq.2)) then
             semflux(D_DECL(i_in,j_in,k_in),nbase+nc)=local_grad(isten+1)
            else if (side.eq.0) then
             ! do nothing
            else
             print *,"side invalid"
             stop
            endif

           else if (spectral_loop.eq.1) then

            if (mask_out.eq.1) then

             if ((side.eq.1).or.(side.eq.2)) then
              xgp(D_DECL(ic,jc,kc),dcomp+nc-1)=half*( &
               semflux(D_DECL(i_in,j_in,k_in),nbase+nc)+ &
               semflux(D_DECL(i_out,j_out,k_out),nbase+nc))
             else if (side.eq.0) then
              ! do nothing
             else
              print *,"side invalid"
              stop
             endif

            else if (mask_out.eq.0) then
             ! do nothing
            else
             print *,"mask_out invalid"
             stop
            endif

           else
            print *,"spectral_loop invalid"
            stop
           endif

          else if (operation_flag.eq.0) then ! MAC pressure gradient

           if (ncfluxreg.ne.SDIM) then
            print *,"ncfluxreg invalid5 ",ncfluxreg
            stop
           endif

           shared_xcut=xcut(D_DECL(ic,jc,kc))

           if (side.eq.0) then
            ! do nothing
           else if ((side.eq.1).or.(side.eq.2)) then
            if (nbr_outside_domain_flag(side).eq.1) then
             if ((local_bctype(side).eq.3).or. & ! reflect even
                 (local_bctype(side).eq.2)) then ! neumann
              if (shared_xcut.ne.zero) then
               print *,"shared_xcut invalid"
               stop
              endif
             else if ((local_bctype(side).eq.1).or. &
                      (local_bctype(side).eq.0)) then
              ! do nothing
             else
              print *,"local_bctype invalid"
              stop
             endif
            else if (nbr_outside_domain_flag(side).eq.0) then
             ! do nothing
            else if (nbr_outside_domain_flag(side).eq.-2) then
             ! do nothing (coarse(current) next to fine)
            else if (nbr_outside_domain_flag(side).eq.-1) then 
             ! do nothing (fine(current) next to coarse)
            else
             print *,"nbr_outside_domain_flag invalid 4"
             stop
            endif 
           else
            print *,"side invalid"
            stop
           endif

           if (spectral_loop.eq.0) then
         
            ! regular solver or SDC viscosity or thermal flux.
            if (energyflag.eq.0) then 
             shared_face_value=-dt*local_grad(isten+1)*shared_xcut

            ! for SDC pressure gradient
            else if (energyflag.eq.2) then 
             shared_face_value=local_grad(isten+1)

            else
             print *,"energyflag invalid"
             stop
            endif

            if (shared_face.eq.0) then
             xgp(D_DECL(ic,jc,kc),dcomp)=shared_face_value
             if (update_right_flux.eq.1) then
              xgp(D_DECL(ic,jc,kc),dcomp+nmat)= &
                xgp(D_DECL(ic,jc,kc),dcomp)
             endif
            else if (shared_face.eq.1) then
             ! do nothing
            else
             print *,"shared_face invalid"
             stop
            endif

            if ((side.eq.1).or. &
                (side.eq.2)) then
             semflux(D_DECL(i_in,j_in,k_in),fluxbase+nc)=shared_face_value
            else if (side.eq.0) then
             ! do nothing
            else
             print *,"side invalid"
             stop
            endif

           else if (spectral_loop.eq.1) then

            if (mask_out.eq.1) then
             if ((side.eq.1).or.(side.eq.2)) then
              xgp(D_DECL(ic,jc,kc),dcomp)=half*( &
               semflux(D_DECL(i_in,j_in,k_in),fluxbase+nc)+ &
               semflux(D_DECL(i_out,j_out,k_out),fluxbase+nc))
              if (update_right_flux.eq.1) then
               xgp(D_DECL(ic,jc,kc),dcomp+nmat)= &
                xgp(D_DECL(ic,jc,kc),dcomp)
              endif
             else if (side.eq.0) then
              ! do nothing
             else
              print *,"side invalid"
              stop
             endif
            else if (mask_out.eq.0) then
             ! do nothing
            else
             print *,"mask_out invalid"
             stop
            endif
           else
            print *,"spectral_loop invalid"
            stop
           endif

          else if (operation_flag.eq.9) then ! den: cell->mac

           if (ncfluxreg.ne.SDIM) then
            print *,"ncfluxreg invalid6 ",ncfluxreg
            stop
           endif

           if (spectral_loop.eq.0) then

            if ((local_interp(isten+1).gt.zero).and. &
                (abs(local_interp(isten+1)).lt.1.0D+20)) then
             ! do nothing
            else
             print *,"local_interp invalid den:cell->mac"
             stop
            endif

            if (shared_face.eq.0) then

             xvel(D_DECL(ic,jc,kc),dcomp)=one/local_interp(isten+1)

            else if (shared_face.eq.1) then
             ! do nothing
            else
             print *,"shared_face invalid"
             stop
            endif

            if ((side.eq.1).or.(side.eq.2)) then
             semflux(D_DECL(i_in,j_in,k_in),fluxbase+nc)=local_interp(isten+1)
            else if (side.eq.0) then
             ! do nothing
            else
             print *,"side invalid"
             stop
            endif
           else if (spectral_loop.eq.1) then
            if (mask_out.eq.1) then
             if ((side.eq.1).or.(side.eq.2)) then
              local_interp(isten+1)=half*( &
               semflux(D_DECL(i_in,j_in,k_in),fluxbase+nc)+ &
               semflux(D_DECL(i_out,j_out,k_out),fluxbase+nc))
              if ((local_interp(isten+1).gt.zero).and. &
                  (abs(local_interp(isten+1)).lt.1.0D+20)) then
               ! do nothing
              else
               print *,"local_interp invalid den:cell->mac"
               stop
              endif

              xvel(D_DECL(ic,jc,kc),dcomp)=one/local_interp(isten+1)
             else if (side.eq.0) then
              ! do nothing
             else
              print *,"side invalid"
              stop
             endif
            else if (mask_out.eq.0) then
             ! do nothing
            else
             print *,"mask_out invalid"
             stop
            endif
           else
            print *,"spectral_loop invalid"
            stop
           endif

          else if (operation_flag.eq.1) then ! p^CELL->MAC

           if (ncfluxreg.ne.SDIM) then
            print *,"ncfluxreg invalid6 ",ncfluxreg
            stop
           endif

           if (spectral_loop.eq.0) then

            if (shared_face.eq.0) then
             if (dcomp.eq.3) then
              xp(D_DECL(ic,jc,kc),dcomp)=local_interp(isten+1)
             else
              print *,"dcomp invalid"
              stop
             endif
            else if (shared_face.eq.1) then
             ! do nothing
            else
             print *,"shared_face invalid"
             stop
            endif

            if ((side.eq.1).or.(side.eq.2)) then
             semflux(D_DECL(i_in,j_in,k_in),fluxbase+nc)=local_interp(isten+1)
            else if (side.eq.0) then
             ! do nothing
            else
             print *,"side invalid"
             stop
            endif
           else if (spectral_loop.eq.1) then
            if (mask_out.eq.1) then
             if ((side.eq.1).or.(side.eq.2)) then
              if (update_right_flux.eq.0) then
               xp(D_DECL(ic,jc,kc),dcomp)=half*( &
                semflux(D_DECL(i_in,j_in,k_in),fluxbase+nc)+ &
                semflux(D_DECL(i_out,j_out,k_out),fluxbase+nc))
              else
               print *,"update_right_flux invalid"
               stop
              endif
             else if (side.eq.0) then
              ! do nothing
             else
              print *,"side invalid"
              stop
             endif
            else if (mask_out.eq.0) then
             ! do nothing
            else
             print *,"mask_out invalid"
             stop
            endif
           else
            print *,"spectral_loop invalid"
            stop
           endif

          else if (operation_flag.eq.2) then ! potential grad and value

           ! potential pressure gradient/den and potential pressure.
           if (ncfluxreg.ne.2*SDIM) then
            print *,"ncfluxreg invalid7 ",ncfluxreg
            stop
           endif

           if (spectral_loop.eq.0) then

            if (local_interp_den(isten+1).le.zero) then
             print *,"local_interp_den underflow"
             stop
            endif

            shared_face_value=local_grad(isten+1)/local_interp_den(isten+1)

            if (shared_face.eq.0) then
             if (nc.eq.1) then
              ! grad ppot/rho_pot at face.
              xgp(D_DECL(ic,jc,kc),nc)=shared_face_value
              ! ppot at face.
              xp(D_DECL(ic,jc,kc),1)=local_interp(isten+1)
             else
              print *,"nc invalid"
              stop
             endif
            else if (shared_face.eq.1) then
             ! do nothing
            else
             print *,"shared_face invalid"
             stop
            endif

            if ((side.eq.1).or.(side.eq.2)) then
              ! grad ppot/rho_pot at face.
             semflux(D_DECL(i_in,j_in,k_in),fluxbase+1)=shared_face_value
              ! ppot at face.
             semflux(D_DECL(i_in,j_in,k_in),fluxbase+2)=local_interp(isten+1)
            else if (side.eq.0) then
             ! do nothing
            else
             print *,"side invalid"
             stop
            endif
           else if (spectral_loop.eq.1) then
            if (mask_out.eq.1) then
             if ((side.eq.1).or.(side.eq.2)) then
              ! grad ppot/rho_pot at face.
              xgp(D_DECL(ic,jc,kc),nc)=half*( &
               semflux(D_DECL(i_in,j_in,k_in),fluxbase+1)+ &
               semflux(D_DECL(i_out,j_out,k_out),fluxbase+1))
              ! ppot at face.
              xp(D_DECL(ic,jc,kc),1)=half*( &
               semflux(D_DECL(i_in,j_in,k_in),fluxbase+2)+ &
               semflux(D_DECL(i_out,j_out,k_out),fluxbase+2))
             else if (side.eq.0) then
              ! do nothing
             else
              print *,"side invalid"
              stop
             endif
            else if (mask_out.eq.0) then
             ! do nothing
            else
             print *,"mask_out invalid"
             stop
            endif
           else
            print *,"spectral_loop invalid"
            stop
           endif

          else if ((operation_flag.eq.3).or. &   !unew^CELL->MAC
                   (operation_flag.eq.10)) then  !unew^MAC,CELL->MAC

           if (ncfluxreg.ne.SDIM) then
            print *,"ncfluxreg invalid8 ",ncfluxreg
            stop
           endif

           if (spectral_loop.eq.0) then

            if (shared_face.eq.0) then
             xvel(D_DECL(ic,jc,kc),dcomp)=local_interp(isten+1)
            else if (shared_face.eq.1) then
             ! do nothing
            else
             print *,"shared_face invalid"
             stop
            endif

            if ((side.eq.1).or.(side.eq.2)) then
             semflux(D_DECL(i_in,j_in,k_in),fluxbase+1)=local_interp(isten+1)
            else if (side.eq.0) then
             ! do nothing
            else
             print *,"side invalid"
             stop
            endif

           else if (spectral_loop.eq.1) then

            if (mask_out.eq.1) then
             if ((side.eq.1).or.(side.eq.2)) then
              xvel(D_DECL(ic,jc,kc),dcomp)=half*( &
               semflux(D_DECL(i_in,j_in,k_in),fluxbase+1)+ &
               semflux(D_DECL(i_out,j_out,k_out),fluxbase+1))
             else if (side.eq.0) then
              ! do nothing
             else
              print *,"side invalid"
              stop
             endif
            else if (mask_out.eq.0) then
             ! do nothing
            else
             print *,"mask_out invalid"
             stop
            endif

           else
            print *,"spectral_loop invalid"
            stop
           endif

          else if (operation_flag.eq.11) then ! u^MAC,CELL DIFF->MAC

           if (ncfluxreg.ne.SDIM) then
            print *,"ncfluxreg invalid8 ",ncfluxreg
            stop
           endif
           if (spectral_loop.eq.0) then

            shared_face_value=xgp(D_DECL(ic,jc,kc),dcomp)+ &
              local_interp(isten+1)

            if (shared_face.eq.0) then
             xvel(D_DECL(ic,jc,kc),dcomp)=shared_face_value
            else if (shared_face.eq.1) then
             ! do nothing
            else
             print *,"shared_face invalid"
             stop
            endif

            if ((side.eq.1).or.(side.eq.2)) then
             semflux(D_DECL(i_in,j_in,k_in),fluxbase+1)=shared_face_value
            else if (side.eq.0) then
             ! do nothing
            else
             print *,"side invalid"
             stop
            endif

           else if (spectral_loop.eq.1) then

            if (mask_out.eq.1) then
             if ((side.eq.1).or.(side.eq.2)) then
              xvel(D_DECL(ic,jc,kc),dcomp)=half*( &
               semflux(D_DECL(i_in,j_in,k_in),fluxbase+1)+ &
               semflux(D_DECL(i_out,j_out,k_out),fluxbase+1))
             else if (side.eq.0) then
              ! do nothing
             else
              print *,"side invalid"
              stop
             endif
            else if (mask_out.eq.0) then
             ! do nothing
            else
             print *,"mask_out invalid"
             stop
            endif
           else
            print *,"spectral_loop invalid"
            stop
           endif

          else if (operation_flag.eq.5) then ! UMAC=UMAC+beta F^CELL->MAC

           if (ncfluxreg.ne.SDIM) then
            print *,"ncfluxreg invalid9 ",ncfluxreg
            stop
           endif
           if (spectral_loop.eq.0) then

            shared_face_value=xgp(D_DECL(ic,jc,kc),dcomp)+ &
              beta*local_interp(isten+1)

            if (shared_face.eq.0) then
             xvel(D_DECL(ic,jc,kc),dcomp)=shared_face_value
            else if (shared_face.eq.1) then
             ! do nothing
            else
             print *,"shared_face invalid"
             stop
            endif

            if ((side.eq.1).or.(side.eq.2)) then
             semflux(D_DECL(i_in,j_in,k_in),fluxbase+1)=shared_face_value
            else if (side.eq.0) then
             ! do nothing
            else
             print *,"side invalid"
             stop
            endif
           else if (spectral_loop.eq.1) then
            if (mask_out.eq.1) then
             if ((side.eq.1).or.(side.eq.2)) then
              xvel(D_DECL(ic,jc,kc),dcomp)=half*( &
               semflux(D_DECL(i_in,j_in,k_in),fluxbase+1)+ &
               semflux(D_DECL(i_out,j_out,k_out),fluxbase+1))
             else if (side.eq.0) then
              ! do nothing
             else
              print *,"side invalid"
              stop
             endif
            else if (mask_out.eq.0) then
             ! do nothing
            else
             print *,"mask_out invalid"
             stop
            endif
           else
            print *,"spectral_loop invalid"
            stop
           endif

          else
           print *,"operation_flag invalid25"
           stop
          endif

         enddo ! isten=0..bfact
 
        else
         print *,"cen_outside_domain_flag: ",cen_outside_domain_flag
         print *,"cen_maskSEM: ",cen_maskSEM
         stop
        endif

       else if (cen_maskSEM.eq.0) then
        ! do nothing
       else
        print *,"cen_maskSEM invalid sem_cell_to_mac: ",cen_maskSEM
        print *,"i,j,k : ",i,j,k
        stop
       endif

      enddo ! nc=1..ncomp_dest

      return
      end subroutine SEM_CELL_TO_MAC
      
       ! operation_flag=0 (right hand side for solver)
       ! operation_flag=1 (divergence)
       ! operation_flag=2 (mac -> cell velocity in solver)
       ! operation_flag=3 (cell pressure gradient, p div (u))
       ! operation_flag=4 (gravity and surface tension force at cell)
       ! operation_flag=5 interpolate grad u from MAC to CELL.
       ! operation_flag=6 advection
       ! mask>0 SEM; mask=0 piecewise finite volume
      subroutine SEM_MAC_TO_CELL( &
       ncomp_denold, &
       ncomp_veldest, &
       ncomp_dendest, &
       conservative_div_uu, &
       nsolveMM_FACE, &
       num_materials_face, &
       ns_time_order, &
       divu_outer_sweeps, &
       num_divu_outer_sweeps, &
       SDC_outer_sweeps, &
       SEM_advection_algorithm, &
       level, &
       finest_level, &
       nmat, &
       operation_flag, &
       project_option, &
       energyflag, &
       temperature_primitive_variable, &
       face_flag, &
       homflag, &
       maskSEM, &
       time, &
       slab_step, &
       dt, &
       i,j,k, &
       tilelo,tilehi, &
       fablo,fabhi, &
       xlo,dx, &
       dir_main, &
       bfact, &
       velbc_in, &
       presbc_in, &
       scomp, &
       scomp_bc, &
       dcomp, &
       ncomp, &
       ncomp_xvel, &
       ncomp_cterm, &
       vol,DIMS(vol), & 
       xface,DIMS(xface), & 
       xp,DIMS(xp), & 
       xvel,DIMS(xvel), & 
       maskcoef,DIMS(maskcoef), & 
       cterm,DIMS(cterm), & 
       mdotcell,DIMS(mdotcell), &  ! holds velocity if operation_flag==6
       pold,DIMS(pold), & 
       denold,DIMS(denold), & 
       ustar,DIMS(ustar), & 
       veldest,DIMS(veldest), &
       dendest,DIMS(dendest), &
       divdest,DIMS(divdest) )
      use global_utility_module

      IMPLICIT NONE

      INTEGER_T, intent(in) :: ncomp_denold
      INTEGER_T, intent(in) :: ncomp_veldest
      INTEGER_T, intent(in) :: ncomp_dendest
      INTEGER_T, intent(in) :: conservative_div_uu
      INTEGER_T, intent(in) :: nsolveMM_FACE
      INTEGER_T, intent(in) :: num_materials_face
      INTEGER_T, intent(in) :: ns_time_order
      INTEGER_T, intent(in) :: divu_outer_sweeps
      INTEGER_T, intent(in) :: num_divu_outer_sweeps
      INTEGER_T, intent(in) :: SDC_outer_sweeps
      INTEGER_T, intent(in) :: SEM_advection_algorithm
      INTEGER_T, intent(in) :: level
      INTEGER_T, intent(in) :: finest_level
      INTEGER_T, intent(in) :: nmat
      INTEGER_T, intent(in) :: slab_step
      INTEGER_T, intent(in) :: operation_flag
      INTEGER_T, intent(in) :: homflag
      INTEGER_T, intent(in) :: project_option
      INTEGER_T, intent(in) :: energyflag
      INTEGER_T, intent(in) :: face_flag
      INTEGER_T, intent(in) :: temperature_primitive_variable(nmat)
      INTEGER_T :: advect_iter
      INTEGER_T :: source_term
      INTEGER_T, intent(in) :: maskSEM
      REAL_T, intent(in) :: time,dt
      INTEGER_T, intent(in) :: i,j,k
      INTEGER_T, intent(in) :: dir_main
      INTEGER_T, intent(in) :: bfact
      INTEGER_T, intent(in) :: scomp
      INTEGER_T :: scompMM_L
      INTEGER_T :: scompMM_R
      INTEGER_T, intent(in) :: scomp_bc
      INTEGER_T, intent(in) :: dcomp
      INTEGER_T, intent(in) :: ncomp
      INTEGER_T, intent(in) :: ncomp_xvel
      INTEGER_T, intent(in) :: ncomp_cterm
      INTEGER_T, intent(in) :: tilelo(SDIM),tilehi(SDIM)
      INTEGER_T, intent(in) :: fablo(SDIM),fabhi(SDIM)
      REAL_T, intent(in) :: xlo(SDIM)
      REAL_T, intent(in) :: dx(SDIM)
      INTEGER_T, intent(in) :: velbc_in(SDIM,2,SDIM)
      INTEGER_T, intent(in) :: presbc_in(SDIM,2)
      INTEGER_T, intent(in) :: DIMDEC(vol)
      INTEGER_T, intent(in) :: DIMDEC(xface)
      INTEGER_T, intent(in) :: DIMDEC(xp)
      INTEGER_T, intent(in) :: DIMDEC(xvel)
      INTEGER_T, intent(in) :: DIMDEC(maskcoef)
      INTEGER_T, intent(in) :: DIMDEC(cterm)
      INTEGER_T, intent(in) :: DIMDEC(mdotcell)
      INTEGER_T, intent(in) :: DIMDEC(pold)
      INTEGER_T, intent(in) :: DIMDEC(denold)
      INTEGER_T, intent(in) :: DIMDEC(dendest)
      INTEGER_T, intent(in) :: DIMDEC(ustar)
      INTEGER_T, intent(in) :: DIMDEC(veldest)
      INTEGER_T, intent(in) :: DIMDEC(divdest)
      REAL_T, intent(in) :: vol(DIMV(vol))
      REAL_T, intent(in) :: xface(DIMV(xface),ncomp)  ! flux data for I-scheme
      REAL_T, intent(in) :: xp(DIMV(xp),2+nsolveMM_FACE)
      REAL_T, intent(in) :: xvel(DIMV(xvel),ncomp_xvel)
      REAL_T, intent(in) :: maskcoef(DIMV(maskcoef))
      REAL_T, intent(inout) :: cterm(DIMV(cterm),ncomp_cterm)
      REAL_T, intent(in) :: mdotcell(DIMV(mdotcell),ncomp*num_materials_face)
      REAL_T, intent(in) :: pold(DIMV(pold),ncomp*num_materials_face)
      REAL_T, intent(in) :: denold(DIMV(denold),ncomp_denold)
      REAL_T, intent(inout) :: dendest(DIMV(dendest),ncomp_dendest)
      REAL_T, intent(inout) :: ustar(DIMV(ustar),SDIM*num_materials_vel)
      REAL_T, intent(inout) :: veldest(DIMV(veldest),ncomp_veldest)
      REAL_T, intent(inout) :: divdest(DIMV(divdest),ncomp*num_materials_face)
      REAL_T local_data(bfact+1)
      REAL_T local_vel_data(bfact+1)
      REAL_T local_vel_data_div(bfact+1)
      REAL_T local_data_up(bfact+1)
      REAL_T local_cell(bfact)
      REAL_T local_vel_cell(bfact)
      REAL_T local_vel_cell_div(bfact)
      REAL_T local_cell_up(bfact)
      REAL_T prescell
      REAL_T local_vel_div(bfact)
      REAL_T local_vel_div_div(bfact)
      REAL_T local_div(bfact)
      REAL_T local_div_up(bfact)
      INTEGER_T ii,jj,kk
      INTEGER_T ic,jc,kc
      INTEGER_T i_out,j_out,k_out
      INTEGER_T nc,side
      INTEGER_T nbr_outside_domain_flag(2)
      INTEGER_T cen_outside_domain_flag
      INTEGER_T isten
      INTEGER_T dir2
      INTEGER_T sideidx(SDIM)
      INTEGER_T indexlo(SDIM)
      INTEGER_T indexhi(SDIM)
      INTEGER_T indexmid(SDIM)
      REAL_T xstenMAC(-3:3,SDIM)
      REAL_T xsten(-3:3,SDIM)
      REAL_T RR,RRTHETA,RR_DIVIDE
      INTEGER_T nhalf,ibase,imattype,nc2
      REAL_T divu,CC,CC_DUAL,MDOT,RHS,dp,dencell
      REAL_T local_POLD
      REAL_T local_POLD_DUAL
      REAL_T TEMPERATURE,Eforce,internal_e
      REAL_T divflux(ncomp)
      REAL_T den_new,den_old,vel_old,mom_new,T_old,T_new
      REAL_T vel_new(SDIM)
      REAL_T VOLTERM
      INTEGER_T velcomp
      INTEGER_T nbase
      INTEGER_T ntensor
      INTEGER_T ntensorMM
      INTEGER_T nsolveMM_FACE_test
      REAL_T xflux_R
      INTEGER_T local_incomp
      REAL_T local_div_val
      REAL_T :: massfrac_parm(num_species_var+1)

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif

      if ((dir_main.ge.1).and.(dir_main.le.SDIM)) then
       ! do nothing
      else
       print *,"dir_main invalid sem mac to cell"
       stop
      endif

      if ((slab_step.lt.-1).or.(slab_step.gt.bfact_time_order)) then
       print *,"slab_step invalid sem mac to cell "
       stop
      endif
      if ((level.lt.0).or. &
          (level.gt.finest_level)) then
       print *,"level or finest_level invalid"
       stop
      endif

      if (num_materials_vel.ne.1) then
       print *,"num_materials_vel invalid"
       stop
      endif

      if ((face_flag.ne.0).and.(face_flag.ne.1)) then
       print *,"face_flag invalid"
       stop
      endif

      ntensor=SDIM*SDIM
      ntensorMM=ntensor*num_materials_vel

      if (bfact.lt.1) then
       print *,"bfact invalid200 mac to cell"
       stop
      endif

      if ((ns_time_order.ge.1).and.(ns_time_order.le.32)) then
       ! do nothing
      else
       print *,"ns_time_order invalid"
       stop
      endif
      if ((SDC_outer_sweeps.ge.0).and. &
          (SDC_outer_sweeps.lt.ns_time_order)) then
       ! do nothing
      else
       print *,"SDC_outer_sweeps invalid"
       stop
      endif
      if (num_divu_outer_sweeps.lt.1) then
       print *,"num_divu_outer_sweeps invalid"
       stop
      endif
      if ((divu_outer_sweeps.ge.0).and. &
          (divu_outer_sweeps.lt.num_divu_outer_sweeps)) then
       ! do nothing
      else
       print *,"divu_outer_sweeps invalid"
       stop
      endif

      if ((SEM_advection_algorithm.eq.0).or. &
          (SEM_advection_algorithm.eq.1)) then
       ! do nothing
      else
       print *,"SEM_advection_algorithm invalid"
       stop
      endif

      advect_iter=energyflag
      source_term=homflag

      local_incomp=0

      if ((maskSEM.ge.1).and. &
          (maskSEM.le.nmat)) then

       if ((fort_material_type(maskSEM).eq.0).or. &
           (is_rigid(nmat,maskSEM).eq.1).or. &
           (fort_material_type(maskSEM).eq.999).or. &
           (is_FSI_rigid(nmat,maskSEM).eq.1).or. &
           (is_ice(nmat,maskSEM).eq.1)) then
        if (temperature_primitive_variable(maskSEM).ne.1) then
         print *,"temperature_primitive_variable(maskSEM) invalid"
         stop
        endif
        local_incomp=1
       else if ((fort_material_type(maskSEM).gt.0).and. &
                (fort_material_type(maskSEM).le.fort_max_num_eos).and. &
                (is_rigid(nmat,maskSEM).eq.0).and. &
                (fort_material_type(maskSEM).ne.999).and. &
                (is_FSI_rigid(nmat,maskSEM).eq.0).and. &
                (is_ice(nmat,maskSEM).eq.0)) then
        if ((temperature_primitive_variable(maskSEM).eq.0).or. &
            (temperature_primitive_variable(maskSEM).eq.1)) then
         ! do nothing
        else
         print *,"temperature_primitive_variable(maskSEM) invalid"
         stop
        endif
       else
        print *,"fort_material_type(maskSEM) or is_rigid invalid"
        stop
       endif

      else if (maskSEM.eq.0) then
       ! do nothing
      else
       print *,"maskSEM invalid sem_mac_to_cell: ",maskSEM
       print *,"i,j,k : ",i,j,k
       stop
      endif

      if (operation_flag.eq.5) then ! grad U: MAC -> CELL

       nsolveMM_FACE_test=ntensorMM

       if ((maskSEM.lt.1).or.(maskSEM.gt.nmat)) then
        print *,"maskSEM invalid"
        stop
       endif 
       if (energyflag.ne.0) then
        print *,"energyflag invalid"
        stop
       endif
       if (project_option.ne.3) then
        print *,"project_option invalid"
        stop
       endif

       ! u_x,v_x,w_x, u_y,v_y,w_y, u_z,v_z,w_z;  
       nbase=dcomp-1

       if ((nbase.ne.0).and.(nbase.ne.SDIM).and. &
           (nbase.ne.(SDIM-1)*SDIM)) then
        print *,"nbase invalid"
        stop
       endif

       if (scomp.ne.dcomp) then
        print *,"scomp invalid"
        stop
       endif
       if (ncomp.ne.SDIM) then
        print *,"ncomp invalid1"
        stop
       endif
       if ((ncomp_xvel.eq.ntensorMM).and. &
           (ncomp_veldest.eq.ntensorMM).and. &
           (ncomp_dendest.eq.ntensorMM).and. &
           (ncomp_denold.eq.ntensorMM).and. &
           (ncomp_cterm.eq.ntensorMM)) then
        ! do nothing
       else
        print *,"nc_xvel,nc_veldest,nc_dendest,nc_denold or nc_cterm invalid"
        stop
       endif

      else if (operation_flag.eq.0) then ! RHS for solver

       if ((project_option.eq.0).or. &
           (project_option.eq.1).or. &
           (project_option.eq.10).or. &
           (project_option.eq.13).or. & !FSI_material_exists 1st project
           (project_option.eq.11)) then !FSI_material_exists 2nd project
        if (ncomp.ne.1) then
         print *,"ncomp invalid2"
         stop
        endif
       else if (project_option.eq.12) then ! extension project
        print *,"extension project should be low order"
        stop
       else if (project_option.eq.3) then ! viscosity
        if (ncomp.ne.SDIM) then
         print *,"ncomp invalid3"
         stop
        endif
       else if (project_option.eq.2) then ! thermal conduction
        if (ncomp.ne.1) then
         print *,"ncomp invalid4"
         stop
        endif
       else if ((project_option.ge.100).and. &
                (project_option.lt.100+num_species_var)) then
        if (ncomp.ne.1) then
         print *,"ncomp invalid5"
         stop
        endif
       else
        print *,"project_option invalid"
        stop
       endif
       if ((maskSEM.lt.1).or.(maskSEM.gt.nmat)) then ! operation_flag=0
        print *,"maskSEM invalid"
        stop
       endif 
       if ((scomp.ne.1).or. &
           (dcomp.ne.1)) then
        print *,"scomp or dcomp invalid"
        stop
       endif
       if ((ncomp.ne.1).and. &
           (ncomp.ne.SDIM)) then
        print *,"ncomp invalid6"
        stop
       endif
       if ((scomp_bc.lt.1).or.(scomp_bc.gt.SDIM)) then
        print *,"scomp_bc invalid"
        stop
       endif
       if (energyflag.ne.0) then
        print *,"energyflag invalid"
        stop
       endif
       if (ncomp_xvel.ne.nsolveMM_FACE) then
        print *,"ncomp_xvel invalid"
        stop
       endif
       if (ncomp_veldest.eq.ncomp) then
        ! do nothing
       else
        print *,"ncomp_veldest invalid"
        stop
       endif
       if (ncomp_dendest.eq.ncomp) then
        ! do nothing
       else
        print *,"ncomp_dendest invalid"
        stop
       endif
       if (ncomp_denold.eq.ncomp*num_materials_face) then
        ! do nothing
       else
        print *,"ncomp_denold invalid"
        stop
       endif

       if (ncomp_cterm.ne.ncomp*num_materials_face) then
        print *,"ncomp_cterm invalid"
        stop
       endif

       nsolveMM_FACE_test=ncomp*num_materials_face
       if (num_materials_face.eq.1) then
        ! do nothing
       else if (num_materials_face.eq.nmat) then
        nsolveMM_FACE_test=nsolveMM_FACE_test*2
       else
        print *,"num_materials_face invalid"
        stop
       endif

      else if (operation_flag.eq.1) then ! divergence

       if (num_materials_face.ne.1) then
        print *,"num_materials_face invalid"
        stop
       endif
       if ((maskSEM.lt.1).or.(maskSEM.gt.nmat)) then
        print *,"maskSEM invalid"
        stop
       endif 
       if ((scomp_bc.lt.1).or.(scomp_bc.gt.SDIM)) then
        print *,"scomp_bc invalid"
        stop
       endif
       if ((scomp.ne.1).or. &
           (dcomp.ne.1).or. &
           (ncomp.ne.1)) then
        print *,"scomp, dcomp, or ncomp invalid"
        stop
       endif
       if (energyflag.ne.0) then
        print *,"energyflag invalid"
        stop
       endif
       if (ncomp_xvel.ne.nsolveMM_FACE) then
        print *,"ncomp_xvel invalid"
        stop
       endif

       if (ncomp_veldest.eq.num_materials_vel) then
        ! do nothing
       else
        print *,"ncomp_veldest invalid"
        stop
       endif
       if (ncomp_dendest.eq.num_materials_vel) then
        ! do nothing
       else
        print *,"ncomp_dendest invalid"
        stop
       endif
       if (ncomp_denold.eq.1) then
        ! do nothing
       else
        print *,"ncomp_denold invalid"
        stop
       endif
       if (ncomp_cterm.ne.1) then
        print *,"ncomp_cterm invalid"
        stop
       endif

       nsolveMM_FACE_test=ncomp*num_materials_face

      else if (operation_flag.eq.2) then !MAC->CELL in solver or VELMAC_TO_CELL

       if (num_materials_face.ne.1) then
        print *,"num_materials_face invalid"
        stop
       endif
       if ((maskSEM.lt.1).or.(maskSEM.gt.nmat)) then
        print *,"maskSEM invalid"
        stop
       endif 
       if ((scomp_bc.lt.1).or.(scomp_bc.gt.SDIM)) then
        print *,"scomp_bc invalid"
        stop
       endif
       if ((dcomp.ge.1).and.(dcomp.le.SDIM)) then
        ! do nothing
       else
        print *,"dcomp invalid"
        stop
       endif
       if (dcomp.ne.dir_main) then
        print *,"dcomp invalid"
        stop
       endif
       if ((scomp.ne.1).or. &
           (ncomp.ne.1)) then
        print *,"scomp or ncomp invalid"
        stop
       endif
       if ((energyflag.ne.0).and. &
           (energyflag.ne.1)) then
        print *,"energyflag invalid"
        stop
       endif
       if (ncomp_xvel.ne.nsolveMM_FACE) then
        print *,"ncomp_xvel invalid"
        stop
       endif

       if (ncomp_veldest.ge. &
           num_materials_vel*SDIM+num_state_material*nmat) then
        ! do nothing
       else
        print *,"ncomp_veldest invalid"
        stop
       endif
       if (ncomp_dendest.ge.num_state_material*nmat) then
        ! do nothing
       else
        print *,"ncomp_dendest invalid"
        stop
       endif
       if ((ncomp_denold.eq.ncomp*num_materials_face).or. &
           (ncomp_denold.eq.1)) then
        ! do nothing
       else
        print *,"ncomp_denold invalid"
        stop
       endif

       if (ncomp_cterm.ne.1) then
        print *,"ncomp_cterm invalid"
        stop
       endif

       nsolveMM_FACE_test=ncomp*num_materials_face

      else if (operation_flag.eq.3) then ! (grad p)^CELL, div(u)p

       nsolveMM_FACE_test=ncomp*num_materials_face

       if (ncomp_veldest.ge. &
           num_materials_vel*SDIM+num_state_material*nmat) then
        ! do nothing
       else
        print *,"ncomp_veldest invalid"
        stop
       endif
       if (ncomp_dendest.ge.num_state_material*nmat) then
        ! do nothing
       else
        print *,"ncomp_dendest invalid"
        stop
       endif
       if (ncomp_denold.eq.nsolveMM_FACE_test) then
        ! do nothing
       else
        print *,"ncomp_denold invalid"
        stop
       endif
       if ((maskSEM.lt.1).or.(maskSEM.gt.nmat)) then
        print *,"maskSEM invalid"
        stop
       endif 
       if ((scomp_bc.lt.1).or.(scomp_bc.gt.SDIM)) then
        print *,"scomp_bc invalid"
        stop
       endif
       if ((dcomp.ge.1).and.(dcomp.le.SDIM)) then
        ! do nothing
       else
        print *,"dcomp invalid"
        stop
       endif
       if (dcomp.eq.dir_main) then
        ! do nothing
       else
        print *,"dcomp invalid"
        stop
       endif
       if ((scomp.ne.1).or.(ncomp.ne.1)) then
        print *,"scomp or ncomp invalid"
        stop
       endif
       if ((energyflag.ne.0).and. &
           (energyflag.ne.1).and. &
           (energyflag.ne.2)) then
        print *,"energyflag invalid"
        stop
       endif
       if (ncomp_xvel.ne.nsolveMM_FACE) then
        print *,"ncomp_xvel invalid"
        stop
       endif
       if (ncomp_cterm.ne.1) then
        print *,"ncomp_cterm invalid"
        stop
       endif
       if (num_materials_face.ne.1) then
        print *,"num_materials_face invalid"
        stop
       endif

      else if (operation_flag.eq.4) then ! (grad pot)^CELL

       if (ncomp_veldest.eq.SDIM) then
        ! do nothing
       else
        print *,"ncomp_veldest invalid"
        stop
       endif
       if (ncomp_dendest.eq.SDIM) then
        ! do nothing
       else
        print *,"ncomp_dendest invalid"
        stop
       endif
       if (ncomp_denold.eq.1) then
        ! do nothing
       else
        print *,"ncomp_denold invalid"
        stop
       endif
       if ((maskSEM.lt.1).or.(maskSEM.gt.nmat)) then
        print *,"maskSEM invalid"
        stop
       endif 
       if ((scomp_bc.lt.1).or.(scomp_bc.gt.SDIM)) then
        print *,"scomp_bc invalid"
        stop
       endif
       if ((dcomp.ge.1).and.(dcomp.le.SDIM)) then
        ! do nothing
       else
        print *,"dcomp invalid"
        stop
       endif
       if (dcomp.eq.dir_main) then
        ! do nothing
       else
        print *,"dcomp invalid"
        stop
       endif
       if ((scomp.ne.1).or.(ncomp.ne.1)) then
        print *,"scomp or ncomp invalid"
        stop
       endif
       if (energyflag.ne.0) then
        print *,"energyflag invalid"
        stop
       endif
       if (ncomp_xvel.ne.nsolveMM_FACE) then
        print *,"ncomp_xvel invalid"
        stop
       endif
       if (ncomp_cterm.ne.1) then
        print *,"ncomp_cterm invalid"
        stop
       endif
       if (num_materials_face.ne.1) then
        print *,"num_materials_face invalid"
        stop
       endif

       nsolveMM_FACE_test=num_materials_face

      else if (operation_flag.eq.6) then ! advection

       if ((maskSEM.ge.1).and.(maskSEM.le.nmat)) then
        ! do nothing
       else
        print *,"maskSEM invalid"
        stop
       endif 

       if (ncomp_veldest.ge. &
           num_materials_vel*SDIM+num_state_material*nmat) then
        ! do nothing
       else
        print *,"ncomp_veldest invalid"
        stop
       endif
       if (ncomp_dendest.ge.num_state_material*nmat) then
        ! do nothing
       else
        print *,"ncomp_dendest invalid"
        stop
       endif
       if (ncomp_denold.eq.nmat*num_state_material) then
        ! do nothing
       else
        print *,"ncomp_denold invalid"
        stop
       endif

       if (ncomp.eq.SDIM+num_state_base) then
        ! do nothing
       else
        print *,"ncomp invalid7"
        stop
       endif
       if (source_term.eq.1) then 
        if (advect_iter.ne.0) then 
         print *,"advect_iter invalid"
         stop
        endif
       else if (source_term.eq.0) then 
        if ((advect_iter.ne.0).and.(advect_iter.ne.1)) then
         print *,"advect_iter invalid"
         stop
        endif
       else
        print *,"source_term invalid"
        stop
       endif
       if ((scomp.ne.1).or. &
           (dcomp.ne.1).or. &
           (scomp_bc.ne.1)) then
        print *,"scomp, dcomp, or scomp_bc invalid"
        stop
       endif
       if (ncomp_xvel.ne.nsolveMM_FACE) then
        print *,"ncomp_xvel invalid"
        stop
       endif
       if (ncomp_cterm.ne.ncomp) then
        print *,"ncomp_cterm invalid"
        stop
       endif
       if (num_materials_face.ne.1) then
        print *,"num_materials_face invalid"
        stop
       endif

       nsolveMM_FACE_test=num_materials_face

      else
       print *,"operation_flag invalid26"
       stop
      endif

      if (nsolveMM_FACE_test.ne.nsolveMM_FACE) then
       print *,"nsolveMM_FACE invalid"
       stop
      endif

      nhalf=3

      ii=0
      jj=0
      kk=0

      if (dir_main.eq.1) then
       ii=1
       if ((i/bfact)*bfact.ne.i) then
        print *,"i invalid"
        stop
       endif
       if (i.lt.0) then
        print *,"i invalid"
        stop
       endif
      else if (dir_main.eq.2) then
       jj=1
       if ((j/bfact)*bfact.ne.j) then
        print *,"j invalid"
        stop
       endif
       if (j.lt.0) then
        print *,"j invalid"
        stop
       endif
      else if ((dir_main.eq.3).and.(SDIM.eq.3)) then
       kk=1
       if ((k/bfact)*bfact.ne.k) then
        print *,"k invalid SEM_MAC_TO_CELL"
        stop
       endif
       if (k.lt.0) then
        print *,"k invalid SEM_MAC_TO_CELL"
        stop
       endif
      else
       print *,"dir_main invalid sem mac to cell2"
       stop
      endif

      do dir2=1,SDIM
       if (fablo(dir2).ge.0) then
        ! do nothing
       else
        print *,"fablo invalid"
        stop
       endif
      enddo ! dir2=1..sdim

      if (dt.le.zero) then
       print *,"dt invalid dt=",dt
       print *,"operation_flag= ",operation_flag
       stop
      endif


      if ((maskSEM.lt.1).or.(maskSEM.gt.nmat)) then
       print *,"maskSEM invalid"
       stop
      endif 

      ibase=(maskSEM-1)*num_state_material

      if ((dir_main.ge.1).and. &
          (dir_main.le.SDIM).and. &
          (bfact.ge.1)) then
       ! do nothing
      else
       print *,"dir_main or bfact invalid200 in SEM_MAC_TO_CELL"
       stop
      endif

      indexlo(1)=i
      indexlo(2)=j
      if (SDIM.eq.3) then
       indexlo(SDIM)=k
      endif
 
      do dir2=1,SDIM
       indexhi(dir2)=indexlo(dir2)
      enddo
      indexhi(dir_main)=indexlo(dir_main)+bfact-1

      cen_outside_domain_flag=0

      do dir2=1,SDIM
       if (indexlo(dir2).lt.fablo(dir2)) then
        if (dir2.eq.dir_main) then
         print *,"indexlo(dir_main) invalid"
         stop
        endif
        if (velbc_in(dir2,1,dir2).ne.INT_DIR) then
         cen_outside_domain_flag=1
        endif
       endif 
       if (indexhi(dir2).gt.fabhi(dir2)) then
        if (dir2.eq.dir_main) then
         print *,"indexhi(dir_main) invalid"
         stop
        endif
        if (velbc_in(dir2,2,dir2).ne.INT_DIR) then
         cen_outside_domain_flag=1
        endif
       endif
      enddo ! dir2=1..sdim


      if (1.eq.0) then
       if (operation_flag.eq.0) then ! right hand side for solver
        if (project_option.eq.10) then ! sync project
         if (level.eq.3) then
          if ((j.eq.0).and.(i.eq.120).and.(k.eq.18)) then
           print *,"TO_CELL: i,j,k,maskSEM,homflag ",i,j,k,maskSEM,homflag
           print *,"dir_main ",dir_main
           print *,"presbc(dir_main,1) ",presbc_in(dir_main,1)  
           print *,"presbc(dir_main,2) ",presbc_in(dir_main,2)  
           print *,"vol01 ", &
            vol(D_DECL(i,j,k)), &
            vol(D_DECL(i+ii,j+jj,k+kk))
           print *,"cterm01 ", &
            cterm(D_DECL(i,j,k),1), &
            cterm(D_DECL(i+ii,j+jj,k+kk),1)
           print *,"mdotcell01 ", &
            mdotcell(D_DECL(i,j,k),1), &
            mdotcell(D_DECL(i+ii,j+jj,k+kk),1)
           print *,"maskcoef01 ", &
            maskcoef(D_DECL(i,j,k)), &
            maskcoef(D_DECL(i+ii,j+jj,k+kk))
           print *,"xvel012 ", &
            xvel(D_DECL(i,j,k),1), &
            xvel(D_DECL(i+ii,j+jj,k+kk),1), &
            xvel(D_DECL(i+2*ii,j+2*jj,k+2*kk),1)
          endif
         endif
        endif
       endif
      endif  ! debugging


      do nc=1,ncomp

       if (cen_outside_domain_flag.eq.1) then
        ! do nothing
       else if (cen_outside_domain_flag.eq.0) then

        do isten=0,bfact

         do dir2=1,SDIM
          indexmid(dir2)=indexlo(dir2)
         enddo
         indexmid(dir_main)=indexlo(dir_main)+isten
 
         ic=indexmid(1)
         jc=indexmid(2)
         kc=indexmid(SDIM)

         if (operation_flag.eq.5) then ! interp grad U^T to cell.
          local_data(isten+1)=xvel(D_DECL(ic,jc,kc),scomp+nc-1)
         else if (operation_flag.eq.6) then ! advection
          if ((nc.ge.1).and.(nc.le.SDIM)) then
           local_data(isten+1)=xface(D_DECL(ic,jc,kc),nc) ! u umac or u
          else if (nc.eq.SDIM+1) then
           local_data(isten+1)=xface(D_DECL(ic,jc,kc),nc) ! rho 
          else if (nc.eq.SDIM+2) then
           local_data(isten+1)=xface(D_DECL(ic,jc,kc),nc) ! temperature
          else
           print *,"nc invalid"
           stop
          endif
          local_vel_data(isten+1)=xvel(D_DECL(ic,jc,kc),1) ! umac
          local_vel_data_div(isten+1)=xvel(D_DECL(ic,jc,kc),1) ! umac

         else if (operation_flag.eq.0) then ! RHS

          if (num_materials_face.eq.1) then
           scompMM_L=nc
           scompMM_R=scompMM_L
          else if (num_materials_face.eq.nmat) then
           if (ncomp.eq.SDIM) then
            scompMM_L=(maskSEM-1)*SDIM+nc
           else if (ncomp.eq.1) then
            scompMM_L=maskSEM
           else
            print *,"ncomp invalid8"
            stop
           endif
           if (nsolveMM_FACE/2.ne.num_materials_face*ncomp) then
            print *,"nsolveMM_FACE invalid"
            stop
           endif
           scompMM_R=scompMM_L+nsolveMM_FACE/2
          else
           print *,"num_materials_face invalid"
           stop
          endif
          local_data(isten+1)=xvel(D_DECL(ic,jc,kc),scompMM_L)
          xflux_R=xvel(D_DECL(ic,jc,kc),scompMM_R)
          if (abs(xflux_R-local_data(isten+1)).gt. &
              VOFTOL*abs(xflux_R)) then
           print *,"xflux_R invalid"
           stop
          endif

         else if (operation_flag.eq.1) then ! divergence

          scompMM_L=1
          scompMM_R=scompMM_L
          local_data(isten+1)=xvel(D_DECL(ic,jc,kc),scompMM_L)
          xflux_R=xvel(D_DECL(ic,jc,kc),scompMM_R)
          if (abs(xflux_R-local_data(isten+1)).gt. &
              VOFTOL*abs(xflux_R)) then
           print *,"xflux_R invalid"
           stop
          endif

         else if (operation_flag.eq.2) then !mac->cell solver or VELMAC_TO_CELL

          scompMM_L=1
          scompMM_R=scompMM_L
          local_data(isten+1)=xvel(D_DECL(ic,jc,kc),scompMM_L)
          xflux_R=xvel(D_DECL(ic,jc,kc),scompMM_R)
          if (abs(xflux_R-local_data(isten+1)).gt. &
              VOFTOL*abs(xflux_R)) then
           print *,"xflux_R invalid"
           stop
          endif

         else if (operation_flag.eq.3) then ! (grad p)_CELL, div(u)p

           ! grad p
          scompMM_L=1
          scompMM_R=scompMM_L
          local_data(isten+1)=xp(D_DECL(ic,jc,kc),2+scompMM_L)
          xflux_R=xp(D_DECL(ic,jc,kc),2+scompMM_R)
          if (abs(xflux_R-local_data(isten+1)).gt. &
              VOFTOL*abs(xflux_R)) then
           print *,"xflux_R invalid"
           stop
          endif

           ! p div u
          if (1.eq.0) then
           local_data_up(isten+1)=xp(D_DECL(ic,jc,kc),2+scompMM_L)* &
            xvel(D_DECL(ic,jc,kc),scompMM_L)
           xflux_R=xp(D_DECL(ic,jc,kc),2+scompMM_R)* &
            xvel(D_DECL(ic,jc,kc),scompMM_R)
          else
           local_data_up(isten+1)= &
            xvel(D_DECL(ic,jc,kc),scompMM_L)
           xflux_R=xvel(D_DECL(ic,jc,kc),scompMM_R)
          endif

          if (abs(xflux_R-local_data_up(isten+1)).gt. &
              VOFTOL*abs(xflux_R)) then
           print *,"xflux_R invalid"
           stop
          endif

         else if (operation_flag.eq.4) then ! (grad ppot)_CELL

          local_data(isten+1)=xp(D_DECL(ic,jc,kc),1)

         else
          print *,"operation_flag invalid27"
          stop
         endif

         RR=one

         if (dir_main.eq.1) then  ! r direction

          call gridstenMAC(xstenMAC,xlo, &
           ic,jc,kc, &
           fablo,bfact,dx,nhalf,dir_main)

          if (levelrz.eq.0) then
           ! do nothing
          else if (levelrz.eq.1) then
           RR=xstenMAC(0,1)
           if (SDIM.ne.2) then
            print *,"dimension bust"
            stop
           endif
          else if (levelrz.eq.3) then
           RR=xstenMAC(0,1)
          else
           print *,"levelrz invalid"
           stop
          endif

         else if ((dir_main.eq.2).or.(dir_main.eq.SDIM)) then
          ! do nothing
         else
          print *,"dir_main invalid sem mac to cell 3"
          stop
         endif 

         if (operation_flag.eq.5) then ! interp grad U^T
          ! do nothing
         else if (operation_flag.eq.0) then !RHS
          local_data(isten+1)=local_data(isten+1)*RR
         else if (operation_flag.eq.6) then !advection
          local_data(isten+1)=local_data(isten+1)*RR
          local_vel_data_div(isten+1)=local_vel_data_div(isten+1)*RR
         else if (operation_flag.eq.1) then !divergence
          local_data(isten+1)=local_data(isten+1)*RR
         else if (operation_flag.eq.2) then !mac->cell solver or VELMAC_TO_CELL
          local_data(isten+1)=local_data(isten+1)*RR
         else if (operation_flag.eq.3) then !(grad p)_CELL, div (u)p
          local_data_up(isten+1)=local_data_up(isten+1)*RR
         else if (operation_flag.eq.4) then !(grad ppot)_CELL
          ! do nothing
         else
          print *,"operation_flag invalid28"
          stop
         endif

        enddo ! isten=0..bfact

        do side=1,2

         nbr_outside_domain_flag(side)=0

         do dir2=1,SDIM
          sideidx(dir2)=indexlo(dir2)
         enddo

         if (side.eq.1) then
          sideidx(dir_main)=indexlo(dir_main)-1
          do dir2=1,SDIM
           if (sideidx(dir2).lt.fablo(dir2)) then
            if (velbc_in(dir2,side,dir2).ne.INT_DIR) then
             nbr_outside_domain_flag(side)=1
            endif
           endif
          enddo ! dir2=1..sdim

          i_out=indexlo(1)-ii
          j_out=indexlo(2)-jj
          k_out=indexlo(SDIM)-kk

         else if (side.eq.2) then

          sideidx(dir_main)=indexhi(dir_main)+1
          do dir2=1,SDIM
           if (sideidx(dir2).gt.fabhi(dir2)) then
            if (velbc_in(dir2,side,dir2).ne.INT_DIR) then
             nbr_outside_domain_flag(side)=1
            endif
           endif
          enddo ! dir2=1..sdim

          i_out=indexhi(1)+ii
          j_out=indexhi(2)+jj
          k_out=indexhi(SDIM)+kk

         else 
          print *,"side invalid"
          stop
         endif

         if (nbr_outside_domain_flag(side).eq.0) then

          ! do nothing
 
         else if (nbr_outside_domain_flag(side).eq.1) then 

          if (velbc_in(dir_main,side,dir_main).eq.INT_DIR) then
           print *,"velbc_in bust "
           print *,"cen_outside_domain_flag= ",cen_outside_domain_flag
           print *,"nbr_outside_domain_flag= ",nbr_outside_domain_flag(side)
           stop
          endif

          if (operation_flag.eq.5) then ! grad u^T: MAC->CELL
         
             ! u_x,v_x,w_x, u_y,v_y,w_y, u_z,v_z,w_z;  
           if ((velbc_in(dir_main,side,scomp_bc+nc-1).eq.REFLECT_EVEN).or. &
               (velbc_in(dir_main,side,scomp_bc+nc-1).eq.FOEXTRAP)) then
            if (side.eq.1) then
             local_data(1)=zero
            else if (side.eq.2) then
             local_data(bfact+1)=zero
            else
             print *,"side invalid"
             stop
            endif
           else if (velbc_in(dir_main,side,scomp_bc+nc-1).eq.REFLECT_ODD) then
            ! do nothing
           else if (velbc_in(dir_main,side,scomp_bc+nc-1).eq.EXT_DIR) then
            ! do nothing
           else
            print *,"velbc_in is corrupt"
            stop
           endif
          else if (operation_flag.eq.0) then!RHS
           ! do nothing
          else if (operation_flag.eq.6) then!advection
           ! do nothing
          else if (operation_flag.eq.1) then!divergence
           ! do nothing
          else if (operation_flag.eq.2) then!mac->cell solver or VELMAC_TO_CELL
           ! do nothing
          else if (operation_flag.eq.3) then!(grad p)_CELL, div(u)p
           ! do nothing
          else if (operation_flag.eq.4) then!(grad ppot)_CELL
           ! do nothing
          else
           print *,"operation_flag invalid29"
           stop
          endif

         else
          print *,"nbr_outside_domain_flag invalid 5"
          stop
         endif

        enddo ! side=1..2

         ! mask=0 piecewise FV  mask>0 SEM
        call line_MAC_TO_CELL(local_data,local_cell,local_div, &
         bfact,maskSEM,dx(dir_main))

        if (operation_flag.eq.3) then
         call line_MAC_TO_CELL(local_data_up,local_cell_up,local_div_up, &
          bfact,maskSEM,dx(dir_main))
        else if (operation_flag.eq.6) then
         if ((nc.ge.1).and.(nc.le.SDIM+2)) then
          call line_MAC_TO_CELL(local_vel_data,local_vel_cell,local_vel_div, &
           bfact,maskSEM,dx(dir_main))
          call line_MAC_TO_CELL(local_vel_data_div, &
           local_vel_cell_div,local_vel_div_div, &
           bfact,maskSEM,dx(dir_main))
         else
          print *,"nc invalid"
          stop
         endif
        endif

        do isten=0,bfact-1

         indexlo(1)=i
         indexlo(2)=j
         if (SDIM.eq.3) then
          indexlo(SDIM)=k
         endif
         do dir2=1,SDIM
          indexmid(dir2)=indexlo(dir2)
         enddo ! dir2

         indexmid(dir_main)=indexlo(dir_main)+isten

         ic=indexmid(1)
         jc=indexmid(2)
         kc=indexmid(SDIM)

         RR=one
         RRTHETA=one

         call gridsten(xsten,xlo, &
          ic,jc,kc, &
          fablo,bfact,dx,nhalf)

         if (dir_main.eq.1) then ! r direction

          if (levelrz.eq.0) then
           RR=one
          else if (levelrz.eq.1) then
           if (SDIM.eq.2) then
            RR=xsten(0,1)
           else
            print *,"dimension bust"
            stop
           endif
          else if (levelrz.eq.3) then
           RR=xsten(0,1)
          else
           print *,"levelrz invalid"
           stop
          endif

         else if ((dir_main.eq.2).or.(dir_main.eq.SDIM)) then
          RR=one
         else
          print *,"dir_main invalid sem mac to cell 4"
          stop
         endif 

         if ((dir_main.eq.2).and.(levelrz.eq.3)) then ! theta direction
          RRTHETA=xsten(0,1)
         endif

         if (operation_flag.eq.5) then ! interp grad U

          veldest(D_DECL(ic,jc,kc),dcomp+nc-1)=local_cell(isten+1)

         else if (operation_flag.eq.6) then ! advection

          if ((nc.ge.1).and.(nc.le.ncomp)) then

           if (dir_main.eq.1) then
            RR_divide=RR
           else if ((dir_main.eq.2).or.(dir_main.eq.SDIM)) then
            RR_divide=RRTHETA
           else
            print *,"dir_main invalid"
            stop
           endif

            ! local_data (the MAC data) is multiplied by RR above.

            ! velocity = div (umac u) - u div(u)
            ! mdotcell corresponds to VELADVECT_MF in the caller.
           if ((nc.ge.1).and.(nc.le.SDIM)) then ! velocity
            if ((conservative_div_uu.eq.1).or. &
                (conservative_div_uu.eq.2)) then
             local_div(isten+1)=local_div(isten+1)- &
                mdotcell(D_DECL(ic,jc,kc),nc)*local_vel_div_div(isten+1)
            else if (conservative_div_uu.eq.0) then
             local_div(isten+1)=local_div(isten+1)*local_vel_cell(isten+1)
            else
             print *,"conservative_div_uu invalid"
             stop
            endif
           else if (nc.eq.SDIM+1) then ! density
            local_div(isten+1)=local_div(isten+1)*local_vel_cell(isten+1)
           else if (nc.eq.SDIM+2) then ! temperature
            local_div(isten+1)=local_div(isten+1)*local_vel_cell(isten+1)
           else
            print *,"nc invalid"
            stop
           endif
           local_div(isten+1)=local_div(isten+1)/RR_divide

            ! divdest corresponds to rhs
            ! rhs corresponds to (*rhs)[mfi]
           if (dir_main.eq.1) then ! r direction
            divdest(D_DECL(ic,jc,kc),nc)=local_div(isten+1)
           else if ((dir_main.eq.2).or.(dir_main.eq.SDIM)) then
            divdest(D_DECL(ic,jc,kc),nc)= &
             divdest(D_DECL(ic,jc,kc),nc)+local_div(isten+1)
           else
            print *,"dir_main invalid mac to cell 5"
            stop
           endif

           if ((dir_main.eq.SDIM).and.(nc.eq.ncomp)) then
      
            if (source_term.eq.1) then 
             ! do nothing
            else if (source_term.eq.0) then

             if ((slab_step.lt.0).or.(slab_step.ge.bfact_time_order)) then
              print *,"slab_step invalid"
              stop
             endif 

             do nc2=1,ncomp
              divflux(nc2)=divdest(D_DECL(ic,jc,kc),nc2)
             enddo ! nc2

             den_old=denold(D_DECL(ic,jc,kc),ibase+1)
             den_new=den_old-dt*divflux(SDIM+1)

              ! SDC correction term: mass
             if ((ns_time_order.ge.2).and. &
                 (ns_time_order.le.32).and. &
                 (advect_iter.eq.1).and. &
                 (SDC_outer_sweeps.gt.0).and. &
                 (divu_outer_sweeps+1.eq.num_divu_outer_sweeps)) then
              den_new=den_new-cterm(D_DECL(ic,jc,kc),SDIM+1)
             else if ((ns_time_order.eq.1).or. &
                      (advect_iter.eq.0).or. &
                      (SDC_outer_sweeps.eq.0).or. &
                      (divu_outer_sweeps+1.lt.num_divu_outer_sweeps)) then
              ! do nothing
             else
              print *,"ns_time_order, SDC_outer_sweeps, or divu_outer.. bad"
              stop
             endif
 
             if (den_new.le.zero) then
              print *,"den_new underflow"
              print *,"dt=",dt
              print *,"divflux= ",divflux(SDIM+1)
              print *,"cterm= ",cterm(D_DECL(ic,jc,kc),SDIM+1)
              print *,"advect_iter =",advect_iter
              print *,"ic,jc,kc ",ic,jc,kc
              print *,"level,finest_level ",level,finest_level
              print *,"maskSEM= ",maskSEM
              stop
             endif

             do nc2=1,SDIM
              velcomp=nc2
              vel_old=ustar(D_DECL(ic,jc,kc),velcomp) 
              mom_new=vel_old-dt*divflux(nc2)

               ! SDC correction term: momentum
              if ((ns_time_order.ge.2).and. &
                  (ns_time_order.le.32).and. &
                  (advect_iter.eq.1).and. &
                  (SDC_outer_sweeps.gt.0).and. &
                  (divu_outer_sweeps+1.eq.num_divu_outer_sweeps)) then
               mom_new=mom_new-cterm(D_DECL(ic,jc,kc),nc2)
              else if ((ns_time_order.eq.1).or. &
                       (advect_iter.eq.0).or. &
                       (SDC_outer_sweeps.eq.0).or. &
                       (divu_outer_sweeps+1.lt.num_divu_outer_sweeps)) then
               ! do nothing
              else
               print *,"ns_time_order, SDC_outer_sweeps, or divu_outer.. bad"
               stop
              endif

              vel_new(nc2)=mom_new
             enddo ! nc2=1..sdim

             T_old=denold(D_DECL(ic,jc,kc),ibase+2)
             T_new=T_old-dt*divflux(SDIM+2)

               ! SDC correction term: energy
             if ((ns_time_order.ge.2).and. &
                 (ns_time_order.le.32).and. &
                 (advect_iter.eq.1).and. &
                 (SDC_outer_sweeps.gt.0).and. &
                 (divu_outer_sweeps+1.eq.num_divu_outer_sweeps)) then
                ! cterm corresponds to (*localMF[delta_MF])[mfi]
              T_new=T_new-cterm(D_DECL(ic,jc,kc),SDIM+2)
             else if ((ns_time_order.eq.1).or. &
                      (advect_iter.eq.0).or. &
                      (SDC_outer_sweeps.eq.0).or. &
                      (divu_outer_sweeps+1.lt.num_divu_outer_sweeps)) then
              ! do nothing
             else
              print *,"ns_time_order, SDC_outer_sweeps, or divu_outer.. bad"
              stop
             endif

             if (T_new.lt.fort_tempcutoff(maskSEM)) then
              T_new=fort_tempcutoff(maskSEM)
             endif
             if (T_new.gt.fort_tempcutoffmax(maskSEM)) then
              T_new=fort_tempcutoffmax(maskSEM)
             endif 

             if (T_new.le.zero) then
              print *,"T_new underflow"
              print *,"dt=",dt
              print *,"divflux (div(rho u))= ",divflux(SDIM+1)
              print *,"divflux (u dot grad T)= ",divflux(SDIM+2)
              print *,"cterm= ",cterm(D_DECL(ic,jc,kc),SDIM+2)
              print *,"energyflag (advect_iter) =",energyflag
              print *,"ic,jc,kc ",ic,jc,kc
              stop
             endif

             do nc2=1,SDIM
              velcomp=nc2
              veldest(D_DECL(ic,jc,kc),velcomp)=vel_new(nc2)
             enddo ! nc2
             dendest(D_DECL(ic,jc,kc),ibase+2)=T_new

             imattype=fort_material_type(maskSEM)
             if (imattype.eq.999) then
              ! do nothing
             else if (imattype.eq.0) then
              ! do nothing
             else if ((imattype.gt.0).and. &
                      (imattype.le.fort_max_num_eos)) then
              dendest(D_DECL(ic,jc,kc),ibase+1)=den_new
             else
              print *,"imattype invalid SEM_MAC_TO_CELL"
              stop
             endif

            else
             print *,"source_term invalid"
             stop
            endif

           else if (((dir_main.ge.1).and.(dir_main.lt.SDIM)).or. &
                    ((nc.ge.1).and.(nc.lt.ncomp))) then
            ! do nothing
           else
            print *,"dir_main or nc invalid"
            stop    
           endif 

          else
           print *,"nc out of range"
           stop
          endif 

         else if (operation_flag.eq.0) then ! RHS

          if (maskcoef(D_DECL(ic,jc,kc)).eq.one) then ! not covered

           if (num_materials_face.eq.1) then
            velcomp=nc
           else if (num_materials_face.eq.nmat) then
            velcomp=(maskSEM-1)*ncomp+nc
           else
            print *,"num_materials_face invalid"
            stop
           endif
           if (dir_main.eq.1) then
            divdest(D_DECL(ic,jc,kc),velcomp)= &
             local_div(isten+1)/RR
           else if ((dir_main.ge.2).and. &
                    (dir_main.le.SDIM)) then
            divdest(D_DECL(ic,jc,kc),velcomp)= &
             divdest(D_DECL(ic,jc,kc),velcomp)+ &
             local_div(isten+1)/RRTHETA
           else
            print *,"dir_main invalid mac to cell 6"
            stop
           endif

           if (dir_main.eq.SDIM) then
            VOLTERM=vol(D_DECL(ic,jc,kc))
            if (VOLTERM.gt.zero) then
             ! do nothing
            else
             print *,"VOLTERM invalid"
             stop
            endif
            divu=divdest(D_DECL(ic,jc,kc),velcomp)*VOLTERM
            CC=cterm(D_DECL(ic,jc,kc),velcomp) ! already x VOLTERM
            CC_DUAL=veldest(D_DECL(ic,jc,kc),velcomp) ! already x VOLTERM
            if (CC_DUAL.eq.CC) then
             ! do nothing
            else
             print *,"CC_DUAL invalid"
             stop
            endif

            MDOT=mdotcell(D_DECL(ic,jc,kc),velcomp)

            if (CC.ge.zero) then
             ! do nothing
            else
             print *,"CC invalid in SEM_MAC_TO_CELL"
             stop
            endif

            if (1.eq.0) then
             if (CC.eq.zero) then
              ! do nothing
             else
              print *,"CC should be 0 for incompressible fluids"
              stop
             endif
             if (MDOT.ne.zero) then
              print *,"expecting MDOT=0   MDOT=",MDOT
              print *,"ic,jc,kc,nc ",ic,jc,kc,nc
              stop
             endif
            endif

             ! divu=-dt VOLTERM * div(k grad T)  project_option==2
             ! divu=-dt VOLTERM * visc_coef div(2 mu D) project_option==3
             ! use_dt=1 dir=-1
             ! use_HO=1
             ! enable_spectral=1
             ! constant_viscosity=1
            local_div_val=divu/VOLTERM
            call SEM_VISC_SANITY(10,dt,xsten,nhalf,local_div_val, &
              -1,velcomp,1,1,project_option,bfact,1,1)

             ! MSKDV=1.0d0
             ! MSKRES=1.0d0
            call SEM_VISC_SANITY_CC(2,dt,CC,1.0d0,1.0d0,MDOT, &
              VOLTERM,project_option,xsten,nhalf,velcomp)

            local_POLD=pold(D_DECL(ic,jc,kc),velcomp)
            local_POLD_DUAL=dendest(D_DECL(ic,jc,kc),velcomp)

            if (homflag.eq.0) then
             if (local_POLD.eq.local_POLD_DUAL) then
              RHS=local_POLD*CC
             else
              print *,"local_POLD invalid"
              stop
             endif
            else if (homflag.eq.1) then
             if (local_POLD.eq.local_POLD_DUAL) then
              RHS=local_POLD*CC
             else
              print *,"local_POLD invalid"
              stop
             endif
            else if (homflag.eq.2) then
             if (local_POLD.eq.local_POLD_DUAL) then
              RHS=-local_POLD*CC
             else
              print *,"local_POLD invalid"
              stop
             endif
            else if (homflag.eq.3) then
             if ((local_POLD.eq.zero).and.(local_POLD_DUAL.eq.zero)) then
              RHS=zero
             else
              print *,"local_POLD or local_POLD_DUAL invalid"
              stop
             endif
            else if (homflag.eq.4) then
             if (local_POLD.eq.local_POLD_DUAL) then
              RHS=zero
             else
              print *,"local_POLD invalid"
              stop
             endif
            else
             print *,"homflag invalid 10"
             stop
            endif

            if (homflag.eq.0) then
             RHS=RHS-divu/dt+MDOT
            else if (homflag.eq.1) then
             RHS=RHS+divu/dt
            else if (homflag.eq.2) then
             RHS=RHS-divu/dt+MDOT
            else if (homflag.eq.3) then
             RHS=-divu/dt+MDOT
             if (level.eq.finest_level) then
              if (divu.eq.zero) then
               ! do nothing
              else 
               print *,"divu invalid"
               stop
              endif
             else if ((level.ge.0).and.(level.lt.finest_level)) then
              ! do nothing
             else
              print *,"level invalid"
              stop
             endif
            else if (homflag.eq.4) then
             if (RHS.eq.zero) then
              RHS=divu/VOLTERM
             else
              print *,"RHS invalid"
              stop
             endif
            else
             print *,"homflag invalid"
             stop
            endif

            divdest(D_DECL(ic,jc,kc),velcomp)=RHS
           else if ((dir_main.ge.1).and.(dir_main.lt.SDIM)) then
            ! do nothing
           else
            print *,"dir_main invalid mac_to_cell 7"
            stop
           endif 

          else if (maskcoef(D_DECL(ic,jc,kc)).eq.zero) then
           ! do nothing (covered)
          else 
           print *,"maskcoef invalid"
           stop
          endif

         else if (operation_flag.eq.1) then ! div

          velcomp=1
          if (dir_main.eq.1) then
           divdest(D_DECL(ic,jc,kc),velcomp)= &
            local_div(isten+1)/RR
          else if ((dir_main.eq.2).or. &
                   (dir_main.eq.SDIM)) then
           divdest(D_DECL(ic,jc,kc),velcomp)= &
            divdest(D_DECL(ic,jc,kc),velcomp)+ &
            local_div(isten+1)/RRTHETA
          else
           print *,"dir_main invalid sem mac to cell 9"
           stop
          endif

         else if (operation_flag.eq.2) then !mac->cell solver or VELMAC_TO_CELL
           ! local_data (the MAC data) is multiplied by RR above.
          velcomp=dir_main
          veldest(D_DECL(ic,jc,kc),velcomp)= &
           local_cell(isten+1)/RR

         else if (operation_flag.eq.3) then ! (grad p)_CELL, p div(u)

           ! maskSEM=0 if FSI_flag(im)=1,2,3,4,5,6
          ibase=num_state_material*(maskSEM-1)

          prescell=pold(D_DECL(ic,jc,kc),1)

          dencell=dendest(D_DECL(ic,jc,kc),ibase+1)
            ! dt * gradp/rho
          dp=dt*local_div(isten+1)/(RRTHETA*dencell)

          if (dencell.le.zero) then
           print *,"dencell invalid"
           stop
          endif

          velcomp=dir_main

          if ((energyflag.eq.0).or. &
              (energyflag.eq.1)) then
           if (face_flag.eq.0) then
            veldest(D_DECL(ic,jc,kc),velcomp)= &
             ustar(D_DECL(ic,jc,kc),velcomp)-dp
           else if (face_flag.eq.1) then
            ! do nothing (veldest already init when operation_flag==2)
           else
            print *,"face_flag invalid"
            stop
           endif
          else if (energyflag.eq.2) then
           if (face_flag.eq.0) then
             ! gradp
            ustar(D_DECL(ic,jc,kc),velcomp)=local_div(isten+1)/RRTHETA
           else if (face_flag.eq.1) then
            ustar(D_DECL(ic,jc,kc),velcomp)=zero
           else
            print *,"face_flag invalid"
            stop
           endif
          else
           print *,"energyflag invalid"
           stop
          endif

          velcomp=1

           ! p (div u) 
          if (dir_main.eq.1) then
           divdest(D_DECL(ic,jc,kc),velcomp)= &
            prescell*local_div_up(isten+1)/RR
          else if ((dir_main.eq.2).or.(dir_main.eq.SDIM)) then
           divdest(D_DECL(ic,jc,kc),velcomp)= &
            divdest(D_DECL(ic,jc,kc),velcomp)+ &
            prescell*local_div_up(isten+1)/RRTHETA
          else
           print *,"dir_main invalid sem mac to cell 11"
           stop
          endif

          if (dir_main.eq.SDIM) then

           if ((project_option.eq.0).or. &
               (project_option.eq.13)) then !FSI_material_exists 1st project

            if ((maskSEM.ge.1).and.(maskSEM.le.nmat)) then

             if (energyflag.eq.1) then ! update temperature

              if (local_incomp.eq.0) then

               TEMPERATURE=dendest(D_DECL(ic,jc,kc),ibase+2)
               if (TEMPERATURE.le.zero) then
                print *,"temperature underflow"
                stop
               endif
               ! ibase+1 = den
               ! ibase+2 = T
               Eforce=-dt*divdest(D_DECL(ic,jc,kc),velcomp)/dencell

               call init_massfrac_parm(dencell,massfrac_parm,maskSEM)
               do ispec=1,num_species_var
                massfrac_parm(ispec)= &
                 dendest(D_DECL(ic,jc,kc),ibase+2+ispec)
               enddo
               call INTERNAL_material(dencell,massfrac_parm, &
                 TEMPERATURE,internal_e, &
                 imattype,maskSEM)
               internal_e=internal_e+Eforce
               if (internal_e.gt.zero) then
                call TEMPERATURE_material(dencell,massfrac_parm, &
                  T_new, &
                  internal_e,imattype,maskSEM)
                if (T_new.gt.zero) then
                 dendest(D_DECL(ic,jc,kc),ibase+2)=T_new
                else
                 print *,"T_new must be positive"
                 stop
                endif
               endif ! internal_e > 0

              else if (local_incomp.eq.1) then

               divdest(D_DECL(ic,jc,kc),velcomp)=zero

              else
               print *,"local_incomp invalid"
               stop
              endif

             else if (energyflag.eq.2) then

              if (local_incomp.eq.0) then
               ! do nothing
              else if (local_incomp.eq.1) then
               divdest(D_DECL(ic,jc,kc),velcomp)=zero
              else
               print *,"local_incomp invalid"
               stop
              endif
             
             else if (energyflag.eq.0) then
              ! do nothing
             else
              print *,"energyflag invalid"
              stop 
             endif

            else
             print *,"maskSEM invalid"
             stop
            endif

           else if (project_option.eq.1) then
            ! do nothing if initial project
           else if (project_option.eq.10) then
            ! do nothing if sync project
           else if (project_option.eq.11) then !FSI_material_exists 2nd 
            ! do nothing if rigid body project
           else if (project_option.eq.12) then
            print *,"extension project should be low order"
            stop
           else
            print *,"project_option invalid sem mac to cell"
            stop
           endif

          else if ((dir_main.eq.1).or.(dir_main.eq.SDIM-1)) then
           ! do nothing
          else
           print *,"dir_main invalid sem mac to cell 13"
           stop
          endif 

         else if (operation_flag.eq.4) then ! (grad ppot)_CELL
          dencell=denold(D_DECL(ic,jc,kc),1)
          if (dencell.le.zero) then
           print *,"hydrostatic density must be positive"
           stop
          endif
          veldest(D_DECL(ic,jc,kc),dir_main)= &
           local_div(isten+1)/(dencell*RRTHETA)
         else
          print *,"operation_flag invalid30"
          stop
         endif
         
        enddo ! isten=0...bfact-1

       else
        print *,"cen_outside_domain_flag invalid"
        stop
       endif 

      enddo ! nc=1..ncomp

      return
      end subroutine SEM_MAC_TO_CELL


       ! 1<=dir<=sdim  1<=side<=2
       ! 1<=veldir<=sdim
       ! input: vel_in
       ! output: vel_in
      subroutine velbc_override(time,dir,side,veldir,vel_in, &
        xsten,nhalf,dx,bfact)
      use global_utility_module
      use rainControl_module
      use bubbleControl_module
      use hydrateReactor_module
      use unimaterialChannel_module
      use River
      use shockdrop
      use USERDEF_module
      use CAV3D_module
      use HELIX_module
      use TSPRAY_module
      use CAV2Dstep_module
      use ZEYU_droplet_impact_module
      use CONE3D_module
      use WAVY_Channel_module
      use rigid_FSI_module
      use sinking_particle_module

      IMPLICIT NONE

      REAL_T, intent(in) :: dx(SDIM)
      INTEGER_T, intent(in) :: dir,side,veldir,bfact
      INTEGER_T, intent(in) :: nhalf
      REAL_T, intent(in) :: xsten(-nhalf:nhalf,SDIM)
      REAL_T vel
      REAL_T, intent(inout) :: vel_in
      REAL_T x,y,z,r
      REAL_T, intent(in) ::time
      REAL_T x_vel,y_vel,z_vel
      REAL_T dist
      INTEGER_T error
      REAL_T costheta,sintheta
      REAL_T xprime,yprime,zprime
      REAL_T velcell(SDIM)
      INTEGER_T dir2
      INTEGER_T nmat
      REAL_T velx_rain,vely_rain
      REAL_T xvec(SDIM)
      INTEGER_T local_dir
      REAL_T xwall
      REAL_T local_LS(num_materials)
      
      velx_rain=adv_vel
      vely_rain=uDrop

      if (nhalf.lt.3) then
       print *,"nhalf invalid velbc override"
       print *,"nhalf= ",nhalf
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)
      do local_dir=1,SDIM
       xvec(local_dir)=xsten(0,local_dir)
      enddo
      xwall=xvec(dir)

      if (SDIM.eq.2) then
       if (abs(z-y).gt.VOFTOL) then
        print *,"z=y expected in 2D 2"
        stop
       endif
      endif

      vel=vel_in*global_velocity_scale

      if (vel_homflag.eq.1) then
       vel_in=zero
      else if (vel_homflag.eq.0) then

       nmat=num_materials
      
       do dir2=1,SDIM
        velcell(dir2)=zero
       enddo

       if (is_in_probtype_list().eq.1) then
        call SUB_LS(xvec,time,local_LS,num_materials)
        call SUB_VEL_BC(xwall,xvec,time,local_LS, &
         velcell(veldir),vel,veldir,dir,side,dx,num_materials)
       else if (probtype.eq.411) then
        call CAV3D_LS(xvec,time,local_LS)
        call CAV3D_VEL_BC(xwall,xvec,time,local_LS, &
         velcell(veldir),vel,veldir,dir,side,dx)
       else if (probtype.eq.401) then
        call HELIX_LS(xvec,time,local_LS)
        call HELIX_VEL_BC(xwall,xvec,time,local_LS, &
         velcell(veldir),vel,veldir,dir,side,dx)
       else if (probtype.eq.402) then
        call TSPRAY_LS(xvec,time,local_LS)
        call TSPRAY_VEL_BC(xwall,xvec,time,local_LS, &
         velcell(veldir),vel,veldir,dir,side,dx)
       else if (probtype.eq.412) then ! step
        call CAV2Dstep_LS(xvec,time,local_LS)
        call CAV2Dstep_VEL_BC(xwall,xvec,time,local_LS, &
         velcell(veldir),vel,veldir,dir,side,dx)

       else if (probtype.eq.413) then ! ZEYU droplet impact
        call ZEYU_droplet_impact_LS(xvec,time,local_LS)
        ! pass dx
        call ZEYU_droplet_impact_VEL_BC(xwall,xvec,time,local_LS, &
         velcell(veldir),vel,veldir,dir,side,dx)

       else if (probtype.eq.533) then
        call rigid_FSI_LS(xvec,time,local_LS)
        call rigid_FSI_VEL_BC(xwall,xvec,time,local_LS, &
         velcell(veldir),vel,veldir,dir,side,dx)
       else if (probtype.eq.534) then
        call sinking_FSI_LS(xvec,time,local_LS)
        call sinking_FSI_VEL_BC(xwall,xvec,time,local_LS, &
         velcell(veldir),vel,veldir,dir,side,dx)

       else if (probtype.eq.311) then ! user defined

        call USERDEF_LS(xvec,time,local_LS)
        call USERDEF_VEL_BC(xwall,xvec,time,local_LS, &
         velcell(veldir),vel,veldir,dir,side,dx)

       else if (probtype.eq.222) then ! cone3d in velbc_override

        call CONE3D_LS(xvec,time,local_LS)
        call CONE3D_VEL_BC(xwall,xvec,time,local_LS, &
         velcell(veldir),vel,veldir,dir,side,dx)

       else if (probtype.eq.915) then ! wavy channel

        call WAVY_INIT_LS(xvec,time,local_LS)
        call WAVY_VEL_BC(xwall,xvec,time,local_LS, &
         velcell(veldir),vel,veldir,dir,side,dx)

        ! velbc_override
       else if ((probtype.eq.26).and. &
                ((axis_dir.eq.10).or. &  ! BCG test
                 (axis_dir.eq.11))) then ! BCG_periodic test  
                                         ! (should not come here)
        do dir2=1,SDIM
         velcell(dir2)=zero
        enddo

       else if (probtype.eq.82) then ! annulus
        do dir2=1,SDIM
         velcell(dir2)=zero
        enddo
 
        ! in: velbc_override
       else if (probtype.eq.199) then ! hydrates

        call HYD_VELO_BC(time,dir,side,veldir, &
         velcell(veldir),vel,x,y,z,dx)

        ! in: velbc_override
       else if (probtype.eq.220) then ! UNIMAT problem

        call UNIMAT_VELO_BC(time,dir,side,veldir, &
         velcell(veldir),vel,x,y,z,dx)

       else if ((probtype.eq.299).or. &
                (probtype.eq.301)) then !melting (boundary condition velocity)
        do dir2=1,SDIM
         velcell(dir2)=zero
        enddo
       else if ((probtype.eq.1).and. &
                ((axis_dir.eq.150).or. &
                 (axis_dir.eq.151))) then
        call shockdrop_velocity(x,y,z,velcell, &
         xblob,yblob,zblob,radblob,zblob2,axis_dir)
       else if (probtype.eq.209) then ! River
        if (dir.eq.SDIM) then
         call RiverVelocity(x,y,z,velcell,axis_dir,probloz,probhiz)
        else
         print *,"dir invalid in velbc_override"
         stop
        endif
       else if ((probtype.eq.1).and.(axis_dir.eq.15)) then
        call Zuzio_velbc(time,dir,side,veldir, &
         velcell(veldir),vel)
       else 
 
        if (side.eq.1) then
  
           ! xlo
         if (dir.eq.1) then
   
           ! xlo,xvel
          if (veldir.eq.1) then
  
           if (adv_dir.eq.1)then
            call rampvel(time,x_vel)  ! default is adv_vel
           else  
            x_vel = zero
           endif
  
           velcell(veldir)=x_vel  ! xlo, velx

           if (probtype.eq.bubbleInPackedColumn) then ! xlo,velx
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if (SDIM.eq.2) then
  
            if (probtype.eq.28) then
             call zalesakuu(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.29) then
             call deformuu(velcell(veldir),x,y,time,dx)
            else if (probtype.eq.31) then ! xlo,velx
             call circleuu(velcell(veldir),x,y,y)
            else if ((probtype.eq.1).and.(axis_dir.eq.11)) then
             velcell(veldir)=vinletgas*(y/yblob-one) 
            else if (probtype.eq.58) then
             velcell(veldir)=zero
            else if (probtype.eq.802) then ! dissolution, xlo,velx
             print *,"802 obsolete"
             stop
            else if (probtype.eq.110) then
             call get_bump_velocity(xsten,nhalf,dx,bfact,velcell(veldir),time)  ! xvel,xlo 
            else if (probtype.eq.59) then ! xvel,xlo,velbc_override 2d
             ! vel=solidvel in solid
             call mask_velocity(xsten,nhalf,dx,bfact,velcell,time,nmat)
            else if (probtype.eq.710) then ! xvel,xlo,velbc_override 2d
             ! vel=solidvel in solid
             call mask_velocity(xsten,nhalf,dx,bfact,velcell,time,nmat)
            else if (probtype.eq.532) then
             call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell) ! xvel,xlo
            else if (probtype.eq.5700) then  ! xvel,xlo
             call microfluidic_velbc(xsten,nhalf,dir,side,velcell)
            endif

           else if (SDIM.eq.3) then

            if ((probtype.eq.59).or. &
                (probtype.eq.710)) then ! xvel,xlo,velbc_override 3d
               ! vel=solvel in sol
             call mask_velocity(xsten,nhalf,dx,bfact,velcell,time,nmat) 
            else if (probtype.eq.5501) then  ! xvel,xlo,velbc_override
               ! vel=solvel in sol
             call mask_velocity(xsten,nhalf,dx,bfact,velcell,time,nmat) 
   
! XIAOYI LI : Adding turbulent boundary layer for gas flow          
            else if (probtype.eq.53) then
!          call BL_inlet(velcell(veldir),z,time)  
            else if (probtype.eq.529) then ! airblast inlet
             r = sqrt((y-yblob)**2+(z-zblob)**2)
             if( (r.le.radblob2) .and. (r.ge.radblob+twall) ) then ! gas co-flow
              velcell(veldir) = adv_vel
             else if (r.le.radblob) then ! liquid injection
              velcell(veldir) = advbot
             else
              velcell(veldir) = zero
             endif
   
! gear problem
            else if (probtype.eq.563) then
             if (levelrz.eq.0) then
              if (radblob.gt.zero) then
               if (sqrt((y-yblob)**2+(z-zblob)**2).le.radblob) then
                velcell(veldir)=advbot
               endif
              endif
             else
              print *,"levelrz invalid velbc override"
              stop
             endif
            else if (probtype.eq.58) then
              velcell(veldir)=zero
            else if (probtype.eq.28) then
              call zalesakuu(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.29) then
              call deform3duu(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.51) then
              velcell(veldir)=zero
            else if (probtype.eq.50) then
              if ((z.lt.zblob-radblob).or.(z.gt.zblob+radblob).or. &
                  (y.lt.yblob-radblob).or.(y.gt.yblob+radblob)) then
               velcell(veldir)=zero
              endif
! xlo, velx 3D
            else if (probtype.eq.41) then 
             velcell(veldir)=zero
            endif
! microfluidics problem horizontal vel xlo inflow
            if (probtype.eq.5700) then  ! xvel,xlo
             call microfluidic_velbc(xsten,nhalf,dir,side,velcell)
            endif

           else
            print *,"dimension bust"
            stop
           endif
  
          else if (veldir.eq.2) then ! xlo, vely
  
           if (adv_dir .eq. 2) then
            y_vel = adv_vel
           else
            y_vel = zero
           endif
           if ((probtype.eq.53).and.(SDIM.eq.2)) then  
            ! y velocity, left wall
            y_vel = zero
           endif
  
           velcell(veldir)=y_vel  ! xlo, vely

           if (probtype.eq.bubbleInPackedColumn) then ! xlo,vely
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if (SDIM.eq.2) then
  
            if (probtype.eq.28) then
             call zalesakvv(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.29) then
             call deformvv(velcell(veldir),x,y,time,dx)
            else if (probtype.eq.31) then ! xlo,vely
             call circlevv(velcell(veldir),x,y,y)
! xlo wall vertical pipe velocity
            else if (probtype.eq.41) then
             velcell(veldir)=zero
            else if (probtype.eq.532) then ! xlo,yvel
             call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
            else if (probtype.eq.802) then ! dissolution, xlo,vely
             print *,"802 obsolete"
             stop
            endif

           else if (SDIM.eq.3) then

            if (probtype.eq.29) then
             call deform3dvv(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.28) then
             call zalesakvv(velcell(veldir),x,y,z,time,dx)
            endif

           else
            print *,"dimension bust"
            stop
           endif

! dir=1, side=1  (xlo face of domain)
          else if ((veldir.eq.3).and.(SDIM.eq.3)) then
   
           if (adv_dir.eq.3) then
            z_vel = adv_vel
           else  
            z_vel = zero
           endif
           if ((probtype.eq.53).or.(probtype.eq.530).or. &
                (probtype.eq.531).or. &
                (probtype.eq.536).or.(probtype.eq.537).or. &
                (probtype.eq.538).or.(probtype.eq.541)) then
            z_vel=zero
           endif
           velcell(veldir)=z_vel  ! xlo,velz
  
! velz, xlo
           if ((probtype.eq.36).and. &
               ((yblob9.ne.zero).or.(yblob10.ne.zero))) then
            velcell(veldir)=yblob9
           else if (probtype.eq.28) then
            call zalesakww(velcell(veldir),x,y,z,time,dx)
           else if (probtype.eq.29) then
            call deform3dww(velcell(veldir),x,y,z,time,dx)
           else if (probtype.eq.bubbleInPackedColumn) then ! xlo,velz
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           endif
          else
           print *,"veldir invalid"
           stop
          endif
  
         else if (dir.eq.2) then ! ylo
  
          if (veldir.eq.1) then
  
           if (adv_dir.eq.1)then
            call rampvel(time,x_vel)
           else  
            x_vel = zero
           endif
  
           velcell(veldir)=x_vel  ! ylo, velx

           if (probtype.eq.bubbleInPackedColumn) then ! ylo,velx
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if (SDIM.eq.2) then

              ! ylo, velx, 2D
            if ((probtype.eq.701).and.(axis_dir.eq.2)) then
             velcell(veldir)=adv_vel 
            else if ((probtype.eq.1).and.(axis_dir.eq.13)) then
             velcell(veldir)=zero
            else if ((probtype.eq.1).and.(axis_dir.ne.14)) then
             velcell(veldir)=-vinletgas
            else if (probtype.eq.21) then
             velcell(veldir)=adv_vel
            else if (probtype.eq.28) then
             call zalesakuu(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.29) then
             call deformuu(velcell(veldir),x,y,time,dx)
            else if (probtype.eq.31) then ! ylo,velx
             call circleuu(velcell(veldir),x,y,y)
            else if (probtype.eq.58) then
             velcell(veldir)=zero
            else if (probtype.eq.53) then  ! x vel bottom wall
             velcell(veldir)=zero
              ! 2d, ylo, velx bottom wall velbc_override
            else if ((probtype.eq.538).or.(probtype.eq.541)) then
             velcell(veldir)=zero
            else if (probtype.eq.10) then
             if ((x.ge.xblob-radblob).and.(x.le.xblob+radblob)) then
              velcell(veldir)=zero
             endif
            endif

           else if (SDIM.eq.3) then

            if (probtype.eq.58) then
             velcell(veldir)=zero
            else if (probtype.eq.29) then
             call deform3duu(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.28) then
             call zalesakuu(velcell(veldir),x,y,z,time,dx)
            endif

           else
            print *,"dimension bust"
            stop
           endif
  
          else if (veldir.eq.2) then  ! ylo, vely
  
           if (adv_dir .eq. 2) then
            y_vel = adv_vel
           else
            y_vel = zero
           endif
  
           velcell(veldir)=y_vel   ! y velocity bottom wall (ylo, vely)

           if (probtype.eq.bubbleInPackedColumn) then ! ylo,vely
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if (SDIM.eq.2) then
  
            if (probtype.eq.28) then
             call zalesakvv(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.29) then
             call deformvv(velcell(veldir),x,y,time,dx)
            else if (probtype.eq.31) then ! ylo,vely
             call circlevv(velcell(veldir),x,y,y)
   
             ! side=1, dir=2,veldir=2  (vely at ylo)
             ! bubble formation
             ! bubble_formation_inflow_bc sets of Poiseuille flow
             ! quantity in cell is average velocity for Poiseuille flow
            else if ((probtype.eq.25).and.(axis_dir.gt.0)) then
             call bubble_formation_inflow_bc(xsten,nhalf,x,velcell(veldir))
            else if (probtype.eq.22) then
             velcell(veldir)=y_vel*(xblob**2-x**2)*three/ &
                   (two*xblob*xblob*xblob)
             if (x.gt.xblob) then
              velcell(veldir)=zero
             endif
            else if ((probtype.eq.53).or.(probtype.eq.537)) then  ! ylo, vely 2D
             call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
            else if ((probtype.eq.538).or.(probtype.eq.541)) then  ! ylo, vely
             call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
            else if (probtype.eq.539) then  ! ylo, vely - velbc_override
             call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
            else if ((probtype.eq.63).or.(probtype.eq.64)) then
             velcell(veldir)=y_vel
            else if (probtype.eq.10) then
             velcell(veldir)=zero
             if ((x.ge.xblob-radblob).and. &
                 (x.le.xblob+radblob)) then
              velcell(veldir)=advbot
             endif
            else if ((probtype.eq.36).and.(xblob10.gt.zero).and. &
                     (yblob10.ne.zero)) then
             velcell(veldir)=x*yblob10/xblob10
! ylo vertical velocity
            else if (probtype.eq.41) then
             call get_pipe_velocity(xsten,nhalf,dx,bfact,velcell,time)
            else if (probtype.eq.72) then
             call vapordist(xsten,nhalf,dx,bfact,dist)
             if (dist.ge.zero) then
              velcell(veldir)=advbot
             else
              velcell(veldir)=adv_vel
             endif
! microfluidics squeeze vertical vel ylo inflow
            else if (probtype.eq.5700) then  ! yvel,ylo
             call microfluidic_velbc(xsten,nhalf,dir,side,velcell)
            endif

           else if (SDIM.eq.3) then

            ! ylo, yvel
            if (probtype.eq.532) then
             call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
            else if ((probtype.eq.59).or. &
                     (probtype.eq.710)) then
               ! vel=solvel in sol
             call mask_velocity(xsten,nhalf,dx,bfact,velcell,time,nmat) 
            else if (probtype.eq.5501) then
               ! vel=solvel in sol
             call mask_velocity(xsten,nhalf,dx,bfact,velcell,time,nmat) 
            else if (probtype.eq.28) then
             call zalesakvv(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.29) then
             call deform3dvv(velcell(veldir),x,y,z,time,dx)
! microfluidics squeeze vertical vel ylo inflow
            else if (probtype.eq.5700) then ! yvel,ylo
             call microfluidic_velbc(xsten,nhalf,dir,side,velcell)
            endif

           else
            print *,"dimension bust"
            stop
           endif

! dir=2, side=1 (ylo face) zvel yloface
          else if ((veldir.eq.3).and.(SDIM.eq.3)) then
  
           if (adv_dir.eq.3) then
            z_vel = adv_vel
           else  
            z_vel = zero
           endif
            ! ylo,zvel
           if (probtype.eq.bubbleInPackedColumn) then ! ylo,velz
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if (probtype.eq.532) then
            call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
           else if ((probtype.eq.53).or.(probtype.eq.530).or. &
               (probtype.eq.531).or. &
               (probtype.eq.536).or.(probtype.eq.537).or. &
               (probtype.eq.538).or. &
               (probtype.eq.541)) then
            z_vel=zero
            velcell(veldir)=z_vel  ! ylo,velz
           else
            velcell(veldir)=z_vel  ! ylo,velz
           endif
  
           if (probtype.eq.29) then
            call deform3dww(velcell(veldir),x,y,z,time,dx)
           else if (probtype.eq.28) then
            call zalesakww(velcell(veldir),x,y,z,time,dx)
           endif
          else
           print *,"veldir invalid"
           stop
          endif

         else if ((dir.eq.3).and.(SDIM.eq.3)) then
  
! zlo face, x velocity
          if (veldir.eq.1) then
  
           if (adv_dir.eq.1)then
            call rampvel(time,x_vel)
           else  
            x_vel = zero
           endif
           velcell(veldir)=x_vel  ! zlo, velx
  
           if (probtype.eq.bubbleInPackedColumn) then ! zlo,velx
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if ((probtype.eq.1).and.(axis_dir.eq.13)) then
            velcell(veldir)=zero
           else if ((probtype.eq.1).and.(axis_dir.lt.150)) then
            if ((axis_dir.eq.11).or.(axis_dir.eq.12)) then
             if (xblob10.eq.one) then
              velcell(veldir)=radblob10
             else
              velcell(veldir)=-vinletgas
             endif
            else
             velcell(veldir)=-vinletgas
            endif
! zlo face, x velocity
           else if (probtype.eq.530) then
            call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
           else if ((probtype.eq.58).or.(probtype.eq.53).or. &
                    (probtype.eq.531).or. &
                    (probtype.eq.536).or.(probtype.eq.537).or. &
                    (probtype.eq.538).or. &
                    (probtype.eq.541)) then
            velcell(veldir)=zero
            if ((probtype.eq.541).and.(axis_dir.eq.0)) then
               !  zlo,velx
             call velread_bc_point(x,y,z,dir,veldir,0,time,velcell(dir))
            endif
           else if (probtype.eq.28) then
            call zalesakuu(velcell(veldir),x,y,z,time,dx)
           else if (probtype.eq.29) then
            call deform3duu(velcell(veldir),x,y,z,time,dx)
! wall gas pipe horizontal velocity (velx) z=zlo 
           else if (probtype.eq.41) then
            print *,"modify for pipe 3d"
            stop
           endif
  
! zlo face, y velocity
  
          else if (veldir.eq.2) then
  
           if (adv_dir .eq. 2) then
            y_vel = adv_vel
           else
            y_vel = zero
           endif
           velcell(veldir)=y_vel  ! zlo, vely
  
           if (probtype.eq.bubbleInPackedColumn) then ! zlo,vely
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if (probtype.eq.28) then
            call zalesakvv(velcell(veldir),x,y,z,time,dx)
           else if (probtype.eq.29) then
            call deform3dvv(velcell(veldir),x,y,z,time,dx)
! zlo face, y velocity
           else if (probtype.eq.530) then
            call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
           else if ((probtype.eq.541).and.(axis_dir.eq.0)) then
            call velread_bc_point(x,y,z,dir,veldir,0,time,velcell(dir))
           endif
  
          else if ((veldir.eq.3).and.(SDIM.eq.3)) then
  
! zlo face, z velocity
           if (adv_dir.eq.3) then
            z_vel = adv_vel
           else  
            z_vel = zero
           endif
           velcell(veldir)=z_vel  ! zlo, velz
  
! zlo, velz 3D, velbc_override
           if (probtype.eq.bubbleInPackedColumn) then ! zlo,velz
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if ((probtype.eq.53).or.(probtype.eq.536).or. &
               (probtype.eq.537).or.(probtype.eq.530).or. &
               (probtype.eq.538).or.(probtype.eq.541)) then

            call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
            if ((probtype.eq.541).and.(axis_dir.eq.0)) then
             call velread_bc_point(x,y,z,dir,veldir,0,time,velcell(dir))
            endif


           else if (probtype.eq.531) then

            z_vel=zero
            velcell(veldir)=z_vel  ! zlo, velz

           else if ((probtype.eq.63).or.(probtype.eq.64)) then
            velcell(veldir)=z_vel
! velz, zlo
           else if ((probtype.eq.36).and.(xblob10.gt.zero).and. &
                    ((yblob9.ne.zero).or.(yblob10.ne.zero))) then
            if (probhix-problox.le.zero) then
             print *,"probhix or problox invalid"
             stop
            endif
            velcell(veldir)=yblob9+(x-problox)*(yblob10-yblob9)/  &
              (probhix-problox)
           else if (probtype.eq.28) then
            call zalesakww(velcell(veldir),x,y,z,time,dx)
           else if (probtype.eq.29) then
            call deform3dww(velcell(veldir),x,y,z,time,dx)
           endif
  
          else
           print *,"veldir invalid"
           stop
          endif
  
         else
          print *,"dir invalid velbcoverride 2"
          stop
         endif
  
! -------------------------------side=2 ----------------------------
        else if (side.eq.2) then
  
         if (dir.eq.1) then
  
! uvel at xhi
          if (veldir.eq.1) then
  
           if (adv_dir.eq.1)then
            call rampvel(time,x_vel)
           else  
            x_vel = zero
           endif
  
           velcell(veldir)=x_vel  ! xhi, velx

           if (probtype.eq.bubbleInPackedColumn) then ! xhi,velx
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if (SDIM.eq.2) then
  
              ! xhi,xvel
            if (probtype.eq.532) then
             call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
            else if (probtype.eq.28) then
             call zalesakuu(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.29) then
             call deformuu(velcell(veldir),x,y,time,dx)
            else if (probtype.eq.31) then ! xhi,velx
             call circleuu(velcell(veldir),x,y,y)
            else if ((probtype.eq.1).and.(axis_dir.eq.11)) then
             velcell(veldir)=vinletgas*(y/yblob-one) 
            else if (probtype.eq.58) then
             velcell(veldir)=zero
            else if (probtype.eq.59) then ! xvel,xhi,velbc_override 2d
             ! vel=solidvel in solid
             call mask_velocity(xsten,nhalf,dx,bfact,velcell,time,nmat)
            else if ((probtype.eq.22).and.(axis_dir.eq.13)) then
             call vbc(velcell(veldir),time,y,zero,error)
            else if (probtype.eq.32) then
             if (levelrz.ne.0) then
              print *,"levelrz invalid for probtype=32"
              stop
             endif
            else if (probtype.eq.110) then
             call get_bump_velocity(xsten,nhalf,dx,bfact,velcell(veldir),time) ! xvel,xhi
            endif
            if (probtype.eq.5700) then  ! xvel,xhi
             call microfluidic_velbc(xsten,nhalf,dir,side,velcell)
            endif

           else if (SDIM.eq.3) then

            if (probtype.eq.58) then
             velcell(veldir)=zero
            else if (probtype.eq.28) then
             call zalesakuu(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.29) then
             call deform3duu(velcell(veldir),x,y,z,time,dx)
            else if ((axis_dir.eq.13).and.(probtype.eq.22)) then
             call vbc(velcell(veldir),time,z,y,error)
            endif
            if (probtype.eq.5700) then  ! xhi,velx
             call microfluidic_velbc(xsten,nhalf,dir,side,velcell)
            endif

           else
            print *,"dimension bust"
            stop
           endif
  
! yvel at xhi
          else if (veldir.eq.2) then
  
           if (adv_dir .eq. 2) then
            y_vel = adv_vel
           else
            y_vel = zero
           endif
            ! side=2  veldir=2 dir=1 (yvel, right wall)
           if ((probtype.eq.53).and.(SDIM.eq.2)) then 
            y_vel = zero
           endif
  
           velcell(veldir)=y_vel  ! xhi, vely

           if (probtype.eq.bubbleInPackedColumn) then ! xhi,vely
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if (SDIM.eq.2) then
  
            if (probtype.eq.28) then
             call zalesakvv(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.29) then
             call deformvv(velcell(veldir),x,y,time,dx)
            else if (probtype.eq.31) then ! xhi,vely
             call circlevv(velcell(veldir),x,y,y)
            else if ((probtype.eq.36).and.(yblob10.ne.zero)) then
             velcell(veldir)=yblob10
! xhi wall vertical pipe velocity
            else if (probtype.eq.41) then
             velcell(veldir)=zero
            else if (probtype.eq.532) then
             call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell) ! yvel,xhi
            else if (probtype.eq.32) then 
             ! do nothing ?
            endif
            if (probtype.eq.5700) then  ! yvel,xhi
             call microfluidic_velbc(xsten,nhalf,dir,side,velcell)
            endif

           else if (SDIM.eq.3) then

            if (probtype.eq.29) then
             call deform3dvv(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.28) then
             call zalesakvv(velcell(veldir),x,y,z,time,dx)
            endif
            if (probtype.eq.5700) then  ! xhi,vely
             call microfluidic_velbc(xsten,nhalf,dir,side,velcell)
            endif

           else
            print *,"dimension bust"
            stop
           endif

! xhi face, z vel, velbc_override
          else if ((veldir.eq.3).and.(SDIM.eq.3)) then
  
           if (adv_dir.eq.3) then
            z_vel = adv_vel
           else  
            z_vel = zero
           endif
           if (probtype.eq.bubbleInPackedColumn) then ! xhi,velz
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if ((probtype.eq.53).or.(probtype.eq.530).or. &
               (probtype.eq.531).or. &
               (probtype.eq.536).or.(probtype.eq.537).or. &
               (probtype.eq.538).or.(probtype.eq.541)) then
            z_vel=zero
           endif
           velcell(veldir)=z_vel  ! xhi, velz
  
! velz,xhi 
           if ((probtype.eq.36).and. &
               ((yblob9.ne.zero).or.(yblob10.ne.zero))) then
            velcell(veldir)=yblob10
           else if (probtype.eq.29) then
            call deform3dww(velcell(veldir),x,y,z,time,dx)
           else if (probtype.eq.28) then
            call zalesakww(velcell(veldir),x,y,z,time,dx)
           endif

          else
           print *,"veldir invalid"
           stop
          endif

          ! yhi face 
         else if (dir.eq.2) then
 
           ! yhi, velx
          if (veldir.eq.1) then
  
           if (adv_dir.eq.1)then
            call rampvel(time,x_vel)
           else  
            x_vel = zero
           endif
  
           velcell(veldir)=x_vel ! yhi, velx

           if (probtype.eq.bubbleInPackedColumn) then ! yhi,velx
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if (SDIM.eq.2) then

             ! yhi, velx, 2D
            if ((probtype.eq.701).and.(axis_dir.eq.2)) then 
             velcell(veldir)=adv_vel
            else if ((probtype.eq.1).and.(axis_dir.ne.14)) then
             velcell(veldir)=vinletgas
            else if (probtype.eq.21) then
             velcell(veldir)=adv_vel
            else if (probtype.eq.28) then
             call zalesakuu(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.29) then
             call deformuu(velcell(veldir),x,y,time,dx)
            else if (probtype.eq.31) then ! yhi,velx
             call circleuu(velcell(veldir),x,y,y)
            else if (probtype.eq.58) then
             velcell(veldir)=zero
            endif

           else if (SDIM.eq.3) then

            if (probtype.eq.58) then
             velcell(veldir)=zero
            else if (probtype.eq.29) then
             call deform3duu(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.29) then
             call zalesakuu(velcell(veldir),x,y,z,time,dx)
            endif

           else
            print *,"dimension bust"
            stop
           endif

            ! yvel, yhi face 
          else if (veldir.eq.2) then
  
           if (adv_dir .eq. 2) then
            y_vel = adv_vel
           else
            y_vel = zero
           endif
           if (((probtype.eq.53).or. &
                (probtype.eq.538).or. &
                (probtype.eq.541)).and. &
               (SDIM.eq.2)) then 
            ! side=2 dir=2 veldir=2 (yvel top wall)
            y_vel = zero
           endif
  
           velcell(veldir)=y_vel  ! yhi, vely

           if (probtype.eq.bubbleInPackedColumn) then ! yhi,vely
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if (SDIM.eq.2) then
  
            if (probtype.eq.28) then
             call zalesakvv(velcell(veldir),x,y,z,time,dx)
            else if (probtype.eq.29) then
             call deformvv(velcell(veldir),x,y,time,dx)
            else if (probtype.eq.31) then ! yhi,vely,2D
             call circlevv(velcell(veldir),x,y,y)
            else if ((probtype.eq.16).or. &
               ((probtype.eq.25).and.(axis_dir.eq.0)) ) then
             velcell(veldir)=zero
             if ((x.ge.xblob-radblob).and. &
                 (x.le.xblob+radblob)) then
              velcell(veldir)=-abs(advbot)
             endif
! yhi vertical velocity
            else if (probtype.eq.41) then
             call get_pipe_velocity(xsten,nhalf,dx,bfact,velcell,time)
            else if (probtype.eq.72) then
   
            else if (probtype.eq.62) then
             costheta=cos(xblob2)
             sintheta=sin(xblob2)
             xprime=costheta*(x-xblob)-sintheta*(y-yblob)
             yprime=sintheta*(x-xblob)+costheta*(y-yblob)
             if (xprime**2<radblob**2) then
              velcell(veldir)=-radblob3
             endif
            else if ((probtype.eq.63).or.(probtype.eq.64)) then
             velcell(veldir)=four*y_vel
            else if ((probtype.eq.36).and.(xblob10.gt.zero).and. &
                     (yblob10.ne.zero)) then
             velcell(veldir)=x*yblob10/xblob10
! microfluidics problem yvel yhi 
! microfluidics channel -- 0,3,4 Roper, 1 Comsol, 2 squeeze
            else if (probtype.eq.5700) then  ! yvel,yhi
             call microfluidic_velbc(xsten,nhalf,dir,side,velcell)
            else if (probtype.eq.701) then
             if ((axis_dir.eq.0).or.(axis_dir.eq.1)) then
              call get_rain_velocity(x,y,z,dx,velcell(veldir), &
                      vely_rain,time,dir,nmat,adv_vel)  ! yhi veldir=2
             else if (axis_dir.eq.2) then
              velcell(veldir)=zero  ! yhi veldir=2
             else
              print *,"axis_dir invalid"
              stop
             endif

            endif

           else if (SDIM.eq.3) then

             ! yhi,yvel,3D
            if (probtype.eq.532) then
             call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
            else if (probtype.eq.531) then
             call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
            else if (probtype.eq.29) then
             call deform3dvv(velcell(veldir),x,y,z,time,dx)        
            else if (probtype.eq.28) then
             call zalesakvv(velcell(veldir),x,y,z,time,dx)        
            endif
! microfluidics problem yvel yhi,3D 
! microfluidics channel -- 0,3,4 Roper, 1 Comsol, 2,5 squeeze
            if (probtype.eq.5700) then  ! yvel,yhi
             call microfluidic_velbc(xsten,nhalf,dir,side,velcell)     
            endif

           else
            print *,"dimension bust"
            stop
           endif

! yhi, zvel
! z vel, yhi face
          else if ((veldir.eq.3).and.(SDIM.eq.3)) then
  
           if (adv_dir.eq.3) then
            z_vel = adv_vel
           else  
            z_vel = zero
           endif 
             ! yhi,zvel
           if (probtype.eq.bubbleInPackedColumn) then ! yhi,zvel
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if (probtype.eq.532) then
            call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
           else if ((probtype.eq.53).or.(probtype.eq.530).or. &
               (probtype.eq.531).or. &
               (probtype.eq.536).or.(probtype.eq.537).or. &
               (probtype.eq.538).or.(probtype.eq.541)) then
            z_vel=zero
            velcell(veldir)=z_vel  ! yhi, velz
           else
            velcell(veldir)=z_vel  ! yhi, velz
           endif
  
           if (probtype.eq.29) then
            call deform3dww(velcell(veldir),x,y,z,time,dx)
           else if (probtype.eq.28) then
            call zalesakww(velcell(veldir),x,y,z,time,dx)
           endif

          else
           print *,"veldir invalid"
           stop
          endif

         else if ((dir.eq.3).and.(SDIM.eq.3)) then
  
          if (veldir.eq.1) then
  
           if (adv_dir.eq.1)then
            call rampvel(time,x_vel)
           else  
            x_vel = zero
           endif
           velcell(veldir)=x_vel  ! zhi, velx
  
           if (probtype.eq.bubbleInPackedColumn) then ! zhi,velx
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if ((probtype.eq.1).and.(axis_dir.lt.150)) then
            velcell(veldir)=vinletgas
           else if (probtype.eq.58) then
            velcell(veldir)=zero
           else if (probtype.eq.28) then
            call zalesakuu(velcell(veldir),x,y,z,time,dx)
           else if (probtype.eq.29) then
            call deform3duu(velcell(veldir),x,y,z,time,dx)
           endif
  
          else if (veldir.eq.2) then
  
           if (adv_dir .eq. 2) then
            y_vel = adv_vel
           else
            y_vel = zero
           endif
           velcell(veldir)=y_vel  ! zhi, vely
  
           if (probtype.eq.bubbleInPackedColumn) then ! zhi,vely
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if (probtype.eq.29) then
            call deform3dvv(velcell(veldir),x,y,z,time,dx)
           else if (probtype.eq.28) then
            call zalesakvv(velcell(veldir),x,y,z,time,dx)
           endif
  
! zhi, velz
          else if ((veldir.eq.3).and.(SDIM.eq.3)) then
  
           if (adv_dir.eq.3) then
            z_vel = adv_vel
           else  
            z_vel = zero
           endif
           if ((probtype.eq.53).or.(probtype.eq.530).or. &
               (probtype.eq.531).or. &
               (probtype.eq.536).or.(probtype.eq.537).or. &
               (probtype.eq.538).or.(probtype.eq.541)) then
            z_vel=zero
           endif
           velcell(veldir)=z_vel  ! zhi, velz
  
           if (probtype.eq.bubbleInPackedColumn) then ! zhi,velz
            call Pack_velbc(dir,side,veldir,velcell,adv_vel,adv_dir)
           else if ((probtype.eq.62).or.(probtype.eq.65)) then
            costheta=cos(xblob2)
            sintheta=sin(xblob2)
            xprime=costheta*(x-xblob)-sintheta*(z-zblob)
            yprime=y-yblob
            zprime=sintheta*(x-xblob)+costheta*(z-zblob)
            if (xprime**2+yprime**2<radblob**2) then
             velcell(veldir)=-radblob3
            endif
           else if ((probtype.eq.63).or.(probtype.eq.64)) then
            velcell(veldir)=four*z_vel
! velz, zhi
           else if ((probtype.eq.36).and.(xblob10.gt.zero).and. &
                    ((yblob9.ne.zero).or.(yblob10.ne.zero))) then
            if (probhix-problox.le.zero) then
             print *,"probhix or problox invalid"
             stop
            endif
            velcell(veldir)=yblob9+(x-problox)*(yblob10-yblob9)/ &
               (probhix-problox)

           else if (probtype.eq.29) then
            call deform3dww(velcell(veldir),x,y,z,time,dx)
           else if (probtype.eq.28) then
            call zalesakww(velcell(veldir),x,y,z,time,dx)
           endif
  
          else
           print *,"veldir invalid"
           stop
          endif
  
         else
          print *,"dir invalid velbc_override 3"
          stop
         endif
  
        else 
         print *,"side invalid"
         stop
        endif
  
       endif ! non-hydrate problems

       vel=velcell(veldir)
       vel_in=vel/global_velocity_scale

      else
       print *,"vel_homflag invalid"
       stop
      endif

      return
      end subroutine velbc_override


 
      subroutine scalarBC(time,dir,side,ADV,ADVwall, &
       xsten,nhalf,dx,bfact)
      IMPLICIT NONE

      INTEGER_T dir,side,nhalf,bfact
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T time,ADV,xwall,ADVwall,x,y,z
      REAL_T dx(SDIM)

      if (nhalf.lt.1) then
       print *,"nhalf invalid scalar bc"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)

      if (dir.eq.1) then
       if (side.eq.1) then
        xwall=problox
       else
        xwall=probhix
       endif
      else if (dir.eq.2) then
       if (side.eq.1) then
        xwall=probloy
       else
        xwall=probhiy
       endif
      else if ((dir.eq.3).and.(SDIM.eq.3)) then
       if (side.eq.1) then
        xwall=probloz
       else
        xwall=probhiz
       endif
      else
       print *,"dir invalid scalarbc"
       stop
      endif

      if ((dir.eq.1).and.(side.eq.1)) then
       if (xwall.lt.x) then
        print *,"xwall,x invalid"
        stop
       endif
       ADV=ADVwall
      else if ((dir.eq.1).and.(side.eq.2)) then
       if (xwall.gt.x) then
        print *,"xwall,x invalid"
        stop
       endif
       ADV=ADVwall
      else if ((dir.eq.2).and.(side.eq.1)) then
       if (xwall.lt.y) then
        print *,"xwall,y invalid"
        stop
       endif
       ADV=ADVwall
      else if ((dir.eq.2).and.(side.eq.2)) then
       if (xwall.gt.y) then
        print *,"xwall,y invalid"
        stop
       endif
       ADV=ADVwall
      else if ((dir.eq.3).and.(side.eq.1).and.(SDIM.eq.3)) then
       if (xwall.lt.z) then
        print *,"xwall,z invalid"
        stop
       endif
       ADV=ADVwall
      else if ((dir.eq.3).and.(side.eq.2).and.(SDIM.eq.3)) then
       if (xwall.gt.z) then
        print *,"xwall,z invalid"
        stop
       endif
       ADV=ADVwall
      else
       print *,"dir side invalid"
       stop
      endif

      return
      end subroutine scalarBC


      subroutine extrapBC(time,dir,side,ADV,ADVwall, &
       xsten,nhalf,dx,bfact)
      IMPLICIT NONE

      INTEGER_T dir,side,nhalf,bfact
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T time,ADV,xwall,ADVwall,x,y,z
      REAL_T dx(SDIM)

      if (nhalf.lt.1) then
       print *,"nhalf invalid extrap bc"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)

      if (dir.eq.1) then
       if (side.eq.1) then
        xwall=problox
       else
        xwall=probhix
       endif
      else if (dir.eq.2) then
       if (side.eq.1) then
        xwall=probloy
       else
        xwall=probhiy
       endif
      else if ((dir.eq.3).and.(SDIM.eq.3)) then
       if (side.eq.1) then
        xwall=probloz
       else
        xwall=probhiz
       endif
      else
       print *,"dir invalid scalarbc"
       stop
      endif

      if ((dir.eq.1).and.(side.eq.1)) then
       if (xwall.lt.x) then
        print *,"xwall,x invalid"
        stop
       endif
       ADV=ADVwall
      else if ((dir.eq.1).and.(side.eq.2)) then
       if (xwall.gt.x) then
        print *,"xwall,x invalid"
        stop
       endif
       ADV=ADVwall
      else if ((dir.eq.2).and.(side.eq.1)) then
       if (xwall.lt.y) then
        print *,"xwall,y invalid"
        stop
       endif
       ADV=ADVwall
      else if ((dir.eq.2).and.(side.eq.2)) then
       if (xwall.gt.y) then
        print *,"xwall,y invalid"
        stop
       endif
       ADV=ADVwall
      else if ((dir.eq.3).and.(side.eq.1).and.(SDIM.eq.3)) then
       if (xwall.lt.z) then
        print *,"xwall,z invalid"
        stop
       endif
       ADV=ADVwall
      else if ((dir.eq.3).and.(side.eq.2).and.(SDIM.eq.3)) then
       if (xwall.gt.z) then
        print *,"xwall,z invalid"
        stop
       endif
       ADV=ADVwall
      else
       print *,"dir side invalid"
       stop
      endif

      return
      end subroutine extrapBC



      subroutine presBDRYCOND(time,dir,side,ADV,ADVwall_in, &
        xsten,nhalf,dx,bfact)
      use global_utility_module
      use hydrateReactor_module
      use unimaterialChannel_module
      use River
      use shockdrop
      use USERDEF_module
      use CAV3D_module
      use HELIX_module
      use TSPRAY_module
      use CAV2Dstep_module
      use ZEYU_droplet_impact_module
      use CONE3D_module
      use WAVY_Channel_module
      use rigid_FSI_module
      use sinking_particle_module

      IMPLICIT NONE


      INTEGER_T dir,side,nhalf,bfact
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T time,ADV,xwall,ADVwall,x,y,z
      REAL_T ADVwall_in
      REAL_T dx(SDIM)
      REAL_T pipexlo,pipexhi
      REAL_T rhohydro
      REAL_T base_pres
      REAL_T VOF(num_materials)
      REAL_T cenbc(num_materials,SDIM)
      REAL_T waterdepth
      REAL_T xpos(SDIM)
      REAL_T gravity_dz
      INTEGER_T local_dir
      REAL_T local_LS(num_materials)
      INTEGER_T from_boundary_hydrostatic

      from_boundary_hydrostatic=0

      if (nhalf.lt.1) then
       print *,"nhalf invalid presBDRYCOND"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)
      do local_dir=1,SDIM
       xpos(local_dir)=xsten(0,local_dir)
      enddo

      if (dir.eq.1) then
       if (side.eq.1) then
        xwall=problox
       else
        xwall=probhix
       endif
      else if (dir.eq.2) then
       if (side.eq.1) then
        xwall=probloy
       else
        xwall=probhiy
       endif
      else if ((dir.eq.3).and.(SDIM.eq.3)) then
       if (side.eq.1) then
        xwall=probloz
       else
        xwall=probhiz
       endif
      else
       print *,"dir invalid presbc"
       stop
      endif

      if (SDIM.eq.2) then
       if (abs(z-y).gt.VOFTOL) then
        print *,"expect z=y in 2D 4"
        stop
       endif
      endif

      if (gravity_dir.eq.1) then
       gravity_dz=x-probhix
      else if (gravity_dir.eq.2) then
       gravity_dz=y-probhiy
      else if ((gravity_dir.eq.3).and.(SDIM.eq.3)) then
       gravity_dz=z-probhiz
      else
       print *,"gravity_dir invalid"
       stop
      endif

      ADVwall=ADVwall_in*global_pressure_scale

      waterdepth=zero

      if (pres_homflag.eq.1) then
       ADV=zero
      else if (pres_homflag.eq.0) then

       if (is_in_probtype_list().eq.1) then
        call SUB_LS(xpos,time,local_LS,num_materials)
        call SUB_PRES_BC(xwall,xpos,time,local_LS, &
         ADV,ADVwall,dir,side,dx,num_materials)
       else if (probtype.eq.411) then

        call CAV3D_LS(xpos,time,local_LS)
        call CAV3D_PRES_BC(xwall,xpos,time,local_LS, &
          ADV,ADVwall,dir,side,dx)
       else if (probtype.eq.401) then

        call HELIX_LS(xpos,time,local_LS)
        call HELIX_PRES_BC(xwall,xpos,time,local_LS, &
          ADV,ADVwall,dir,side,dx)
       else if (probtype.eq.402) then

        call TSPRAY_LS(xpos,time,local_LS)
        call TSPRAY_PRES_BC(xwall,xpos,time,local_LS, &
          ADV,ADVwall,dir,side,dx)
       else if (probtype.eq.412) then ! step
        call CAV2Dstep_LS(xpos,time,local_LS)
        call CAV2Dstep_PRES_BC(xwall,xpos,time,local_LS, &
          ADV,ADVwall,dir,side,dx)
       else if (probtype.eq.413) then ! zeyu
        call ZEYU_droplet_impact_LS(xpos,time,local_LS)
        call ZEYU_droplet_impact_PRES_BC(xwall,xpos,time,local_LS, &
          ADV,ADVwall,dir,side,dx)

       else if (probtype.eq.533) then
        call rigid_FSI_LS(xpos,time,local_LS)
        call rigid_FSI_PRES_BC(xwall,xpos,time,local_LS, &
          ADV,ADVwall,dir,side,dx)
       else if (probtype.eq.534) then
        call sinking_FSI_LS(xpos,time,local_LS)
        call sinking_FSI_PRES_BC(xwall,xpos,time,local_LS, &
          ADV,ADVwall,dir,side,dx)

       else if (probtype.eq.311) then ! user defined

        call USERDEF_LS(xpos,time,local_LS)
        call USERDEF_PRES_BC(xwall,xpos,time,local_LS, &
          ADV,ADVwall,dir,side,dx)

       else if (probtype.eq.222) then ! cone3d in presBDRYCOND

        call CONE3D_LS(xpos,time,local_LS)
        call CONE3D_PRES_BC(xwall,xpos,time,local_LS, &
          ADV,ADVwall,dir,side,dx)

       else if (probtype.eq.915) then ! wavy channel

        call WAVY_INIT_LS(xpos,time,local_LS)
        call WAVY_PRES_BC(xwall,xpos,time,local_LS, &
          ADV,ADVwall,dir,side,dx)

       else if (probtype.eq.199) then ! hydrates

        call HYD_PRES_BC(time,dir,side,ADV,xwall,ADVwall, &
          x,y,z,dx)

        ! in: presBDRYCOND
       else if (probtype.eq.220) then ! UNIMATERIAL problem
        call UNIMAT_PRES_BC(time,dir,side,ADV,xwall,ADVwall, &
          x,y,z,dx)

       else if ((probtype.eq.299).or. &
                (probtype.eq.301)) then !melting (boundary condition pressure)
        ADV=zero
       else if (probtype.eq.209) then ! River
        call RiverPressure(x,y,z,time,ADV,gravity, &
         fort_denconst(2),fort_denconst(1),axis_dir)
       else if ((probtype.eq.1).and. &
                ((axis_dir.eq.150).or. &
                 (axis_dir.eq.151))) then
        call shockdrop_pressure(x,y,z,ADV, &
         xblob,yblob,zblob,radblob,zblob2,axis_dir)
       else  
 
        base_pres=zero
        if ((probtype.eq.53).and.(axis_dir.eq.2)) then ! injection shock
         call general_hydrostatic_pressure(base_pres)
        else if ((probtype.eq.53).and. &  ! compressible JIC
                 (fort_material_type(2).gt.0)) then
         call general_hydrostatic_pressure(base_pres)
        else if ((probtype.eq.538).and.(SDIM.eq.2)) then 
         ! diesel injection w/needle
!        call general_hydrostatic_pressure(base_pres)
          base_pres=outflow_pressure
        else if ((probtype.eq.541).and.(SDIM.eq.2)) then
          base_pres=outflow_pressure
        else if (probtype.eq.539) then  ! sup injector
         call general_hydrostatic_pressure(base_pres)
        else if ((probtype.eq.530).and. &  ! impinging jets
                 (axis_dir.eq.1).and. &
                 (fort_material_type(2).gt.0).and. &
                 (SDIM.eq.3)) then
         call general_hydrostatic_pressure(base_pres)
        else if ((probtype.eq.538).and.(SDIM.eq.3)) then 
          ! diesel injection w/needle
!        call general_hydrostatic_pressure(base_pres)
          base_pres=outflow_pressure
        else if ((probtype.eq.541).and.(SDIM.eq.3)) then
          base_pres=outflow_pressure

         ! CODY ESTEBE created test problem
        else if ((probtype.eq.46).and.(axis_dir.eq.20)) then
          base_pres=outflow_pressure
        endif

        if ((dir.eq.1).and.(side.eq.1)) then  ! xlo
         if (xwall.lt.x) then
          print *,"xwall,x invalid"
          stop
         endif
         ADV=base_pres

          ! xlo,presBDRYCOND, stratified fluid
         if (probtype.eq.201) then

          if (z.le.zblob2) then
           ADV=-fort_denconst(1)*abs(gravity)*(z-zblob2)
          else
           ADV=-fort_denconst(3)*abs(gravity)*(z-zblob2)
          endif
  
         else if (SDIM.eq.2) then

          if ((probtype.eq.92).or.(probtype.eq.93)) then
           if (axis_dir.eq.2) then ! shock-turbulence pressure xlo
            ADV=10.333333
           else if (axis_dir.eq.3) then ! mach>4
            ADV=10.0*(1.4-1.0)
           else if ((axis_dir.eq.0).or. &
                    (axis_dir.eq.1).or. &
                    (axis_dir.eq.4)) then
            ! do nothing
           else
            print *,"axis_dir invalid"
            stop
           endif
          else if (fort_material_type(1).eq.13) then ! xlo, 2D, Tait EOS
           call boundary_hydrostatic(xpos,rhohydro,ADV)

          ! xlo, presBDRYCOND, 2D
          else if ((probtype.eq.9).and.(axis_dir.eq.1)) then  

           if (y.le.waterdepth) then
            ADV=-fort_denconst(1)*abs(gravity)*(y-waterdepth)
           else
            ADV=-fort_denconst(2)*abs(gravity)*(y-waterdepth)
           endif

          else if (probtype.eq.539) then  ! supnozzle xlo - presBDRYCOND
           ADV=inflow_pressure ! inlet side is all gas

          else if (probtype.eq.710) then
           ADV=-fort_denconst(1)*abs(gravity)*gravity_dz
          endif

         else if (SDIM.eq.3) then

          if (fort_material_type(1).eq.13) then !xlo 3D(1st material Tait EOS)
           call boundary_hydrostatic(xpos,rhohydro,ADV)
          else if ((probtype.eq.36).and.(axis_dir.eq.0)) then ! xlo
           ADV=-fort_denconst(1)*abs(gravity)*z

           ! xlo, presBDRYCOND, 3D
          else if ((probtype.eq.9).and.(axis_dir.eq.1)) then  
           if (z.le.waterdepth) then
            ADV=-fort_denconst(1)*abs(gravity)*(z-waterdepth)
           else
            ADV=-fort_denconst(2)*abs(gravity)*(z-waterdepth)
           endif
          endif

         else
          print *,"dimension bust"
          stop
         endif

        else if ((dir.eq.1).and.(side.eq.2)) then  ! xhi, presBDRYCOND
         if (xwall.gt.x) then
          print *,"xwall,x invalid"
          stop
         endif
         ADV=base_pres
   
          ! xhi, presBDRYCOND, stratified
         if (probtype.eq.201) then

          if (z.le.zblob2) then
           ADV=-fort_denconst(1)*abs(gravity)*(z-zblob2)
          else
           ADV=-fort_denconst(3)*abs(gravity)*(z-zblob2)
          endif

         else if (SDIM.eq.2) then

          if ((probtype.eq.92).or.(probtype.eq.93)) then
           if (axis_dir.eq.2) then ! shock-turbulence pressure xhi
            ADV=one
           else if (axis_dir.eq.3) then ! mach>4
            ADV=(1.4-1.0)
           else if ((axis_dir.eq.0).or. &
                    (axis_dir.eq.1).or. &
                    (axis_dir.eq.4)) then
            ! do nothing
           else
            print *,"axis_dir invalid"
            stop
           endif
          else if (fort_material_type(1).eq.13) then ! xhi, 2D, Tait EOS
           call boundary_hydrostatic(xpos,rhohydro,ADV)
          else if ((probtype.eq.36).and.(axis_dir.eq.0)) then ! xhi
           ADV=-fort_denconst(1)*abs(gravity)*y
          else if ((probtype.eq.36).and.(axis_dir.eq.2)) then
           call tait_hydrostatic_pressure_density(xpos,rhohydro,ADV, &
                   from_boundary_hydrostatic)
          else if (probtype.eq.42) then ! bubble jetting 2D
           call tait_hydrostatic_pressure_density(xpos,rhohydro,ADV, &
                   from_boundary_hydrostatic)
            ! in presBDRYCOND: 2d, xhi
          else if (probtype.eq.46) then ! cavitation 2D
           if ((axis_dir.ge.0).and.(axis_dir.lt.10)) then
            call tait_hydrostatic_pressure_density(xpos,rhohydro,ADV, &
                    from_boundary_hydrostatic)
           else if (axis_dir.eq.10) then
            call tait_hydrostatic_pressure_density(xpos,rhohydro,ADV, &
                    from_boundary_hydrostatic)
           else if (axis_dir.eq.20) then
            ! do nothing (ADV=base_pres, base_pres=outflow_pressure above) 
           else
            print *,"axis_dir invalid"
            stop
           endif

           ! xhi, presBDRYCOND, 2D
          else if ((probtype.eq.9).and.(axis_dir.eq.1)) then  
           if (y.le.waterdepth) then
            ADV=-fort_denconst(1)*abs(gravity)*(y-waterdepth)
           else
            ADV=-fort_denconst(2)*abs(gravity)*(y-waterdepth)
           endif
          else if (probtype.eq.539) then  ! supnozzle xhi - presBDRYCOND
           ADV=outflow_pressure

          else if (probtype.eq.710) then
           ADV=-fort_denconst(1)*abs(gravity)*gravity_dz
          endif

         else if (SDIM.eq.3) then

          if (fort_material_type(1).eq.13) then ! xhi, presBDRYCOND, TAIT EOS
           call boundary_hydrostatic(xpos,rhohydro,ADV)
          else if ((probtype.eq.36).and.(axis_dir.eq.0)) then ! xhi
           ADV=-fort_denconst(1)*abs(gravity)*z

           ! xhi, presBDRYCOND, 3D
          else if ((probtype.eq.9).and.(axis_dir.eq.1)) then  
           if (z.le.waterdepth) then
            ADV=-fort_denconst(1)*abs(gravity)*(z-waterdepth)
           else
            ADV=-fort_denconst(2)*abs(gravity)*(z-waterdepth)
           endif
          endif

         else
          print *,"dimension bust"
          stop
         endif

        else if ((dir.eq.2).and.(side.eq.1)) then  ! ylo

         if (xwall.lt.y) then
          print *,"xwall,y invalid"
          stop
         endif
         ADV=base_pres

          ! ylo,presBDRYCOND, stratified fluid, material 1 is bottom
         if (probtype.eq.201) then

          if (z.le.zblob2) then
           ADV=-fort_denconst(1)*abs(gravity)*(z-zblob2)
          else
           ADV=-fort_denconst(3)*abs(gravity)*(z-zblob2)
          endif

         else if (SDIM.eq.2) then

          if (fort_material_type(1).eq.13) then  !ylo 2D (TAIT EOS)
           call boundary_hydrostatic(xpos,rhohydro,ADV)
          else if ((probtype.eq.36).and.(axis_dir.eq.0)) then ! ylo
           ADV=-fort_denconst(1)*abs(gravity)*y
          else if ((probtype.eq.36).and.(axis_dir.eq.2)) then
           call tait_hydrostatic_pressure_density(xpos,rhohydro,ADV, &
                   from_boundary_hydrostatic)
          else if (probtype.eq.42) then ! bubble jetting 2D
           call tait_hydrostatic_pressure_density(xpos,rhohydro,ADV, &
                   from_boundary_hydrostatic)
          else if (probtype.eq.46) then ! cavitation ylo 2D
           if ((axis_dir.ge.0).and.(axis_dir.lt.10)) then
            call tait_hydrostatic_pressure_density(xpos,rhohydro,ADV, &
                    from_boundary_hydrostatic)
           else if (axis_dir.eq.10) then
            call tait_hydrostatic_pressure_density(xpos,rhohydro,ADV, &
                    from_boundary_hydrostatic)
           else if (axis_dir.eq.20) then
            ! do nothing (ADV=base_pres, base_pres=outflow_pressure above) 
           else
            print *,"axis_dir invalid"
            stop
           endif

           ! ylo, presBDRYCOND, 2D
          else if ((probtype.eq.9).and.(axis_dir.eq.1)) then  
           if (y.le.waterdepth) then
            ADV=-fort_denconst(1)*abs(gravity)*(y-waterdepth)
           else
            ADV=-fort_denconst(2)*abs(gravity)*(y-waterdepth)
           endif
          endif

           ! nozzle + pressure bc
          if ((probtype.eq.53).and.(axis_dir.eq.2)) then ! injection+shock
           call get_jet_vfrac(xsten,nhalf,dx,bfact,VOF,cenbc,num_materials) 
           if (VOF(1).gt.zero) then
            ADV=inflow_pressure
           endif 
           ! 2d diesel injection w/needle ylo presBDRYCOND
          else if (probtype.eq.538) then 
           call get_initial_vfrac(xsten,nhalf,dx,bfact,VOF,cenbc,num_materials)
           if (VOF(1).gt.zero) then
            ADV=inflow_pressure
           endif
           ! 2d diesel injection w/needle ylo presBDRYCOND
          else if ((probtype.eq.541).and.(axis_dir.eq.2)) then
           call get_initial_vfrac(xsten,nhalf,dx,bfact,VOF,cenbc,num_materials)
           if (VOF(1).gt.zero) then
            ADV=inflow_pressure
           endif
          else if (probtype.eq.539) then  ! supnozzle ylo - presBDRYCOND
           ADV=outflow_pressure
           call get_jet_vfrac(xsten,nhalf,dx,bfact,VOF,cenbc,num_materials) 
           if (VOF(1).gt.zero) then
! Hack: should be input, but "inflow_pressure" used at xlo
            ADV=1.6e7
           endif
          endif

         else if (SDIM.eq.3) then

          if (fort_material_type(1).eq.13) then ! ylo 3D, Tait EOS
           call boundary_hydrostatic(xpos,rhohydro,ADV)
          else if ((probtype.eq.36).and.(axis_dir.eq.0)) then  ! ylo
           ADV=-fort_denconst(1)*abs(gravity)*z

           ! ylo, presBDRYCOND, 3D
          else if ((probtype.eq.9).and.(axis_dir.eq.1)) then  
           if (z.le.waterdepth) then
            ADV=-fort_denconst(1)*abs(gravity)*(z-waterdepth)
           else
            ADV=-fort_denconst(2)*abs(gravity)*(z-waterdepth)
           endif
          endif

         else
          print *,"dimension bust"
          stop
         endif

        else if ((dir.eq.2).and.(side.eq.2)) then  ! yhi
         if (xwall.gt.y) then
          print *,"xwall,y invalid"
          stop
         endif
         ADV=base_pres

          ! yhi,presBDRYCOND, stratified
         if (probtype.eq.201) then

          if (z.le.zblob2) then
           ADV=-fort_denconst(1)*abs(gravity)*(z-zblob2)
          else
           ADV=-fort_denconst(3)*abs(gravity)*(z-zblob2)
          endif

         else if (SDIM.eq.2) then

          if (fort_material_type(1).eq.13) then ! yhi,2D, Tait EOS
           call boundary_hydrostatic(xpos,rhohydro,ADV)
          else if ((probtype.eq.36).and.(axis_dir.eq.0)) then
           ADV=-fort_denconst(1)*abs(gravity)*y
          else if ((probtype.eq.36).and.(axis_dir.eq.2)) then  ! yhi
           call tait_hydrostatic_pressure_density(xpos,rhohydro,ADV, &
                   from_boundary_hydrostatic)
           ! yhi, presBDRYCOND, 2D
          else if ((probtype.eq.9).and.(axis_dir.eq.1)) then  
           if (y.le.waterdepth) then
            ADV=-fort_denconst(1)*abs(gravity)*(y-waterdepth)
           else
            ADV=-fort_denconst(2)*abs(gravity)*(y-waterdepth)
           endif
          else if (probtype.eq.42) then ! bubble jetting 2D
           call tait_hydrostatic_pressure_density(xpos,rhohydro,ADV, &
                   from_boundary_hydrostatic)
          else if (probtype.eq.46) then ! cavitation yhi 2D
           if ((axis_dir.ge.0).and.(axis_dir.lt.10)) then
            call tait_hydrostatic_pressure_density(xpos,rhohydro,ADV, &
                    from_boundary_hydrostatic)
           else if (axis_dir.eq.10) then
            call tait_hydrostatic_pressure_density(xpos,rhohydro,ADV, &
                    from_boundary_hydrostatic)
           else if (axis_dir.eq.20) then
            ! do nothing (ADV=base_pres, base_pres=outflow_pressure above) 
           else
            print *,"axis_dir invalid"
            stop
           endif

          else if (probtype.eq.710) then
           ADV=-fort_denconst(1)*abs(gravity)*gravity_dz
          endif

          if (probtype.eq.41) then ! presBDRYCOND 2D yhi
           pipexlo=problox
           pipexhi=probhix
           if ((axis_dir.eq.1).or.(axis_dir.eq.2).or.(axis_dir.eq.3)) then
            pipexlo=zero
            pipexhi=two*radblob3
           endif

           if (axis_dir.eq.0) then
            ! do nothing
           else if (axis_dir.eq.1) then

            if (invert_gravity.ne.1) then
             print *,"invert gravity invalid"
             stop
            endif
            if (gravity_dir.ne.1) then
             print *,"gravity_dir invalid"
             stop
            endif
            if (x.lt.pipexlo) then
             ADV=zero
            else if (x.lt.xblob) then
             ADV=fort_denconst(2)*abs(gravity)*(x-pipexlo)
            else
             ADV=fort_denconst(2)*abs(gravity)*(xblob-pipexlo)+ &
                 fort_denconst(1)*abs(gravity)*(x-xblob) 
            endif

           else if (axis_dir.eq.2) then

            ! gravity force should be directed towards xhi
            ! pressure grows as one gets near to x=xhi
            if (invert_gravity.ne.1) then
             print *,"invert gravity invalid"
             stop
            endif
            if (gravity_dir.ne.1) then
             print *,"gravity_dir invalid"
             stop
            endif

            if (x.lt.pipexlo) then
             ADV=zero
            else if (x.lt.xblob-radblob2) then
             ADV=fort_denconst(1)*abs(gravity)*(x-pipexlo)
            else if (x.lt.xblob+radblob2) then
             ADV=fort_denconst(1)*abs(gravity)*(xblob-radblob2-pipexlo)+ &
                 fort_denconst(2)*abs(gravity)*(x-xblob+radblob2) 
            else
             ADV=fort_denconst(1)*abs(gravity)*(xblob-radblob2-pipexlo)+ &
                 fort_denconst(2)*abs(gravity)*(two*radblob2)+ & 
                 fort_denconst(1)*abs(gravity)*(x-xblob-radblob2) 
            endif

           else if (axis_dir.eq.3) then

            ! gravity force should be directed towards xhi
            ! pressure grows as one gets near to x=xhi
            if (invert_gravity.ne.1) then
             print *,"invert gravity invalid"
             stop
            endif
            if (gravity_dir.ne.1) then
             print *,"gravity_dir invalid"
             stop
            endif

            if (x.lt.pipexlo) then
             ADV=zero
            else 
             ADV=fort_denconst(1)*abs(gravity)*(x-pipexlo)
            endif

           else if (axis_dir.eq.4) then
            ! do nothing 
           else
            print *,"axis_dir invalid for pipe problem"
            stop
           endif  
  
           ! above, probtype=41 below supnozzle yhi - presBDRYCOND
          else if (probtype.eq.539) then
           ADV=outflow_pressure
          endif  

         else if (SDIM.eq.3) then

          if (fort_material_type(1).eq.13) then ! yhi, 3D, Tait EOS
           call boundary_hydrostatic(xpos,rhohydro,ADV)
          else if ((probtype.eq.36).and.(axis_dir.eq.0)) then ! yhi
           ADV=-fort_denconst(1)*abs(gravity)*z
           ! yhi, presBDRYCOND, 3D
          else if ((probtype.eq.9).and.(axis_dir.eq.1)) then  
           if (z.le.waterdepth) then
            ADV=-fort_denconst(1)*abs(gravity)*(z-waterdepth)
           else
            ADV=-fort_denconst(2)*abs(gravity)*(z-waterdepth)
           endif
          endif

         else 
          print *,"dimension bust"
          stop
         endif

        else if ((dir.eq.3).and.(side.eq.1).and.(SDIM.eq.3)) then  ! zlo
         if (xwall.lt.z) then
          print *,"xwall,z invalid"
          stop
         endif
         ADV=base_pres
         if (fort_material_type(1).eq.13) then ! zlo, 3D, Tait EOS
          call boundary_hydrostatic(xpos,rhohydro,ADV)
         else if (probtype.eq.201) then ! zlo stratified material 1 at bottom
          ADV=-fort_denconst(1)*abs(gravity)*(z-zblob2)
         else if ((probtype.eq.36).and.(axis_dir.eq.0)) then  ! zlo
          ADV=-fort_denconst(1)*abs(gravity)*z
         else if ((probtype.eq.9).and.(axis_dir.eq.1)) then  ! zlo, presBDRYCOND
          if (z.le.waterdepth) then
           ADV=-fort_denconst(1)*abs(gravity)*(z-waterdepth)
          else
           ADV=-fort_denconst(2)*abs(gravity)*(z-waterdepth)
          endif
         endif

          ! pressure bc at inflow
         if ((probtype.eq.53).and.(axis_dir.eq.2)) then ! injection shock
          call get_jet_vfrac(xsten,nhalf,dx,bfact,VOF,cenbc,num_materials)   
          if (VOF(1).gt.zero) then
           ADV=inflow_pressure
          endif 
           ! 3D zlo presBDRYCOND diesel injection w/needle
         else if (probtype.eq.538) then
          call get_initial_vfrac(xsten,nhalf,dx,bfact,VOF,cenbc,num_materials)
          if (VOF(1).gt.zero) then
           ADV=inflow_pressure
          endif
           ! 3D zlo presBDRYCOND diesel injection w/needle
         else if ((probtype.eq.541).and.(axis_dir.eq.2)) then
          call get_initial_vfrac(xsten,nhalf,dx,bfact,VOF,cenbc,num_materials)
          if (VOF(1).gt.zero) then
           ADV=inflow_pressure
          endif
         endif

        else if ((dir.eq.3).and.(side.eq.2).and.(SDIM.eq.3)) then  ! zhi
         if (xwall.gt.z) then
          print *,"xwall,z invalid"
          stop
         endif
         ADV=base_pres
         if (fort_material_type(1).eq.13) then ! zhi, 3D, Tait EOS
          call boundary_hydrostatic(xpos,rhohydro,ADV)
         else if (probtype.eq.201) then ! zhi, stratified
          ADV=-fort_denconst(3)*abs(gravity)*(z-zblob2)
         else if ((probtype.eq.36).and.(axis_dir.eq.0)) then ! zhi
          ADV=-fort_denconst(1)*abs(gravity)*z
         else if ((probtype.eq.9).and.(axis_dir.eq.1)) then  ! zhi, presBDRYCOND
          if (z.le.waterdepth) then
           ADV=-fort_denconst(1)*abs(gravity)*(z-waterdepth)
          else
           ADV=-fort_denconst(2)*abs(gravity)*(z-waterdepth)
          endif
         endif

        else
         print *,"dir side invalid"
         stop
        endif

       endif ! non-hydrate problems

      else
       print *,"pres_homflag invalid"
       stop
      endif

      ADV=ADV/global_pressure_scale

      return
      end subroutine presBDRYCOND

      subroutine derive_plot_data(xsten,nhalf,den,nmat)
      IMPLICIT NONE

      INTEGER_T nmat
      INTEGER_T nhalf
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T den(nmat*num_state_material)
      REAL_T temp_offset
      REAL_T gtemp_offset(SDIM)
      INTEGER_T im,icomp

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif
      if (nhalf.lt.1) then
       print *,"nhalf invalid"
       stop
      endif

      if (probtype.eq.82) then ! annulus
       call thermal_offset(xsten,nhalf,temp_offset,gtemp_offset)
       if (1.eq.0) then
        im=1
        icomp=(im-1)*num_state_material+2 ! temperature
        den(icomp)=den(icomp)+temp_offset
       endif
      endif

      end subroutine derive_plot_data
     
      ! called from FORT_STATEFILL, FORT_GROUP_STATEFILL if EXT_DIR
      subroutine denBC(time,dir,side,ADV,ADVwall_in, &
         xsten,nhalf,dx,bfact,istate,im)
      use global_utility_module
      use hydrateReactor_module
      use unimaterialChannel_module
      use marangoni
      use USERDEF_module
      use CAV3D_module
      use HELIX_module
      use TSPRAY_module
      use CAV2Dstep_module
      use ZEYU_droplet_impact_module
      use CONE3D_module
      use WAVY_Channel_module
      use rigid_FSI_module
      use sinking_particle_module

      IMPLICIT NONE

      INTEGER_T, intent(in) :: dir,side,istate,im,nhalf,bfact
      REAL_T, intent(in) :: xsten(-nhalf:nhalf,SDIM)
      REAL_T, intent(in) :: time
      REAL_T, intent(inout) :: ADV
      REAL_T xwall
      REAL_T ADVwall
      REAL_T x,y,z
      REAL_T, intent(inout) :: ADVwall_in
      REAL_T ADV_merge
      REAL_T dx(SDIM)
      REAL_T dist,water_temp
      INTEGER_T species_flag,local_homflag
      REAL_T xvec(SDIM)
      INTEGER_T local_dir
      REAL_T local_LS(num_materials)
      INTEGER_T try_merge
      REAL_T :: massfrac_parm(num_species_var+1)

      if (nhalf.lt.1) then
       print *,"nhalf invalid denbc"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if ((im.le.0).or.(im.gt.num_materials)) then
       print *,"im invalid80"
       stop
      endif
      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)
      do local_dir=1,SDIM
       xvec(local_dir)=xsten(0,local_dir)
      enddo

      if (dir.eq.1) then
       if (side.eq.1) then
        xwall=problox
       else
        xwall=probhix
       endif
      else if (dir.eq.2) then
       if (side.eq.1) then
        xwall=probloy
       else
        xwall=probhiy
       endif
      else if ((dir.eq.3).and.(SDIM.eq.3)) then
       if (side.eq.1) then
        xwall=probloz
       else
        xwall=probhiz
       endif
      else
       print *,"dir invalid denbc"
       stop
      endif
      if (num_state_base.ne.2) then
       print *,"num_state_base invalid in denBC"
       stop
      endif

      if ((istate.ge.1).and.(istate.le.num_state_base)) then
       species_flag=0
       if (istate.eq.1) then
        try_merge=0
       else if (istate.eq.2) then
        try_merge=1
       else
        print *,"istate invalid"
        stop
       endif
       if ((temp_homflag.eq.1).and.(istate.eq.2)) then
        local_homflag=1
       else
        local_homflag=0
       endif
      else if ((istate.gt.num_state_base).and. &
               (istate.le.num_state_material)) then
       species_flag=1
       try_merge=1
       if (species_homflag.eq.1) then
        local_homflag=1
       else
        local_homflag=0
       endif
      else
       print *,"istate invalid"
       stop
      endif

        ! homogeneous BC for temperature solver
      if ((temp_homflag.eq.1).and. &
          (species_flag.eq.0).and. &
          (istate.eq.2).and. &
          (local_homflag.eq.1)) then

       ADV=zero
       ADV_merge=zero

        ! homogeneous BC for species solver
      else if ((species_homflag.eq.1).and. &
               (species_flag.eq.1).and. &
               (istate.gt.num_state_base).and. &
               (istate.le.num_state_material).and. &
               (local_homflag.eq.1)) then

       ADV=zero
       ADV_merge=zero

      else if (local_homflag.eq.0) then

       if (istate.eq.1) then
        ADVwall=ADVwall_in   ! den
       else if (istate.eq.2) then
        ADVwall=ADVwall_in   ! T
       else if ((istate.gt.2).and. &
                (istate.le.num_state_material)) then
        ADVwall=ADVwall_in   ! species
       else
        print *,"istate invalid"
        stop
       endif

       if ((im.lt.1).or.(im.gt.num_materials)) then
        print *,"im invalid79"
        stop
       endif

       if (is_in_probtype_list().eq.1) then

        call SUB_LS(xvec,time,local_LS,num_materials)
        call SUB_STATE_BC(xwall,xvec,time,local_LS, &
         ADV,ADV_merge,ADVwall,im,istate,dir,side,dx,num_materials)

       else if (probtype.eq.411) then

        call CAV3D_LS(xvec,time,local_LS)
        call CAV3D_STATE_BC(xwall,xvec,time,local_LS, &
          ADV,ADV_merge,ADVwall,im,istate,dir,side,dx) 

       else if (probtype.eq.401) then

        call HELIX_LS(xvec,time,local_LS)
        call HELIX_STATE_BC(xwall,xvec,time,local_LS, &
          ADV,ADV_merge,ADVwall,im,istate,dir,side,dx) 

       else if (probtype.eq.402) then

        call TSPRAY_LS(xvec,time,local_LS)
        call TSPRAY_STATE_BC(xwall,xvec,time,local_LS, &
          ADV,ADV_merge,ADVwall,im,istate,dir,side,dx) 

       else if (probtype.eq.412) then ! step

        call CAV2Dstep_LS(xvec,time,local_LS)
        call CAV2Dstep_STATE_BC(xwall,xvec,time,local_LS, &
          ADV,ADV_merge,ADVwall,im,istate,dir,side,dx)

       else if (probtype.eq.413) then ! zeyu

        call ZEYU_droplet_impact_LS(xvec,time,local_LS)
        call ZEYU_droplet_impact_STATE_BC(xwall,xvec,time,local_LS, &
          ADV,ADV_merge,ADVwall,im,istate,dir,side,dx)

       else if (probtype.eq.533) then

        call rigid_FSI_LS(xvec,time,local_LS)
        call rigid_FSI_STATE_BC(xwall,xvec,time,local_LS, &
          ADV,ADV_merge,ADVwall,im,istate,dir,side,dx) 
       else if (probtype.eq.534) then

        call sinking_FSI_LS(xvec,time,local_LS)
        call sinking_FSI_STATE_BC(xwall,xvec,time,local_LS, &
          ADV,ADV_merge,ADVwall,im,istate,dir,side,dx) 

       else if (probtype.eq.311) then ! user defined

        call USERDEF_LS(xvec,time,local_LS)
        call USERDEF_STATE_BC(xwall,xvec,time,local_LS, &
          ADV,ADV_merge,ADVwall,im,istate,dir,side,dx) 

       else if (probtype.eq.222) then ! cone3d in denBC

        call CONE3D_LS(xvec,time,local_LS)
        call CONE3D_STATE_BC(xwall,xvec,time,local_LS, &
          ADV,ADV_merge,ADVwall,im,istate,dir,side,dx)

       else if (probtype.eq.915) then ! wavy channel

        call WAVY_INIT_LS(xvec,time,local_LS)
        call WAVY_STATE_BC(xwall,xvec,time,local_LS, &
          ADV,ADV_merge,ADVwall,im,istate,dir,side,dx)

       else if (species_flag.eq.0) then

        if (probtype.eq.82) then ! annulus: denBC

         if (istate.eq.1) then ! den
          ! do nothing
         else if (istate.eq.2) then ! temperature
          if (dir.eq.1) then ! r direction
           if (side.eq.1) then
            ADV=fort_tempconst(1)
           else if (side.eq.2) then
            ADV=fort_tempconst(1)  ! see: subroutine thermal_offset
           else
            print *,"side invalid"
            stop
           endif
          else if ((dir.eq.2).or.(dir.eq.SDIM)) then
           ! do nothing
          else
           print *,"dir invalid denbc 2"
           stop
          endif
         else
          print *,"istate invalid"
          stop
         endif

         ! in: subroutine denBC
         ! HYDRATES
        else if (probtype.eq.199) then

         if (istate.eq.1) then
          call HYD_DENS_BC(time,dir,side,ADV,xwall,ADVwall, &
            x,y,z,dx,im)
         else if (istate.eq.2) then
          call HYD_TEMP_BC(time,dir,side,ADV,xwall,ADVwall, &
            x,y,z,dx,im)
         else
          print *,"istate invalid"
          stop
         endif

         ! in: subroutine denBC
         ! UNIMATERIAL problem
        else if (probtype.eq.220) then

         if (istate.eq.1) then
          call UNIMAT_DENS_BC(time,dir,side,ADV,xwall,ADVwall, &
            x,y,z,dx,im)
         else if (istate.eq.2) then
          call UNIMAT_TEMP_BC(time,dir,side,ADV,xwall,ADVwall, &
            x,y,z,dx,im)
         else
          print *,"istate invalid"
          stop
         endif

        else if ((probtype.eq.299).or. &
                 (probtype.eq.301)) then !melting

         if (istate.eq.1) then ! density boundary condition
          ADV=ADVwall
         else if (istate.eq.2) then ! temperature boundary condition
          ADV=fort_tempconst(2)  ! gas temperature
         else
          print *,"istate invalid"
          stop
         endif

         ! marangoni (heat pipe) problem
        else if ((probtype.eq.36).and.(axis_dir.eq.10)) then

         if (istate.eq.1) then
          print *,"density bc should be FOEXTRAP"
          stop
         else if (istate.eq.2) then 
           ! flag=0 (no buffer, do not start w/room temp in the bulk)
           ! second parameter would be the lateral buffer size. (delta)
           ! third parameter would be the front/back buffer size. (delta2)
          call position_Temp(0,radblob,radblob2,x,y,z,ADV)
         else 
          print *,"istate invalid"
          stop
         endif
  
        else

          ! xlo
         if ((dir.eq.1).and.(side.eq.1)) then
          if (xwall.lt.x) then
           print *,"xwall,x invalid"
           stop
          endif
          ADV=ADVwall

          if (SDIM.eq.2) then

            ! xlo states (freezing singularity problem, boiling problem)
           if ((probtype.eq.59).or. &
               (probtype.eq.710)) then

            if (istate.eq.1) then
             ! do nothing (density)
            else if (istate.eq.2) then
             ! bcflag=1 (calling from denBC - boundary conditions
             ! for density, temperature and species variables)
             call outside_temperature(time,x,y,z,ADV,im,1) 
            else
             print *,"istate invalid"
             stop
            endif

            ! xlo states
            ! denBC: compare w/Welch and Wilson 2000
           else if (probtype.eq.801) then 

            if (num_materials.lt.2) then
             print *,"num_materials invalid probtype=801"
             stop
            endif
             ! temperature (probtype==801)
            if (istate.eq.2) then
             call vapordist(xsten,nhalf,dx,bfact,dist)
             if (dist.lt.zero) then
              ADV=fort_tempconst(2) ! vapor/ice temperature
             else 
              ADV=fort_tempconst(1) ! liquid temperature 
             endif
            endif
           else if (probtype.eq.802) then ! dissolution, xlo
            print *,"802 obsolete"
            stop
           else if (probtype.eq.532) then
            if (istate.eq.1) then
             ADV=fort_denconst(im)
            else if (istate.eq.2) then
             ADV=fort_tempconst(im)
            else
             print *,"istate invalid"
             stop
            endif 
           else if (probtype.eq.539) then ! xlo, sup, denBC

            if (istate.eq.1) then
             ADV=fort_denconst(im)
            else if (istate.eq.2) then
             ADV=fort_tempconst(im)
! Hack: inlet temperature (should not be called since outflow BC?)
             ADV=513.0
            else
             print *,"istate invalid"
             stop
            endif 

           else if (probtype.eq.53) then ! xlo, denBC

            if (istate.eq.1) then
             ADV=fort_denconst(im)
            else if (istate.eq.2) then
             ADV=fort_tempconst(im)
            else
             print *,"istate invalid"
             stop
            endif 
           endif  ! probtype=53

          else if (SDIM.eq.3) then

           if (probtype.eq.53) then
            if (istate.eq.1) then
             ADV=fort_denconst(im)
            else if (istate.eq.2) then
             ADV=fort_tempconst(im)
            else
             print *,"istate invalid"
             stop
            endif
           endif  ! probtype=53

          else
           print *,"dimension bust"
           stop
          endif

          ! xhi
         else if ((dir.eq.1).and.(side.eq.2)) then
          if (xwall.gt.x) then
           print *,"xwall,x invalid"
           stop
          endif
          ADV=ADVwall

          if (SDIM.eq.2) then

            ! xhi states (freezing singularity problem, boiling problem)
           if ((probtype.eq.59).or. &
               (probtype.eq.710)) then

            if (istate.eq.1) then
             ! do nothing (density)
            else if (istate.eq.2) then
             ! bcflag=1 (calling from denBC)
             call outside_temperature(time,x,y,z,ADV,im,1) 
            else
             print *,"istate invalid"
             stop
            endif

            ! xhi states
           else if (probtype.eq.801) then !denBC:compare w/Welch and Wilson 2000
            if (num_materials.lt.2) then
             print *,"num_materials invalid probtype=801"
             stop
            endif
            if (istate.eq.2) then
             call vapordist(xsten,nhalf,dx,bfact,dist)
             if (dist.lt.zero) then
              ADV=fort_tempconst(2) !vapor/ice temperature
             else 
              ADV=fort_tempconst(1) !liquid temperature (air temp in far field)
             endif
            endif
           else if (probtype.eq.532) then
            if (istate.eq.1) then
             ADV=fort_denconst(im)
            else if (istate.eq.2) then
             ADV=fort_tempconst(im)
            else
             print *,"istate invalid"
             stop
            endif 
           else if (probtype.eq.539) then  ! xhi, sup, denBC

            if (istate.eq.1) then
             ADV=fort_denconst(im)
            else if (istate.eq.2) then
             ADV=fort_tempconst(im)
            else
             print *,"istate invalid"
             stop
            endif 
           endif

          else if (SDIM.eq.3) then

          else
           print *,"dimension bust"
           stop
          endif

          ! ylo (subroutine denBC)
         else if ((dir.eq.2).and.(side.eq.1)) then
          if (xwall.lt.y) then
           print *,"xwall,y invalid"
           stop
          endif
          ADV=ADVwall

            ! ylo states

          if (SDIM.eq.2) then

            ! cavity boil: ylo 2D
           if (probtype.eq.710) then

            if (istate.eq.1) then
             ! do nothing (density)
            else if (istate.eq.2) then
             ! bcflag=1 (calling from denBC)
             call outside_temperature(time,x,y,z,ADV,im,1) 
            else
             print *,"istate invalid"
             stop
            endif

            ! melting ice block on substrate (subroutine denBC) 
            ! ylo
            ! prescribe_temperature_outflow:
            ! 0=dirichlet at inflow
            ! 1=dirichlet at inflow and outflow
            ! 2=dirichlet at inflow and walls.
            ! 3=dirichlet at inflow, outflow, and walls.
           else if ((prescribe_temperature_outflow.eq.3).and. &
                    (probtype.eq.59)) then

            if (istate.eq.1) then
             ! do nothing (density)
            else if (istate.eq.2) then
             ! bcflag=1 (calling from denBC)
             call outside_temperature(time,x,y,z,ADV,im,1) 
            else
             print *,"istate invalid"
             stop
            endif
  
            ! denBC: compare w/Welch and Wilson 2000
           else if (probtype.eq.801) then 

            if (num_materials.lt.2) then
             print *,"num_materials invalid probtype=801"
             stop
            endif
             ! ylo
            if (istate.eq.2) then
             call vapordist(xsten,nhalf,dx,bfact,dist)
             if (dist.lt.zero) then
              ADV=fort_tempconst(2) ! vapor/ice temperature
             else 
              ADV=fort_tempconst(1) ! liquid temperature + far field
             endif
            endif
           else if ((probtype.eq.538).or.(probtype.eq.53).or. &
                    (probtype.eq.541)) then
            if (istate.eq.1) then
             ADV=fort_denconst(im)
            else if (istate.eq.2) then
             ADV=fort_tempconst(im)
            else
             print *,"istate invalid"
             stop
            endif 
            ! above denBC - probtype=53 or 538 ylo face
            ! below Benard convection
           else if (probtype.eq.603) then
            water_temp=radblob2+fort_tempconst(1)
            call init_massfrac_parm(fort_denconst(1),massfrac_parm,1)
            call INTERNAL_material(fort_denconst(1),massfrac_parm, &
             water_temp, &
             fort_energyconst(1),fort_material_type(1),1)
            if (fort_energyconst(1).gt.zero) then
             ! do nothing
            else
             print *,"fort_energyconst(1) invalid in denBC ylo"
             print *,"fort_energyconst(1)=",fort_energyconst(1)
             stop
            endif

            ! this density will never be used at the wall.
            if (istate.eq.1) then 
             ADV=fort_denconst(im)
            else if (istate.eq.2) then
             ADV=water_temp
            else
             print *,"istate invalid"
             stop
            endif 

           endif   ! probtype.eq.603

          else if (SDIM.eq.3) then

           ! ylo states
           if (probtype.eq.532) then
            if (istate.eq.1) then
             ADV=fort_denconst(im)
            else if (istate.eq.2) then
             ADV=fort_tempconst(im)
            else
             print *,"istate invalid"
             stop
            endif
           endif  ! probtype=532

          else
           print *,"dimension bust"
           stop
          endif

          ! yhi
         else if ((dir.eq.2).and.(side.eq.2)) then
          if (xwall.gt.y) then
           print *,"xwall,y invalid"
           stop
          endif
          ADV=ADVwall

          if (SDIM.eq.2) then

            ! in: subroutine denBC
            ! yhi states 2d (freezing singularity problem, boiling)
           if ((probtype.eq.59).or. &
               (probtype.eq.710)) then

            if (istate.eq.1) then
             ! do nothing
            else if (istate.eq.2) then
             ! bcflag=1 (calling from denBC)
             call outside_temperature(time,x,y,z,ADV,im,1) 
            else
             print *,"istate invalid"
             stop
            endif

            ! yhi states
           else if (probtype.eq.801) then !denBC:compare w/Welch and Wilson 2000
            if (num_materials.lt.2) then
             print *,"num_materials invalid probtype=801"
             stop
            endif
            if (istate.eq.2) then
             call vapordist(xsten,nhalf,dx,bfact,dist)
             if (dist.lt.zero) then
              ADV=fort_tempconst(2) ! vapor/ice temperature
             else 
              ADV=fort_tempconst(1) ! liquid temperature then far field.
             endif
            endif

           ! Benard convection yhi
           else if (probtype.eq.603) then
            water_temp=fort_tempconst(1)
            call init_massfrac_parm(fort_denconst(1),massfrac_parm,1)
            call INTERNAL_material(fort_denconst(1),massfrac_parm, &
             water_temp, &
             fort_energyconst(1),fort_material_type(1),1)
            if (fort_energyconst(1).gt.zero) then
             ! do nothing
            else
             print *,"fort_energyconst(1) invalid in denBC yhi"
             print *,"fort_energyconst(1)=",fort_energyconst(1)
             stop
            endif

            ! this density will never be used at the wall.
            if (istate.eq.1) then
             ADV=fort_denconst(im)
            else if (istate.eq.2) then
             ADV=water_temp
            else
             print *,"istate invalid"
             stop
            endif 

           endif  

          else if (SDIM.eq.3) then

           ! 3d yhi states denBC
           if ((probtype.eq.532).or.(probtype.eq.541)) then
            if (istate.eq.1) then
             ADV=fort_denconst(im)
            else if (istate.eq.2) then
             ADV=fort_tempconst(im)
            else
             print *,"istate invalid"
             stop
            endif
           endif  ! probtype=532

          else
           print *,"dimension bust"
           stop
          endif

           ! zlo
         else if ((dir.eq.3).and.(side.eq.1).and.(SDIM.eq.3)) then
          if (xwall.lt.z) then
           print *,"xwall,z invalid"
           stop
          endif
          ADV=ADVwall

           ! melting ice block: zlo
          if ((prescribe_temperature_outflow.eq.3).and. &
              (probtype.eq.59)) then

           if (istate.eq.1) then
            ! do nothing (density)
           else if (istate.eq.2) then
             ! bcflag=1 (calling from denBC)
            call outside_temperature(time,x,y,z,ADV,im,1)
           else
            print *,"istate invalid"
            stop
           endif

           ! cavity boil: zlo 3D
          else if (probtype.eq.710) then

           if (istate.eq.1) then
            ! do nothing (density)
           else if (istate.eq.2) then
             ! bcflag=1 (calling from denBC)
            call outside_temperature(time,x,y,z,ADV,im,1) 
           else
            print *,"istate invalid"
            stop
           endif

          else if (probtype.eq.53) then
           if (istate.eq.1) then
            ADV=fort_denconst(im)
           else if (istate.eq.2) then
            ADV=fort_tempconst(im)
           else
            print *,"istate invalid"
            stop
           endif 
           ! above probtype.eq.53
           ! zlo states
          else if ((probtype.eq.530).or.(probtype.eq.538).or. &
                   (probtype.eq.541)) then
           if (istate.eq.1) then
            ADV=fort_denconst(im)
           else if (istate.eq.2) then
            ADV=fort_tempconst(im)
           else
            print *,"istate invalid"
            stop
           endif 
           ! above probtype=530 or 538
          else if (probtype.eq.603) then ! Benard convection zlo denBC
           water_temp=radblob2+fort_tempconst(1)
           call init_massfrac_parm(fort_denconst(1),massfrac_parm,1)
           call INTERNAL_material(fort_denconst(1),massfrac_parm, &
            water_temp, &
            fort_energyconst(1),fort_material_type(1),1)
           if (fort_energyconst(1).gt.zero) then
            ! do nothing
           else
            print *,"fort_energyconst(1) invalid in denBC zlo"
            print *,"fort_energyconst(1)=",fort_energyconst(1)
            stop
           endif

            ! this density will never be used at the wall.
           if (istate.eq.1) then 
            ADV=fort_denconst(im) 
           else if (istate.eq.2) then
            ADV=water_temp
           else
            print *,"istate invalid"
            stop
           endif
   
          endif  ! probtype.eq.603

          ! zhi
         else if ((dir.eq.3).and.(side.eq.2).and.(SDIM.eq.3)) then
          if (xwall.gt.z) then
           print *,"xwall,z invalid"
           stop
          endif
          ADV=ADVwall

           ! cavity boil: zhi 3D
          if (probtype.eq.710) then
             
           if (istate.eq.1) then
            ! do nothing
           else if (istate.eq.2) then
             ! bcflag=1 (calling from denBC)
            call outside_temperature(time,x,y,z,ADV,im,1)
           else
            print *,"istate invalid"
            stop
           endif

           ! Benard convection zhi
          else if (probtype.eq.603) then
           water_temp=fort_tempconst(1)
           call init_massfrac_parm(fort_denconst(1),massfrac_parm,1)
           call INTERNAL_material(fort_denconst(1),massfrac_parm,  &
            water_temp, &
            fort_energyconst(1),fort_material_type(1),1)
           if (fort_energyconst(1).gt.zero) then
            ! do nothing
           else
            print *,"fort_energyconst(1) invalid in denBC zhi"
            print *,"fort_energyconst(1)=",fort_energyconst(1)
            stop
           endif

            ! this density will never be used at the wall.
           if (istate.eq.1) then
            ADV=fort_denconst(im)
           else if (istate.eq.2) then
            ADV=water_temp
           else
            print *,"istate invalid"
            stop
           endif 

          endif  

         else
          print *,"dir side invalid"
          stop
         endif

         if (istate.eq.1) then
          ! do nothing: den
         else if (istate.eq.2) then
          ! do nothing: T
         else
          print *,"istate invalid"
          stop
         endif

        endif ! non-hydrate problems

        ADV_merge=ADV

       else if (species_flag.eq.1) then

        ! CODY ESTEBE created test problem (species=0 at inflow)
        if ((probtype.eq.46).and.(axis_dir.eq.20)) then

         ADV=zero

        else if (probtype.eq.199) then

         call HYD_CCNT_BC(time,dir,side,ADV,xwall,ADVwall, &
          x,y,z,dx,im)

        else 

         if ((dir.eq.1).and.(side.eq.1)) then
          if (xwall.lt.x) then
           print *,"xwall,x invalid"
           stop
          endif
          ADV=ADVwall
         else if ((dir.eq.1).and.(side.eq.2)) then
          if (xwall.gt.x) then
           print *,"xwall,x invalid"
           stop
          endif
          ADV=ADVwall
         else if ((dir.eq.2).and.(side.eq.1)) then
          if (xwall.lt.y) then
           print *,"xwall,y invalid"
           stop
          endif
          ADV=ADVwall
         else if ((dir.eq.2).and.(side.eq.2)) then
          if (xwall.gt.y) then
           print *,"xwall,y invalid"
           stop
          endif
          ADV=ADVwall
         else if ((dir.eq.3).and.(side.eq.1).and.(SDIM.eq.3)) then
          if (xwall.lt.z) then
           print *,"xwall,z invalid"
           stop
          endif
          ADV=ADVwall
         else if ((dir.eq.3).and.(side.eq.2).and.(SDIM.eq.3)) then
          if (xwall.gt.z) then
           print *,"xwall,z invalid"
           stop
          endif
          ADV=ADVwall
         else
          print *,"dir side invalid"
          stop
         endif

        endif ! not hydrate problem

        ADV_merge=ADV

       else
        print *,"species_flag invalid"
        stop
       endif

       if (try_merge.eq.1) then
        if (num_materials_scalar_solve.eq.num_materials) then
         ! do nothing
        else if (num_materials_scalar_solve.eq.1) then
         ADV=ADV_merge
        else
         print *,"num_materials_scalar_solve invalid"
         stop
        endif
       else if (try_merge.eq.0) then
        ! do nothing
       else
        print *,"try_merge invalid"
        stop
       endif
      else
       print *,"temp_homflag,species_homflag, or local_homflag invalid"
       stop
      endif  

      return
      end subroutine denBC

      subroutine tensorBC(time,dir,side,ADV,ADVwall, &
        xsten,nhalf,dx,bfact,ipart,im)
      IMPLICIT NONE

      INTEGER_T, intent(in) :: ipart,im
      INTEGER_T, intent(in) :: dir,side,bfact,nhalf
      REAL_T, intent(in) :: xsten(-nhalf:nhalf,SDIM)
      REAL_T, intent(in) :: time
      REAL_T, intent(out) :: ADV
      REAL_T, intent(in) :: ADVwall
      REAL_T, intent(in) :: dx(SDIM)
      REAL_T :: x,y,z
      REAL_T :: xwall

      if (nhalf.lt.1) then
       print *,"nhalf invalid tensorbc"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if ((ipart.lt.1).or. &
          (ipart.gt.num_materials_viscoelastic)) then
       print *,"ipart invalid"
       stop
      endif
      if ((im.lt.1).or.(im.gt.num_materials)) then
       print *,"im invalid81"
       stop
      endif
      if (fort_im_elastic_map(ipart)+1.ne.im) then
       print *,"fort_im_elastic_map(ipart)+1.ne.im"
       stop
      endif

      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)

      if (dir.eq.1) then
       if (side.eq.1) then
        xwall=problox
       else
        xwall=probhix
       endif
      else if (dir.eq.2) then
       if (side.eq.1) then
        xwall=probloy
       else
        xwall=probhiy
       endif
      else if ((dir.eq.3).and.(SDIM.eq.3)) then
       if (side.eq.1) then
        xwall=probloz
       else
        xwall=probhiz
       endif
      else
       print *,"dir invalid tensorbc"
       stop
      endif

      if ((dir.eq.1).and.(side.eq.1)) then
       if (xwall.lt.x) then
        print *,"xwall,x invalid"
        stop
       endif
       ADV=ADVwall
       ADV=zero
      else if ((dir.eq.1).and.(side.eq.2)) then
       if (xwall.gt.x) then
        print *,"xwall,x invalid"
        stop
       endif
       ADV=ADVwall
       ADV=zero
      else if ((dir.eq.2).and.(side.eq.1)) then
       if (xwall.lt.y) then
        print *,"xwall,y invalid"
        stop
       endif
       ADV=ADVwall
       ADV=zero
      else if ((dir.eq.2).and.(side.eq.2)) then
       if (xwall.gt.y) then
        print *,"xwall,y invalid"
        stop
       endif
       ADV=ADVwall
       ADV=zero
      else if ((dir.eq.3).and.(side.eq.1).and.(SDIM.eq.3)) then
       if (xwall.lt.z) then
        print *,"xwall,z invalid"
        stop
       endif
       ADV=ADVwall
       ADV=zero
      else if ((dir.eq.3).and.(side.eq.2).and.(SDIM.eq.3)) then
       if (xwall.gt.z) then
        print *,"xwall,z invalid"
        stop
       endif
       ADV=ADVwall
       ADV=zero
      else
       print *,"dir side invalid"
       stop
      endif

      return
      end subroutine tensorBC


      subroutine xdisplaceBC(time,dir,side,ADV,ADVwall, &
        xsten,nhalf,dx,bfact,dir_xdisplace)
      IMPLICIT NONE

      INTEGER_T, intent(in) :: dir_xdisplace
      INTEGER_T, intent(in) :: dir,side,bfact,nhalf
      REAL_T, intent(in) :: xsten(-nhalf:nhalf,SDIM)
      REAL_T, intent(in) :: time
      REAL_T, intent(out) :: ADV
      REAL_T, intent(in) :: ADVwall
      REAL_T, intent(in) :: dx(SDIM)
      REAL_T :: x,y,z
      REAL_T :: xwall

      if (nhalf.lt.1) then
       print *,"nhalf invalid xdisplacebc"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if ((dir_xdisplace.lt.1).or. &
          (dir_xdisplace.gt.SDIM)) then
       print *,"dir_xdisplace invalid"
       stop
      endif

      x=xsten(0,1)
      y=xsten(0,2)
      z=xsten(0,SDIM)

      if (dir.eq.1) then
       if (side.eq.1) then
        xwall=problox
       else
        xwall=probhix
       endif
      else if (dir.eq.2) then
       if (side.eq.1) then
        xwall=probloy
       else
        xwall=probhiy
       endif
      else if ((dir.eq.3).and.(SDIM.eq.3)) then
       if (side.eq.1) then
        xwall=probloz
       else
        xwall=probhiz
       endif
      else
       print *,"dir invalid tensorbc"
       stop
      endif

      if ((dir.eq.1).and.(side.eq.1)) then
       if (xwall.lt.x) then
        print *,"xwall,x invalid"
        stop
       endif
       ADV=ADVwall
       ADV=zero
      else if ((dir.eq.1).and.(side.eq.2)) then
       if (xwall.gt.x) then
        print *,"xwall,x invalid"
        stop
       endif
       ADV=ADVwall
       ADV=zero
      else if ((dir.eq.2).and.(side.eq.1)) then
       if (xwall.lt.y) then
        print *,"xwall,y invalid"
        stop
       endif
       ADV=ADVwall
       ADV=zero
      else if ((dir.eq.2).and.(side.eq.2)) then
       if (xwall.gt.y) then
        print *,"xwall,y invalid"
        stop
       endif
       ADV=ADVwall
       ADV=zero
      else if ((dir.eq.3).and.(side.eq.1).and.(SDIM.eq.3)) then
       if (xwall.lt.z) then
        print *,"xwall,z invalid"
        stop
       endif
       ADV=ADVwall
       ADV=zero
      else if ((dir.eq.3).and.(side.eq.2).and.(SDIM.eq.3)) then
       if (xwall.gt.z) then
        print *,"xwall,z invalid"
        stop
       endif
       ADV=ADVwall
       ADV=zero
      else
       print *,"dir side invalid"
       stop
      endif

      return
      end subroutine xdisplaceBC


      subroutine velread_bc_point(x,y,z,dir,velcomp,isann,time,vbc_point)

      IMPLICIT NONE
      INTEGER_T dir,velcomp,isann
      REAL_T    x,y,z,time,vbc_point


      INTEGER_T nr,na
      REAL_T    dt1,dt2,r,a0,a,daa,twopi
      REAL_T    rbc(NR_MAX),vbc1(NS_MAX),vbc2(NS_MAX)

      ! interpolation on polar grid
      twopi=8.0*ATAN(1.0)
      if(dir.eq.1) then
       r = sqrt((y-yblob)**2+(z-zblob)**2)
       a = atan2((z-zblob),(y-yblob))
      else if(dir.eq.2) then
       r = sqrt((z-zblob)**2+(x-xblob)**2)
       a = atan2((x-xblob),(z-zblob))
      else if(dir.eq.3) then
       r = sqrt((x-xblob)**2+(y-yblob)**2)
       a = atan2((y-yblob),(x-xblob))
      endif

      ! Hack: this is taking too long
      if(velcomp.eq.3.and.r.le.radblob) then
       vbc_point = advbot
      else
       vbc_point = 0.
      endif
      return
        
      ! Unfortunately, the full file needs to be read for this point
      call velread_polar(dir,velcomp,isann,time, &
                         dt1,dt2,a0,rbc,vbc1,vbc2,nr,na)
      a = a-a0
      if (a.lt.0) then
       a = a+twopi
      endif
      daa = twopi/(na+1.0)    ! assume regular angular spacing
      if (isann.eq.0) then
       vbc_point = zero  ! initialize to zero only once
       if(r.lt.rbc(nr)) then
        call interp_polar(r,a,daa,dt1,dt2,rbc,vbc1,vbc2,nr,na,vbc_point)
       endif
      else if ((isann.eq.1).and.(r.lt.rbc(nr)).and.(r.gt.rbc(1))) then
       call interp_polar(r,a,daa,dt1,dt2,rbc,vbc1,vbc2,nr,na,vbc_point)
      endif

      return
      end subroutine


      subroutine interp_polar(r,a,daa,dt1,dt2,rbc,vbc1,vbc2,nr,na,vinterp)

      IMPLICIT NONE
      INTEGER_T    nr,na
      REAL_T       r,a,daa,dt1,dt2,vinterp
      REAL_T       rbc(NR_MAX),vbc1(NS_MAX),vbc2(NS_MAX)

      INTEGER_T l1,l2,m,m1,m2
      REAL_T r1,r2,da1,da2,dr1,dr2,v1,v2
      REAL_T vel111,vel112,vel121,vel122,vel211,vel212,vel221,vel222

       dr1 = 0.
       dr2 = 0.
       if(r.le.rbc(1)) then    ! extrapolate to the centerline i
                               ! (special case that happens for isann =
                               ! 0 only)
        dr2 = rbc(1)
        m1 = 1
        m2 = 1
       endif
       if(r.lt.rbc(nr).and.r.gt.rbc(1)) then  ! radial interpolation 
        do m = 2,nr
         if((r.gt.rbc(m-1)).and.(r.le.rbc(m))) then
          m1 = m-1
          m2 = m
          goto 30
         endif
        enddo
  30    r1 = rbc(m1)
        r2 = rbc(m2)
        dr1 = r-r1
        dr2 = r2-r
       endif

       if(dr2.gt.0) then          ! angle interpolation
        if ((m1.lt.1).or.(m2.lt.1).or.(m1.gt.nr).or.(m2.gt.nr)) then
         print *,"incorrect radial interpolation point(s) ",m1,m2
         stop
        endif
        l1 = ceiling(a/daa)
        if(l1.ge.na) then
         l1 = na
         l2 = 1
        else
         l2 = l1+1
        endif
        da1 = a-(l1-1)*daa
        da2 = daa-da1
        if ((l1.lt.1).or.(l2.lt.1).or.(l1.gt.na).or.(l2.gt.na)) then
         print *,"incorrect angular interpolation point(s) ",l1,l2
         stop
        endif
        vel111 = vbc1(m1+nr*(l1-1))
        vel121 = vbc1(m2+nr*(l1-1))
        vel112 = vbc1(m1+nr*(l2-1))
        vel122 = vbc1(m2+nr*(l2-1))
        v1 = vel111*dr2*da2+vel121*dr1*da2+vel112*dr2*da1+vel122*dr1*da1
        vel211 = vbc2(m1+nr*(l1-1))
        vel221 = vbc2(m2+nr*(l1-1))
        vel212 = vbc2(m1+nr*(l2-1))
        vel222 = vbc2(m2+nr*(l2-1))
        v2 = vel211*dr2*da2+vel221*dr1*da2+vel212*dr2*da1+vel222*dr1*da1
        vinterp = (dt2*v1+dt1*v2)/(dr1+dr2)/(da1+da2)/(dt1+dt2)
       else
        vinterp = 0.
       endif ! if(dr2.gt.0.)

      return
      end subroutine


      subroutine velread_polar(dir,velcomp,isann,time, &
                               dt1,dt2,a0,r_store,v1_store,v2_store,nr,na)

      ! Reads two consecutive velocity fields from a sequence of files
      ! spaced by 
      ! time "tinterv" and covering a total time "period"
      ! Two polar geometries allowed: filled circle and ring (isann =
      ! 0,1)

      IMPLICIT NONE

      INTEGER_T    isann ! to distinguish between tube (0) and annular (1) geometry
      INTEGER_T    dir,velcomp ! face direction,velocity component
      INTEGER_T    nr,na ! number of radial and tangential points
      REAL_T time,a0,r_store(NR_MAX),v1_store(NS_MAX),v2_store(NS_MAX)
      ! reference angle, radial positions, velocity fields


      character vel_file1*80, vel_file2*80
      INTEGER_T i,j,nr2,na2,interv1,interv2
      REAL_T rscale,rinner,router,dt1,dt2
      REAL_T lref,vref,ptime1,ptime2,period,tinterv
      REAL_T, dimension(:), allocatable :: rbc
      REAL_T, dimension(:,:), allocatable :: vbc1
      REAL_T, dimension(:,:), allocatable :: vbc2

      if(isann.eq.0) then
       rinner = 0.
       router = radblob
       vref = advbot
      else
       rinner = radblob2
       router = radblob3
       vref = radblob4
      endif
      lref = router-rinner
      period = radblob5*lref/vref      ! overall duration of the records
      tinterv = radblob6*lref/vref     ! time spacing between records

      ! find correct time and open file
      ptime1 = mod(time,period)
      interv1 = floor(ptime1/tinterv)+1
      ! for interpolation in time
      dt1 = ptime1-(interv1-1)*tinterv
      ptime2 = mod(time+tinterv,period)
      interv2 = floor(ptime2/tinterv)+1
      dt2 = tinterv-dt1
      if ((dt1.lt.0.).or.(dt2.le.0)) then
       print *,"incorrect interpolation interval(s) in velread_polar",dt1,dt2
       stop
      endif

      ! Generate file name
      ! Note: synthetic turbulent inflow was generated along the x axis 
      if(isann.eq.0) then

       if(dir.eq.1) then
        if(velcomp.eq.1) then
         WRITE(vel_file1,111) interv1
         WRITE(vel_file2,111) interv2
        else if(velcomp.eq.2) then
         WRITE(vel_file1,222) interv1
         WRITE(vel_file2,222) interv2
        else if(velcomp.eq.3) then
         WRITE(vel_file1,333) interv1
         WRITE(vel_file2,333) interv2
        else
         print *,"invalid velocity component in velread_polar "
         stop
        endif
       else if(dir.eq.2) then
        if(velcomp.eq.1) then
         WRITE(vel_file1,333) interv1
         WRITE(vel_file2,333) interv2
        else if(velcomp.eq.2) then
         WRITE(vel_file1,111) interv1
         WRITE(vel_file2,111) interv2
        else if(velcomp.eq.3) then
         WRITE(vel_file1,222) interv1
         WRITE(vel_file2,222) interv2
        else
         print *,"invalid velocity component in velread_polar "
         stop
        endif
       else if(dir.eq.3) then
        if(velcomp.eq.1) then
         WRITE(vel_file1,222) interv1
         WRITE(vel_file2,222) interv2
        else if(velcomp.eq.2) then
         WRITE(vel_file1,333) interv1
         WRITE(vel_file2,333) interv2
        else if(velcomp.eq.3) then
         WRITE(vel_file1,111) interv1
         WRITE(vel_file2,111) interv2
        else
         print *,"invalid velocity component in velread_polar "
         stop
        endif
       endif

      else if(isann.eq.1) then

       if(dir.eq.1) then
        if(velcomp.eq.1) then
         WRITE(vel_file1,444) interv1
         WRITE(vel_file2,444) interv2
        else if(velcomp.eq.2) then
         WRITE(vel_file1,555) interv1
         WRITE(vel_file2,555) interv2
        else if(velcomp.eq.3) then
         WRITE(vel_file1,666) interv1
         WRITE(vel_file2,666) interv2
        else
         print *,"invalid velocity component in velread_polar "
         stop
        endif
       else if(dir.eq.2) then
        if(velcomp.eq.1) then
         WRITE(vel_file1,666) interv1
         WRITE(vel_file2,666) interv2
        else if(velcomp.eq.2) then
         WRITE(vel_file1,444) interv1
         WRITE(vel_file2,444) interv2
        else if(velcomp.eq.3) then
         WRITE(vel_file1,555) interv1
         WRITE(vel_file2,555) interv2
        else
         print *,"invalid velocity component in velread_polar "
         stop
        endif
       else if(dir.eq.3) then
        if(velcomp.eq.1) then
         WRITE(vel_file1,555) interv1
         WRITE(vel_file2,555) interv2
        else if(velcomp.eq.2) then
         WRITE(vel_file1,666) interv1
         WRITE(vel_file2,666) interv2
        else if(velcomp.eq.3) then
         WRITE(vel_file1,444) interv1
         WRITE(vel_file2,444) interv2
        else
         print *,"invalid velocity component in velread_polar "
         stop
        endif
       endif

      endif

      OPEN(unit=25,file=vel_file1,access='sequential', &
      form="formatted",status='old',err=901)
      READ(25,*) nr,na  ! number of radial and tangential components
      if ((nr.le.0).or.(na.le.0)) then
       print *,"Parameters ",nr,na, " are inconsistent ",nr,na
       stop
      endif
      if ((nr.gt.NR_MAX).or.(nr*na.gt.NS_MAX)) then
       print *,"Increase the buffer size: nr = ",nr," and na = ",nr,na
       stop
      endif
      allocate(rbc(nr))
      allocate(vbc1(nr,na))
      allocate(vbc2(nr,na))
      READ(25,*) a0  ! angle of the first coordinate
      READ(25,*) (rbc(i),i=1,nr)
      do j = 1,na
       READ(25,*) (vbc1(i,j),i=1,nr)
      enddo
      CLOSE(25)
      goto 10
 901  WRITE(6,911) vel_file1
      stop

  10  OPEN(unit=26,file=vel_file2,access='sequential', &
      form="formatted",status='old',err=902)
      READ(26,*) nr2,na2 ! should be the same as above
      if ((nr2.ne.nr).or.(na2.ne.na)) then
       print *,"the size ",nr2,na2, &
        " of the velocity tables does not match existing ",nr,na
       stop
      endif
      READ(26,*) a0
      READ(26,*) (rbc(i),i=1,nr)
      do j = 1,na
       READ(26,*) (vbc2(i,j),i=1,nr)
      enddo
      CLOSE(26)
      goto 20
 902  WRITE(6,911) vel_file2
      stop

 111  FORMAT ('./turbinlet/uinn',I3.3,'.dat')
 222  FORMAT ('./turbinlet/vinn',I3.3,'.dat')
 333  FORMAT ('./turbinlet/winn',I3.3,'.dat')
 444  FORMAT ('./turbinlet/uout',I3.3,'.dat')
 555  FORMAT ('./turbinlet/vout',I3.3,'.dat')
 666  FORMAT ('./turbinlet/wout',I3.3,'.dat')
 911  FORMAT(" Can't open file ",a," stopping ...")

  20  rscale = 2.*router      ! the normalized radius is 0.5
      do i = 1,nr
       r_store(i)=rscale*rbc(i)
       do j = 1,na
        v1_store(i+nr*(j-1)) = vref*vbc1(i,j)
        v2_store(i+nr*(j-1)) = vref*vbc2(i,j)
       enddo
      enddo

      deallocate(rbc)
      deallocate(vbc1)
      deallocate(vbc2)

      return
      end subroutine








! L rho= rho^* dx
! rho^*=L rho/dx
! xlo,xhi is bounding box for "side" neighbor of face
! side=0,1  dir=0,1
      subroutine override_mass_side(xlo,xhi,mass_side,delta,side,dir)
      IMPLICIT NONE

      INTEGER_T side,dir
      REAL_T xlo,xhi,mass_side,delta

     
      if ((side.ne.0).and.(side.ne.1)) then
       print *,"side invalid"
       stop
      endif
      if ((dir.lt.0).or.(dir.ge.SDIM)) then
       print *,"dir invalid override mass side"
       stop
      endif

      if (probtype.eq.102) then
       if (yblob4.le.zero) then
        print *,"yblob4 invalid"
        stop
       endif
       if (yblob5.le.zero) then
        print *,"yblob5 invalid"
        stop
       endif
       if (dir.eq.1) then

        if (side.eq.0) then
         if (half*(xlo+xhi).lt.zero) then
          mass_side=mass_side*yblob4/delta
         endif
        else if (side.eq.1) then
         if (half*(xlo+xhi).gt.probhiy) then
          mass_side=mass_side*yblob5/delta
         endif
        else
         print *,"side invalid"
         stop
        endif
 
       else if (dir.eq.0) then
 
       else
        print *,"dir invalid override mass side 2"
        stop
       endif

      endif

      return
      end subroutine override_mass_side

      subroutine override_facecut(facecut,xface,dir)
      IMPLICIT NONE

      REAL_T facecut
      REAL_T xface(SDIM)
      INTEGER_T dir


      if (probtype.eq.102) then
       if (dir.eq.1) then
        if ((xface(2).le.1.0D-10).and.(xface(1).ge.radblob5).and. &
            (xface(1).le.radblob3)) then
         facecut=zero  ! override gas inflow
        endif
       else if (dir.eq.0) then

       else
        print *,"dir invalid override_facecut"
        stop
       endif
      endif

      return
      end subroutine override_facecut


! called if probtype=540
      subroutine get_Rieber_velocity(xsten,nhalf,bfact,dx,vel)
      IMPLICIT NONE

      INTEGER_T nhalf,bfact
      REAL_T xsten(-nhalf:nhalf,SDIM)
      REAL_T dx(SDIM)
      REAL_T cenbc(num_materials,SDIM)
      REAL_T vel(SDIM)

      INTEGER_T dir2
      REAL_T vfrac(num_materials)
      REAL_T midz
      INTEGER_T nmat

      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (nhalf.lt.1) then
       print *,"nhalf invalid get_Rieber_velocity"
       stop
      endif
      nmat=num_materials

      do dir2=1,SDIM
       vel(dir2)=zero
      enddo

      if (probtype.eq.540) then

       call get_initial_vfrac(xsten,nhalf,dx,bfact,vfrac,cenbc,nmat)  
       if (SDIM.eq.2) then
        midz=half*((yblob-radblob)+radblob2)
        if ((vfrac(1).gt.zero).and.(xsten(0,SDIM).ge.midz)) then  
         vel(SDIM)=-abs(advbot)
        endif
       else if (SDIM.eq.3) then
        midz=half*((zblob-radblob)+radblob2)
        if ((vfrac(1).gt.zero).and.(xsten(0,SDIM).ge.midz)) then  
         vel(SDIM)=-abs(advbot)
        endif
       else
        print *,"dimension bust"
        stop
       endif
 
      else
       print *,"probtype invalid"
       stop
      endif

      return
      end subroutine get_Rieber_velocity

        ! RGASRWATER is the ratio of the total domain width to the
        ! liquid domain width.
        ! 0<r<1 liquid
        ! 1<r<RGASRWATER  gas
      subroutine get_surface_tension_wave_speed(dxmin,Uscale,Lscale, &
        Re,We,RGASRWATER,wave_speed,density_ratio,viscosity_ratio, &
        wave_speed_target)
      IMPLICIT NONE


      REAL_T wave_speed_target
      REAL_T density_ratio,viscosity_ratio
      REAL_T wave_speed,local_wave_speed
      REAL_T Uscale,Lscale
      REAL_T dxmin
      REAL_T Re,We,RGASRWATER
      INTEGER_T N1parm,N2parm
      real*8 :: alpha_real  ! set to 2 pi/dxmin
      real*8 :: alpha_imag  ! set to 0.0
      real*8 :: PI_LSA

      integer :: M, j, k
      complex*16 :: alpha
      complex*16, dimension(:,:), allocatable :: eigenv
      complex*16, dimension(:), allocatable :: omega1

      real*8, dimension(:), allocatable :: r1
      real*8, dimension(:), allocatable :: r2

      real*8  :: omega_real,omega_imag,ki,kr
      real*8  :: omega_before_real,omega_before_imag
      real*8  :: err

      PI_LSA=4.0*ATAN(1.0)
      N1parm=64
      N2parm=N1parm
      alpha_imag=0.0
      alpha_real=2.0*PI_LSA*Lscale/dxmin

      print *,"surface tension alpha_real,alpha_imag ", &
         alpha_real,alpha_imag
      alpha=DCMPLX(alpha_real, alpha_imag)
      
     
        ! u, w, p, f  (v is radial velocity; not used in 2d)
        ! noslip and interface continuity conditions are hardwired.
      M=(N1parm+N2parm+2)*3+1-6

      allocate(r1(0:N1parm))
      allocate(r2(0:N2parm))

      allocate(omega1(M))
      allocate(eigenv(M,M))

      print *,"calling tlsa2d M=",M
      call tlsa2d(M, alpha, omega1, eigenv, N1parm, N2parm,  &
        r1, r2, Re,We,RGASRWATER,density_ratio,viscosity_ratio)
      print *,"done with tlsa2d"

      wave_speed=zero

      k=0
      do j=1,M
       kr=real(omega1(j))
       ki=aimag(omega1(j))
       omega_real=kr
       omega_imag=ki
       local_wave_speed=omega_real*Uscale/alpha_real

       if (1.eq.0) then

        print *,"**********************************************"
        print *,"the growthrate is: j,omega real, omega imag: ",   &
         j,omega_real,omega_imag

        print *,"dimensional speed: j,c ",j,local_wave_speed
        print *,"**********************************************"
     
       endif

       if (abs(local_wave_speed).le.wave_speed_target) then

        if (abs(local_wave_speed).ge.wave_speed_target*(1.0D-6)) then

         if (omega_imag.lt.zero) then

          do k=1,M
           if (k.ne.j) then 
          
            omega_before_real=real(omega1(k))
            omega_before_imag=aimag(omega1(k))
         
            if (omega_before_real*omega_real.lt.zero) then

             err=(omega_before_imag-omega_imag)/omega_imag
             if (abs(err).lt.1.0D-3) then
              err=(omega_before_real+omega_real)/omega_real
              if (abs(err).lt.1.0D-3) then
               if (abs(local_wave_speed).gt.wave_speed) then
                wave_speed=abs(local_wave_speed)
               endif
              endif
             endif

            endif ! real part opposite signs

           endif ! k<>j
          enddo ! k

         endif ! omega_imag<0

        endif ! computed wave speed > small fraction of predicted wave speed

       endif ! computed wave speed < than predicted wave speed
       
      enddo

! mode is e^{i(alpha z + n theta - omega t)}
! let n=0
! =e^{i (alpha z- omega t) } 
! the imaginary part of alpha is 0, so we have,
! =e^{i alpha (z-omega/alpha t)}
! let c=omega/alpha
! =e^{i alpha (z-ct)}=
! =e^{alpha imag(c)}e^{i alpha (z- real(c) t)}
! note: imag(c) should always be <=0 (no growing waves in 2d)
! dimensionless speed of waves is real(c).

      deallocate(r1)
      deallocate(r2)

      deallocate(omega1)
      deallocate(eigenv)

      return
      end subroutine

      subroutine capillary_wave_speed(wavelen,den1,den2,visc1,visc2, &
       tension,wavespeed,use_lsa)
      IMPLICIT NONE

      REAL_T wavelen,den1,den2,visc1,visc2,tension,wavespeed
      REAL_T omega,k
      INTEGER_T use_lsa
      REAL_T wavespeed_no_viscosity
      REAL_T Lscale,liquid_viscosity,liquid_density
      REAL_T Uscale,density_ratio,viscosity_ratio,Re,We
      REAL_T RGASRWATER


      if ((wavelen.le.zero).or.(den1.le.zero).or. &
          (den2.le.zero).or.(visc1.le.zero).or. &
          (visc2.le.zero).or.(tension.le.zero)) then
       print *,"parameter invalid in capillary wave speed"
       stop
      endif

      k=two*Pi/wavelen
      omega=(k**(1.5))*sqrt(tension/(den1+den2))
      wavespeed=omega/k
      wavespeed_no_viscosity=wavespeed

      if (use_lsa.eq.0) then
       ! do nothing
      else if (use_lsa.eq.1) then
       Lscale=wavelen
       liquid_viscosity=visc1
       liquid_density=den1
       Uscale=liquid_viscosity/(Lscale*liquid_density)
       density_ratio=den2/den1
       viscosity_ratio=visc2/visc1
       Re=(liquid_density*Lscale*Uscale)/liquid_viscosity
       We=(Uscale**2)*Lscale/tension
       RGASRWATER=two
       call get_surface_tension_wave_speed(wavelen,Uscale, &
         Lscale,Re,We,RGASRWATER,wavespeed,density_ratio, &
         viscosity_ratio,wavespeed_no_viscosity)

       print *,"old_speed, new_speed,Lscale ", &
        wavespeed_no_viscosity,wavespeed,Lscale
      else
       print *,"use_lsa invalid"
       stop
      endif

      return
      end subroutine capillary_wave_speed

      subroutine pforce_probtype_flag_init(pforce_flag)
      IMPLICIT NONE

      INTEGER_T pforce_flag


      if ((probtype.eq.90).and.(SDIM.eq.2)) then
       pforce_flag=1
      else
       pforce_flag=0
      endif

      return
      end subroutine

      subroutine pressure_force(x,t,pforce)
      IMPLICIT NONE

      REAL_T x,t,pforce
      REAL_T t_stopforce
      REAL_T h,mu,t_startup,wavelen
      REAL_T factor,factor_test,k
      REAL_T rampfn,mu_tilde,omega_bar
      REAL_T omega,omega2,alpha,rho
      REAL_T C1,D1,coeff1,coeff2,eta1,eta2


      if ((probtype.eq.90).and.(SDIM.eq.2)) then
       h=yblob-probloy
       mu=xblob2
       t_startup=xblob3
       t_stopforce=xblob4
       wavelen=yblob3
       if (wavelen.gt.probhix-problox+VOFTOL) then
        print *,"wavelen too big"
        stop
       else if (wavelen.le.zero) then
        print *,"wavelen too small"
        stop
       else if (probhix-problox.le.zero) then
        print *,"probhix or problox invalid"
        stop
       else
        factor=(probhix-problox)/wavelen
        factor_test=ANINT(factor)  ! round to Nearest INTeger, return real
        if (abs(factor-factor_test).gt.VOFTOL) then
         print *,"wave length must be integer multiple of domain size"
         stop
        endif
       endif
       k=two*Pi/wavelen
 
       if (t.lt.zero) then
        print *,"time invalid in pressure force"
        stop
       else if (t.eq.zero) then
        rampfn=zero
       else if (t.ge.t_startup) then
        rampfn=one 
        if (t_stopforce.gt.zero) then
         if (t.ge.t_stopforce) then
          rampfn=zero
         endif
        else if (t_stopforce.eq.zero) then
         ! do nothing
        else
         print *,"t_stopforce invalid"
         stop
        endif
       else
        rampfn=half*(one+sin(Pi*(t-half*t_startup)/t_startup))
       endif
       mu_tilde=mu/(one+sqrt(one+mu*mu))
       omega_bar=sqrt(abs(gravity)*k*tanh(k*h))
       factor=sqrt(one+mu*mu)/(one+mu_tilde*mu_tilde)
       omega=sqrt(factor)*omega_bar
       omega2=mu_tilde*omega
       alpha=omega_bar**2/(omega**2+omega2**2)
       rho=fort_denconst(1)
 
        ! given mu, one derives omega2 which gives the
        ! growth rate.
        ! if pforce=rho g mu (-eta2 cos + eta1 sin) exp(omega2 t)
        ! then the interface is 
        ! eta=(eta1 cos + eta2 sin) exp(omega2 t)
        ! note that there is no "mu" in the coefficient part of the
        ! expression for eta.
       if (1.eq.0) then
        C1=yblob2
        D1=zblob2
        coeff1=-rho*mu*alpha*(-D1*omega2+C1*omega)
        coeff2=-rho*mu*alpha*(D1*omega+C1*omega2)
       else
        eta1=yblob2
        eta2=zblob2
        coeff1=-eta2*rho*abs(gravity)*mu
        coeff2=eta1*rho*abs(gravity)*mu
       endif 
       rampfn=rampfn*exp(omega2*t)
       coeff1=coeff1*rampfn
       coeff2=coeff2*rampfn
       pforce=coeff1*cos(k*x-omega*t)+ &
              coeff2*sin(k*x-omega*t) 
      else
       print *,"probtype invalid in pressure force"
       stop
      endif

      return
      end subroutine
 
! distance to star with center at origin

      subroutine stardist(x,y,z,radstar,radthick,dist)
      use global_utility_module
      use global_distance_module
      IMPLICIT NONE

      REAL_T, intent(in) :: x,y,z
      REAL_T, intent(out) :: dist
      REAL_T, intent(in) :: radstar,radthick
      REAL_T :: dist1,dist2

      call cubedist(-radstar,radstar,-radstar,radstar, &
                    -radthick,radthick,x,y,z,dist1)
      call cubedist(-radthick,radthick,-radstar,radstar, &
                    -radstar,radstar,x,y,z,dist2)

      if ((dist1.le.zero).and.(dist2.le.zero)) then
       dist=-sqrt(dist1**2+dist2**2)
      else if (dist1.le.zero) then
       dist=dist1
      else if (dist2.le.zero) then
       dist=dist2
      else
       dist=dist1
       if (dist.gt.dist2) then
        dist=dist2
       endif
      endif

      return
      end subroutine

! rotate is in radians, positive angle rotates clockwise.
      subroutine paddlegeom(x,y,z,dist,onlypaddle)
      IMPLICIT NONE

      REAL_T x,y,z,dist
      INTEGER_T onlypaddle


      print *,"obsolete"
      stop

      return
      end subroutine


! u=2s_yz/pi^2
! v=-s_xz/pi^2
! w=-s_xy/pi^2

      subroutine streamdeform3D(s,x,y,z)
      IMPLICIT NONE

      REAL_T s,x,y,z,sx,sy,sz

      sx=sin(Pi*x)
      sy=sin(Pi*y)
      sz=sin(Pi*z)

      s=sx*sx*sy*sy*sz*sz

      return
      end subroutine streamdeform3D

      subroutine deform3duu(u,x,y,z,t,dx)
      IMPLICIT NONE
      REAL_T u,x,y,z,t
      REAL_T dx(SDIM)
      REAL_T aa


      aa=cos(Pi*t/three)
      u=two*(sin(Pi*x)**2)*sin(two*Pi*y)*sin(two*Pi*z)*aa

      return
      end subroutine deform3duu

      subroutine deform3dvv(u,x,y,z,t,dx)
      IMPLICIT NONE
      REAL_T u,x,y,z,t
      REAL_T dx(SDIM)
      REAL_T aa


      aa=cos(Pi*t/three)
      u=-(sin(Pi*y)**2)*sin(two*Pi*x)*sin(two*Pi*z)*aa

      return
      end subroutine deform3dvv

      subroutine deform3dww(u,x,y,z,t,dx)
      IMPLICIT NONE
      REAL_T u,x,y,z,t
      REAL_T dx(SDIM)
      REAL_T aa
      

      aa=cos(Pi*t/three)
      u=-(sin(Pi*z)**2)*sin(two*Pi*x)*sin(two*Pi*y)*aa

      return 
      end subroutine deform3dww





! u = -s_y  
! v = s_x
! u_i+1/2 = -(s_i+1,j+1 + s_i,j+1 - s_i+1,j-1 - s_i,j-1)/(4 dy)
! u_i-1/2 = -(s_i,j+1 + s_i-1,j+1 - s_i,j-1 - s_i-1,j-1)/(4 dy)
! v_j+1/2 = (s_i+1,j+1 + s_i+1,j - s_i-1,j+1 - s_i-1,j)/(4 dx)
! v_j-1/2 = (s_i+1,j + s_i+1,j-1 - s_i-1,j - s_i-1,j-1)/(4 dx)
! div u= -(s_i+1,j+1 + s_i,j+1 - s_i+1,j-1 - s_i,j-1)/(4 dy dx)+
!         (s_i,j+1 + s_i-1,j+1 - s_i,j-1 - s_i-1,j-1)/(4 dy dx)+
!         (s_i+1,j+1 + s_i+1,j - s_i-1,j+1 - s_i-1,j)/(4 dx dy)+
!        -(s_i+1,j + s_i+1,j-1 - s_i-1,j - s_i-1,j-1)/(4 dx dy)=0
! 
      subroutine streamdeform(s,x,y)
      IMPLICIT NONE

      REAL_T s,x,y,sx,sy

      sx=sin(Pi*x)
      sy=sin(Pi*y)
      s=sx*sx*sy*sy

      return
      end subroutine

      subroutine deformuu(u,x,y,t,dx)
      IMPLICIT NONE
      REAL_T u,x,y,t
      REAL_T dx(SDIM)
      REAL_T aa,s1,s2,s3,s4
      REAL_T x1,x2,y1,y2


      if (probtype.ne.29) then
       print *,"probtype should be 29"
       stop
      endif

      if (fort_stop_time.le.zero) then
       print *,"fort_stop_time invalid"
       stop
      endif
      if (period_time.le.zero) then
       print *,"period_time invalid"
       stop
      endif
      aa=cos(Pi*t/period_time)
      if (axis_dir.eq.0) then
       u=sin(four*Pi*(x+half))*sin(four*Pi*(y+half))*aa
      else if ((axis_dir.eq.1).or.(axis_dir.eq.3).or. &
               (axis_dir.eq.4)) then
! when t=T, object is back to circular
! Cervone et al 2009, page 413
! psi=(1/pi)sin^2(pi x)sin^2(pi y)
! u=-psi_y=-sin^2(pi x)sin(2 pi y)=-2 sin^2(pi x)sin(pi y)cos(pi y)

       if ((axis_dir.eq.3).or.(axis_dir.eq.1)) then
        s1=sin(Pi*y)
        s2=cos(Pi*y)
        s3=sin(Pi*x)
        u=-two*s1*s2*s3*s3
       else if (axis_dir.eq.4) then
        x1=x+half*dx(1)
        x2=x-half*dx(1)
        y1=y+dx(2)
        y2=y-dx(2)
        call streamdeform(s1,x1,y1)
        call streamdeform(s2,x1,y2)
        call streamdeform(s3,x2,y1)
        call streamdeform(s4,x2,y2)
        u=-(s1-s2+s3-s4)/(four*dx(2)*Pi)
       else
        print *,"bust"
        stop
       endif

       if ((axis_dir.eq.3).or.(axis_dir.eq.4)) then
        u=u*aa
       endif
      else if (axis_dir.eq.2) then
       s1=sin(Pi*x)
       s2=sin(two*Pi*y)
       u=s1*s1*s2
       if (t.ge.one) then
        u=-u
       endif
      else
       print *,"axis_dir invalid deformuu"
       stop
      endif

      return
      end subroutine deformuu

      subroutine deformvv(v,x,y,t,dx)
      IMPLICIT NONE
      REAL_T v,x,y,t
      REAL_T dx(SDIM)
      REAL_T aa,s1,s2,s3,s4
      REAL_T x1,x2,y1,y2


      if (probtype.ne.29) then
       print *,"probtype should be 29"
       stop
      endif

      if (fort_stop_time.le.zero) then
       print *,"fort_stop_time invalid"
       stop
      endif
      if (period_time.le.zero) then
       print *,"period_time invalid"
       stop
      endif
      aa=cos(Pi*t/period_time)
      if (axis_dir.eq.0) then
       v=cos(four*Pi*(x+half))*cos(four*Pi*(y+half))*aa
      else if ((axis_dir.eq.1).or.(axis_dir.eq.3).or. &
               (axis_dir.eq.4)) then
! when t=T, object is back to circular
! Cervone et al 2009, page 413
! psi=(1/pi)sin^2(pi x)sin^2(pi y)
! v=psi_x=2 sin(pi x)cos(pi x)sin^2 (pi y)

       if ((axis_dir.eq.3).or.(axis_dir.eq.1)) then
        s1=sin(Pi*x)
        s2=cos(Pi*x)
        s3=sin(Pi*y)
        v=two*s1*s2*s3*s3
       else if (axis_dir.eq.4) then
        x1=x+dx(1)
        x2=x-dx(1)
        y1=y+half*dx(2)
        y2=y-half*dx(2)
        call streamdeform(s1,x1,y1)
        call streamdeform(s2,x2,y1)
        call streamdeform(s3,x1,y2)
        call streamdeform(s4,x2,y2)
        v=(s1-s2+s3-s4)/(four*dx(1)*Pi)
       else
        print *,"bust"
        stop
       endif

       if ((axis_dir.eq.3).or.(axis_dir.eq.4)) then
        v=v*aa
       endif
      else if (axis_dir.eq.2) then
       s1=sin(Pi*y)
       s2=sin(two*Pi*x)
       v=-s1*s1*s2
       if (t.ge.one) then
        v=-v
       endif
      else
       print *,"axis_dir invalid deformvv"
       stop
      endif

      return
      end subroutine

! Cervone et al 2009, page 416
      subroutine deformdist(dist,x,y)
      IMPLICIT NONE
      REAL_T dist,x,y

      dist=sqrt( (x-half)**2 + (y-0.75)**2 )-0.15

      return
      end subroutine deformdist

      subroutine zalesakuu(u,x,y,z,time,dx)
      IMPLICIT NONE
      REAL_T u,x,y,z,time
      REAL_T dx(SDIM)


      if (probtype.ne.28) then
       print *,"probtype invalid"
       stop
      endif
      if ((SDIM.eq.2).and.(abs(z-y).gt.VOFTOL)) then
       print *,"abs(z-y) bust"
       stop
      endif 

      if (adv_vel.eq.zero) then
       if (levelrz.eq.0) then
        u=-(Pi/314.0)*(y-50.0)
       else if (levelrz.eq.3) then
        u=zero
       else
        print *,"zalesakuu: levelrz invalid"
        stop
       endif
      else if ((adv_dir.eq.1).or.(adv_dir.eq.SDIM+1)) then
       u=adv_vel
      else if (adv_dir.eq.2) then
       u=zero
      else if (adv_dir.eq.SDIM) then
       u=zero
      else
       print *,"adv_dir invalid zalesakuu (7)"
       stop
      endif

      return
      end subroutine zalesakuu

      subroutine zalesakvv(v,x,y,z,time,dx)
      IMPLICIT NONE
      REAL_T v,x,y,z,time
      REAL_T dx(SDIM)


      if (probtype.ne.28) then
       print *,"probtype invalid"
       stop
      endif
      if ((SDIM.eq.2).and.(abs(z-y).gt.VOFTOL)) then
       print *,"abs(z-y) bust"
       stop
      endif 

      if (adv_vel.eq.zero) then
       if (levelrz.eq.0) then
        v=(Pi/314.0)*(x-50.0)
       else if (levelrz.eq.3) then
        v=(Pi/314.0)*x
       else
        print *,"zalesakvv: levelrz invalid"
        stop
       endif
      else if ((adv_dir.eq.2).or.(adv_dir.eq.SDIM+1)) then
       v=adv_vel
      else if (adv_dir.eq.1) then
       v=zero
      else if ((adv_dir.eq.SDIM).and.(SDIM.eq.3)) then
       v=zero
      else
       print *,"adv_dir invalid zalesakvv (8)"
       stop
      endif

      return
      end subroutine zalesakvv


      subroutine zalesakww(w,x,y,z,time,dx)
      IMPLICIT NONE
      REAL_T w,x,y,z,time
      REAL_T dx(SDIM)


      if (probtype.ne.28) then
       print *,"probtype invalid"
       stop
      endif
      if (levelrz.ne.0) then
       print *,"levelrz invalid zalesakvv"
       stop
      endif
      if ((SDIM.eq.2).and.(abs(z-y).gt.VOFTOL)) then
       print *,"abs(z-y) bust"
       stop
      endif 

      if (adv_vel.eq.zero) then
       w=zero
      else if ((adv_dir.eq.SDIM).or.(adv_dir.eq.SDIM+1)) then
       w=adv_vel
      else if (adv_dir.eq.1) then
       w=zero
      else if (adv_dir.eq.2) then
       w=zero
      else
       print *,"adv_dir invalid zalesakww (9)"
       stop
      endif

      return
      end subroutine zalesakww



      subroutine zalesakdist(dist,xx,yy)
      IMPLICIT NONE
      REAL_T dist,xx,yy,x,y
      REAL_T dist1,dist2

      if (probtype.ne.28) then
       print *,"probtype invalid"
       stop
      endif

      x=xx
      y=yy
      if (axis_dir.eq.0) then
       if (levelrz.eq.0) then
        ! do nothing
       else if (levelrz.eq.3) then
        x=xx*cos(yy)+50.0
        y=xx*sin(yy)+50.0
       else
        print *,"levelrz invalid in zalesakdist"
        stop
       endif
       dist=sqrt((x-50.0)**2+(y-75.0)**2)-15.0
       if ((x.ge.47.5).and.(x.le.52.5)) then
        if (y.le.60.0) then
         if (x.lt.50.0) then
          dist=sqrt( (y-60.0)**2+(x-47.5)**2 )
         else
          dist=sqrt( (y-60.0)**2+(x-52.5)**2 )
         endif
        else if (y.le.85.0) then
         if (x.lt.50.0) then
          dist1=x-47.5
         else
          dist1=52.5-x
         endif
         dist2=85.0-y
         dist=min(dist1,dist2)
        else if ((y.le.90.0).and.(dist.le.zero)) then
         dist=max(dist,85.0-y)
        endif
       else if ((dist.lt.zero).and.(x.lt.47.5)) then
        if (y.le.85.0) then
         dist=max(dist,(x-47.5))
        else
         dist=max(dist,-sqrt( (x-47.5)**2+(y-85.0)**2 ) )
        endif
       else if ((dist.lt.zero).and.(x.gt.52.5)) then
        if (y.le.85.0) then
         dist=max(dist,(52.5-x))
        else
         dist=max(dist,-sqrt( (x-52.5)**2+(y-85.0)**2 ) )
        endif
       endif

      else if (axis_dir.eq.1) then
       if (levelrz.eq.3) then
        dist=x-radblob
       else if (levelrz.eq.0) then
        dist=sqrt((x-xblob)**2+(y-yblob)**2)-radblob
       else
        print *,"levelrz invalid zalesak dist"
        stop
       endif
      else if (axis_dir.eq.2) then
       dist=sqrt((x-50.0)**2+(y-75.0)**2)-15.0
      else
       print *,"axis_dir invalid zalesakdist"
       stop
      endif

       
      return
      end subroutine zalesakdist


      subroutine circleuu(u,x,y,z)
      IMPLICIT NONE
      REAL_T u,x,y,z


      u=zero
      if (adv_dir .eq. 1) then
         u = adv_vel
      else if (adv_dir .eq. 2) then
         u = zero
      else if (adv_dir.eq.SDIM) then
         u = zero
      else if (adv_dir.eq.SDIM+1) then
         u = adv_vel
      endif

      return
      end subroutine circleuu

      subroutine circlevv(v,x,y,z)
      IMPLICIT NONE
      REAL_T v,x,y,z


      v=zero
      if (adv_dir .eq. 2) then
         v = adv_vel
      else if (adv_dir .eq. 1) then
         v = zero
      else if ((adv_dir.eq.SDIM).and.(SDIM.eq.3)) then
         v = zero
      else if (adv_dir.eq.SDIM+1) then
         v = adv_vel
      endif

      return
      end subroutine circlevv

      subroutine circleww(w,x,y,z)
      IMPLICIT NONE
      REAL_T w,x,y,z


      if (SDIM.ne.3) then
       print *,"dimension bust circleww"
       stop
      endif

      w=zero
      if ((adv_dir.eq.3).or.(adv_dir.eq.4)) then
         w = adv_vel
      else
         w = zero
      endif

      return
      end subroutine circleww

      subroutine jettingdist(x,y,dist,HSB,NOD,NPT)

      use global_distance_module

      IMPLICIT NONE
      REAL_T x,y,dist,HSB,NOD,NPT,slope
      REAL_T xx1(maxnumline),yy1(maxnumline)
      REAL_T xx2(maxnumline),yy2(maxnumline)
      INTEGER_T dd(maxnumline),lessflag(maxnumline),numline


      xx1(1)=zero
      xx2(1)=half*NOD
      yy1(1)=HSB+NPT
      yy2(1)=HSB+NPT
      dd(1)=0
      lessflag(1)=0 

      slope = -0.4
      xx1(2)=half*NOD
      yy1(2)=HSB+NPT
      xx2(2)=1.0D+3
      yy2(2)=slope*(xx2(2)-xx1(2))+yy1(2)
      dd(2)=0
      lessflag(2)=0

      numline=2

      call construct(x,y,xx1,yy1,xx2,yy2,dd,lessflag,numline,dist)
      if (y.ge.HSB+NPT) then
       dist=-abs(dist)
      endif

      if ((axis_dir.ge.8).and.(axis_dir.le.10)) then
       print *,"this option disabled"
       stop
      else if ((axis_dir.eq.11).or.(axis_dir.eq.12).or.(axis_dir.eq.13)) then
       call microfabdist(x,y,dist)
      endif
    
      return
      end subroutine


         ! stage=-1 (init)
         ! stage=0 (cooling)
         ! stage=1 (nucleation)
         ! stage=2 (recalesce in progress)
         ! stage=3 (recalesce finished)
         ! stage=4 (frost)
         ! stage=5 (regular freezing starts)
      subroutine check_recalesce_status(im_source,start_freezing)
      IMPLICIT NONE

      INTEGER_T im_source,start_freezing,ibase,stage

      start_freezing=1
      if ((recalesce_material(im_source).eq.1).or. &
          (recalesce_material(im_source).eq.2)) then
       ibase=(im_source-1)*recalesce_num_state
       stage=NINT(recalesce_state_old(ibase+1))
       if (stage.lt.4) then ! start freezing when "frost" starts.
        start_freezing=0
       endif
      else if (recalesce_material(im_source).eq.0) then
       ! do nothing
      else
       print *,"recalesce_material invalid"
       stop
      endif

      return
      end subroutine check_recalesce_status

! -------------------
! CODY ESTEBE
! -----------------
! representitive parameter values:
! values from (Singhal 2002)
! rho_l = 1.0 !density liquid (g/cm^3) (Brusiani: 0.845 g/cm^3 IDEAL fuel)
! rho_v = 0.00002558 ! density gas (g/cm^3)
! sigma = 71.7 !surface tension g/s^2 (Singhal), or can calculate
! mu = 0.00853 dynamic viscosity g/(cm s) 
! (water: 0.00853 at 300K)
! saturation pressure: 35400 g/(cm s^2)
! See also Bicer and Sou, 2016
! P=liquid pressure
! f_v=vapor mass fraction
! mu=liquid viscosity
! sigma=liquid/vapor surface tension.
subroutine RatePhaseChange(P,f_v,saturation_pressure, &
  rho_l,rho_v,mu,sigma,R_e,R_c,D_alpha_D_t)
 implicit none
 REAL_T, intent(in) :: P, f_v !pressure, vapor mass fraction
 REAL_T, intent(in) :: rho_l, rho_v ! density liquid, density vapor
 REAL_T, intent(in) :: sigma ! surface tension
 REAL_T, intent(in) :: mu ! dynamic viscosity of liquid
 REAL_T, intent(in) :: saturation_pressure ! saturation vapor pressure
 REAL_T :: alpha_v
 REAL_T :: k !k: turbulent kinetic energy
 REAL_T :: C_e, C_c !empirical constants
 REAL_T :: I, U, L, Re !initial turbulence intensity %, initial velocity magnitude, dynamic viscosity, length scale, Reynolds number (for obtaining k)
 REAL_T :: rho
 REAL_T :: P_v_Singhal  ! (18) in Singhal 2002
 REAL_T :: saturation_pressure_local
 REAL_T :: n_0,R_b,R_0
 REAL_T :: P_injector
 REAL_T :: R_crit
 REAL_T :: P_crit
 REAL_T :: h_l,h_v,h
 REAL_T :: f_bar
 REAL_T :: a,b,theta_0,psi,theta
 REAL_T :: DfDt
 INTEGER_T :: lowpressure
 REAL_T, intent(out) :: R_e, R_c !evaporation, condensation rates
 REAL_T, intent(out) :: D_alpha_D_t !volume fraction rate

 if ((rho_l.le.zero).or.(rho_v.le.zero)) then
  print *,"rho_l or rho_v invalid"
  stop
 endif
 if ((mu.le.zero).or.(sigma.le.zero)) then
  print *,"mu or sigma invalid"
  stop
 endif
 if ((f_v.lt.zero).or.(f_v.gt.one)) then
  print *,"f_v invalid"
  stop
 endif
 
 !T=300K (Singhal)
 U = 11000.0 !cm/s
 L = 0.03*0.07! length scale cm (7% nozzle diameter) (Brusiani)

 !(https://en.wikipedia.org/wiki/Turbulence_kinetic_energy)
 Re = rho_l*U*L/mu !Reynolds number
 I = 0.16*Re**(-1.0/8.0) !turbulent intensity
 k = (3.0/2.0)*((U*I)**2.0) !turbulent kinetic energy 

  ! note:
  ! rho=rho_l + alpha_v (rho_v - rho_l)
  ! alpha_v=(rho-rho_l)/(rho_v-rho_l)
  ! alpha_v rho_v = f_v rho
  ! rho=(1-alpha_v)rho_l + alpha_v rho_v=
  !     (1-f_v rho/rho_v)rho_l + f_v rho=
  ! rho rho_v =rho_l rho_v - f_v rho rho_l + f_v rho rho_v
  ! rho ((1-f_v)rho_v+f_v rho_l)= rho_l rho_v
  ! rho=rho_l rho_v/((1-f_v)rho_v+f_v rho_l)

 rho=rho_l*rho_v/((one-f_v)*rho_v+f_v*rho_l)
 if (rho.le.zero) then
  print *,"rho.le.zero"
  stop
 endif
 alpha_v=f_v*rho/rho_v ! alpha_v=vapor volume fraction f_v=vapor mass fraction
 if ((alpha_v.lt.zero).or.(alpha_v.gt.one)) then
  print *,"(alpha_v.lt.zero).or.(alpha_v.gt.one)"
  stop
 endif

 saturation_pressure_local=saturation_pressure ! 35400 (g/(cm s^2))
 if (saturation_pressure_local.le.zero) then
  print *,"saturation_pressure_local.le.zero"
  stop
 endif
 P_v_Singhal=saturation_pressure_local+0.39*rho*k/2.0 
 if (P_v_Singhal.le.zero) then
  print *,"P_v_Singhal.le.zero"
  print *,"P_v_Singhal=",P_v_Singhal
  print *,"saturation_pressure_local=",saturation_pressure_local
  print *,"k=",k
  print *,"rho=",rho
  stop
 endif

 if (1.eq.0) then
  print *,"saturation_pressure ",saturation_pressure
  print *,"P_v_Singhal ",P_v_Singhal
  print *,"P ",P
  print *,"rho_l=",rho_l
  print *,"rho_v=",rho_v
  print *,"f_v=",f_v
  print *,"k=",k
  print *,"sigma=",sigma
  stop
 endif
 
 C_e = 0.02
 C_c = 0.01

 !(Singhal 2002), (Brusiani et al 2013), Bicer and Sou 2016
 R_e = zero
 R_c = zero

  ! Singhal 2002
 if (1.eq.1) then

  if (P.lt.P_v_Singhal) then
   R_e = C_e*(sqrt(k)/sigma)*rho_l*rho_v* &
    sqrt((2.0/3.0)*(P_v_Singhal-P)/rho_l)*(one-f_v)
  else if (P.ge.P_v_Singhal) then
   R_c = C_c*(sqrt(k)/sigma)*rho_l*rho_v* &
    sqrt((2.0/3.0)*(P-P_v_Singhal)/rho_l)*f_v
  else
   print *,"P or  P_v_Singhal invalid"
   stop
  endif

 else if (1.eq.0) then ! Bicer and Sou
  n_0=10.0e+8  ! 1/cm^3
  R_b=(3.0*alpha_v/(4.0*Pi*(one-alpha_v)*n_0))**(1.0/3.0)
  R_0=1.0e-4
  P_injector=0.22e+7 ! gm/(cm s^2)  dyne/cm^2=gm cm/s^2  / cm^2
  if (P_injector.le.saturation_pressure_local) then
   print *,"P_injector.le.saturation_pressure_local"
   stop
  endif
  R_crit=R_0*sqrt(3.0*(R_0*(P_injector-saturation_pressure_local)/ &
         (2.0*sigma)+1.0))
  P_crit = saturation_pressure_local-(4.0*sigma)/(3.0*R_crit)
  if (P.lt.P_crit) then
   R_e = C_e*3.0*(rho_l*rho_v/rho)*alpha_v*(1.0-alpha_v)/R_b* &
         sqrt(2.0*abs(saturation_pressure_local-P)/(3.0*rho_l))
  else if (P.gt.saturation_pressure_local) then
   R_c = C_c*3.0*(rho_l*rho_v/rho)*alpha_v*(1.0-alpha_v)/R_b* &
         sqrt(1.27*abs(saturation_pressure_local-P)/rho_l)
  else if ((P.ge.P_crit).and.(P.le.saturation_pressure_local)) then
   R_e=zero
   R_c=zero
  else
   print *,"P, P_crit, or P_saturation_pressure_local invalid"
   stop
  endif

 else if (1.eq.0) then ! HRM
  n_0=10.0e+8  ! 1/cm^3
  R_b=(3.0*alpha_v/(4.0*Pi*(one-alpha_v)*n_0))**(1.0/3.0)
  R_0=1.0e-4
  P_injector=0.22e+7 ! gm/(cm s^2)  dyne/cm^2=gm cm/s^2  / cm^2
  if (P_injector.le.saturation_pressure_local) then
   print *,"P_injector.le.saturation_pressure_local"
   stop
  endif
  R_crit=R_0*sqrt(3.0*(R_0*(P_injector-saturation_pressure_local)/ &
         (2.0*sigma)+1.0))
  P_crit = saturation_pressure_local-(4.0*sigma)/(3.0*R_crit)
  h_l=P_injector/rho_l
  h_v=P_crit/rho_v
  h=P/rho
  if ((h.le.h_l).and.(h_v.lt.h_l)) then
   f_bar=(h_l-h)/(h_l-h_v)
  else
   print *,"h>h_l or h_v >= h_l"
   stop
  endif

  lowpressure = 0 !flag low or high pressure (below 10bar)
  if (lowpressure.eq.1) then
   a=-0.257
   b=-2.24
   theta_0=6.51e-4
   psi = abs((saturation_pressure_local-P)/saturation_pressure_local)
   theta = theta_0*(alpha_v**a)*(psi**b)
  else if (lowpressure.eq.0) then
   a=-0.54
   b=-1.76
   theta_0=6.51e-4
   psi = abs((saturation_pressure_local-P)/ &
             (P_crit-saturation_pressure_local))
   theta = theta_0*(alpha_v**a)*(psi**b)
  else
   print *,"lowpressure invalid"
   stop
  endif
   ! DfDt = rate of change of the vapor mass fraction
   ! rho DfDt = volume D (rho f)/Dt = rate of change of the vapor mass
  DfDt = (f_bar-f_v)/theta
   ! the effective velocity (assuming unidirectional normal) is:
   ! velocity=dx * D_alpha_D_t
  D_alpha_D_t=rho*DfDt/rho_v
  if (DfDt.eq.zero) then
   ! do nothing
  else if (DfDt.gt.zero) then
   R_e=DfDt*rho
  else if (DfDt.lt.zero) then
   R_c=DfDt*rho
  else
   print *,"DfDt invalid"
   stop
  endif

 else
  print *,"option does not exist"
  stop
 endif

 if ((R_e.lt.zero).or.(R_c.lt.zero)) then
  print *,"(R_e.lt.zero).or.(R_c.lt.zero)"
  stop
 endif
 
end subroutine RatePhaseChange


       ! vapor_mass_source<0 if condensation
       ! vapor_mass_source>0 if evaporation
      subroutine get_vapor_mass_source( &
       liq_viscosity, &
       liq_vap_tension, &
       total_density, &
       liquid_density,vapor_density, &
       liquid_pressure, &
       saturation_pressure, &
       vapor_mass_frac, &
       vapor_vol_frac, &
       vapor_mass_source, &
       vapor_vfrac_source)
      IMPLICIT NONE

      REAL_T, intent(in) :: liq_viscosity
      REAL_T, intent(in) :: liq_vap_tension
      REAL_T, intent(in) :: total_density
      REAL_T, intent(in) :: liquid_density,vapor_density
      REAL_T, intent(in) :: liquid_pressure,saturation_pressure
      REAL_T, intent(in) :: vapor_mass_frac
      REAL_T, intent(in) :: vapor_vol_frac
      REAL_T, intent(out) :: vapor_mass_source
      REAL_T, intent(out) :: vapor_vfrac_source

      REAL_T R_e,R_c

      if ((liquid_density.gt.zero).and.(vapor_density.gt.zero)) then
       ! do nothing
      else
       print *,"liquid_density or vapor_density invalid"
       stop
      endif
      if (liq_vap_tension.ge.zero) then
       ! do nothing
      else
       print *,"liq_vap_tension invalid"
       stop
      endif

      if ((vapor_mass_frac.ge.zero).and.(vapor_mass_frac.le.one)) then

       if ((vapor_vol_frac.ge.zero).and.(vapor_vol_frac.le.one)) then

         ! R_e>=0  R_c>=0
        call RatePhaseChange( &
         liquid_pressure, &
         vapor_mass_frac, &
         saturation_pressure, &
         liquid_density,vapor_density, &
         liq_viscosity,liq_vap_tension, &
         R_e,R_c, &
         vapor_vfrac_source)

        if ((R_e.ge.zero).and.(R_c.ge.zero)) then
         vapor_mass_source=R_e-R_c
        else
         print *,"R_e or R_c invalid"
         stop
        endif 

       else
        print *,"vapor_vol_frac invalid"
        stop
       endif
 
      else
       print *,"vapor_mass_frac invalid"
       stop
      endif

      return
      end subroutine get_vapor_mass_source

! -------------------
! end CODY ESTEBE
! -----------------


      subroutine get_vel_phasechange_NUCLEATE( &
                      nucleate_in,nucleate_out)
      use global_utility_module
      use geometry_intersect_module
      use MOF_routines_module

      IMPLICIT NONE

      type(nucleation_parm_type_input), intent(in) :: nucleate_in
      type(nucleation_parm_type_inout), intent(inout) :: nucleate_out
      INTEGER_T nmat
      INTEGER_T nstate_test
      REAL_T VOFTOL_NUCLEATE
      INTEGER_T i,j,k
      INTEGER_T denbase
      INTEGER_T mofbase
      INTEGER_T vofcomp
      INTEGER_T local_freezing_model
      INTEGER_T im_local
      INTEGER_T im_dest
      INTEGER_T im_source
      INTEGER_T im_vapor
      INTEGER_T im_liquid
      REAL_T LL
      INTEGER_T make_seed ! 0 no seed, 1 yes to seed
      REAL_T xsten(-3:3,SDIM)
      INTEGER_T nhalf
      REAL_T prev_time,cur_time,dt
      REAL_T saturation_pres
      REAL_T total_density
      REAL_T test_pressure
      REAL_T test_den
      REAL_T vapor_density
      REAL_T test_temp
      REAL_T test_visc
      REAL_T vapor_vol_frac
      REAL_T vapor_mass_frac
      REAL_T liquid_mass_frac
      REAL_T vapor_mass_source
      REAL_T vapor_vfrac_source
      INTEGER_T nmax
      INTEGER_T use_ls_data
      INTEGER_T mof_verbose
      INTEGER_T continuous_mof
      INTEGER_T tessellate
      INTEGER_T ibasesrc,ibasedst
      INTEGER_T ibase_raw,ibase_recon
      REAL_T mofdata(num_materials*ngeom_recon)
      REAL_T :: LS_stencil(D_DECL(-1:1,-1:1,-1:1),num_materials)
      REAL_T :: multi_centroidA(num_materials,SDIM)
      REAL_T :: volcell
      REAL_T :: cencell(SDIM)
      INTEGER_T :: dir
      REAL_T cen_src(SDIM)
      REAL_T cen_dst(SDIM)
      REAL_T vfluid_sum
      REAL_T VOF_source,VOF_dest

      nhalf=3
      nmax=POLYGON_LIST_MAX 

      call checkbound(nucleate_in%fablo,nucleate_in%fabhi, &
        DIMS(nucleate_in%EOS), &
        1,-1,1301)
      call checkbound(nucleate_in%fablo,nucleate_in%fabhi, &
        DIMS(nucleate_in%pres), &
        1,-1,1301)
      call checkbound(nucleate_in%fablo,nucleate_in%fabhi, &
        DIMS(nucleate_in%pres_eos), &
        1,-1,1301)
      call checkbound(nucleate_in%fablo,nucleate_in%fabhi, &
        DIMS(nucleate_in%LSnew), &
        1,-1,1301)
      call checkbound(nucleate_in%fablo,nucleate_in%fabhi, &
        DIMS(nucleate_in%Snew), &
        1,-1,1301)
      nmat=nucleate_in%nmat

      nstate_test=num_materials_vel*(SDIM+1)+ &
              nmat*(num_state_material+ngeom_raw)+1
      if (nucleate_in%nstate.eq.nstate_test) then
       ! do nothing
      else
       print *,"nstate invalid"
       stop
      endif
      if (n_sites.gt.0) then
       if (nucleate_in%nucleate_pos_size.ne.n_sites*4) then
        print *,"nucleate_pos_size invalid"
        stop
       endif
      endif

       ! redistancing for phase change sees materials in which
       ! F>VOFTOL_REDIST
      VOFTOL_NUCLEATE=VOFTOL_REDIST*two

      denbase=num_materials_vel*(SDIM+1)
      mofbase=denbase+nmat*num_state_material
      im_dest=nucleate_in%im_dest
      im_source=nucleate_in%im_source
      vofcomp=mofbase+(im_dest-1)*ngeom_raw+1

      local_freezing_model=nucleate_in%local_freezing_model

      i=nucleate_in%i
      j=nucleate_in%j
      k=nucleate_in%k
      if (nucleate_out%Snew(D_DECL(i,j,k),vofcomp).ge.VOFTOL_NUCLEATE) then
       ! do nothing
      else if (nucleate_out%Snew(D_DECL(i,j,k),vofcomp).le.VOFTOL_NUCLEATE) then

       LL=nucleate_in%LL
       make_seed=0

       call gridsten_level(xsten,i,j,k,nucleate_in%level,nhalf)

       if (local_freezing_model.eq.0) then

        if (is_in_probtype_list().eq.1) then
         call SUB_nucleation(nucleate_in,xsten,nhalf,make_seed)
        else
         ! do nothing
        endif
        
       else if (local_freezing_model.eq.7) then ! cavitation
        prev_time=nucleate_in%prev_time
        cur_time=nucleate_in%cur_time
        dt=nucleate_in%dt
        if (prev_time.gt.zero) then
         if (cur_time.gt.prev_time) then
          if (dt.gt.zero) then
           test_pressure=nucleate_in%pres_eos(D_DECL(i,j,k))
           if (LL.gt.zero) then
            im_vapor=im_dest ! evaporation
            im_liquid=im_source
            vapor_mass_frac=zero
            liquid_mass_frac=one
            vapor_density=fort_denconst(im_vapor)
            test_den=nucleate_in%EOS(D_DECL(i,j,k), &
                   (im_liquid-1)*num_state_material+1)
            test_temp=nucleate_in%EOS(D_DECL(i,j,k), &
                   (im_liquid-1)*num_state_material+2)
           else if (LL.lt.zero) then
            im_vapor=im_source ! condensation
            im_liquid=im_dest
            vapor_mass_frac=one
            liquid_mass_frac=zero
            vapor_density=nucleate_in%EOS(D_DECL(i,j,k), &
                   (im_vapor-1)*num_state_material+1)
            test_den=fort_denconst(im_liquid)
            test_temp=nucleate_in%EOS(D_DECL(i,j,k), &
                   (im_vapor-1)*num_state_material+2)
           else
            print *,"LL invalid"
            stop
           endif
           saturation_pres=nucleate_in%cavitation_pressure(im_liquid)
           if (vapor_density.gt.zero) then
            ! let Y=vapor_mass_frac dV=vapor density dL=liquid den
            ! alpha*dV=Y*d
            ! d=alpha dV + (1-alpha) dL=alpha(dV-dL)+dL=
            ! Y*d(dV-dL)/dV+dL
            ! d(1-Y(dV-dL)/dV)=dL
            ! d=dL dV/(dV-Y(dV-dL))=dL dV/((1-Y)dV+Y dL)
            ! 
            total_density=test_den*vapor_density/ &
               (vapor_mass_frac*test_den+liquid_mass_frac*vapor_density)
            vapor_vol_frac=total_density*vapor_mass_frac/vapor_density

            if ((vapor_vol_frac.ge.zero).and. &
                (vapor_vol_frac.le.one)) then

             if (nucleate_in%cavitation_tension(im_liquid).ge.zero) then
              test_visc=get_user_viscconst(im_liquid,test_den,test_temp)

              if (test_visc.ge.zero) then
               call get_vapor_mass_source( &
                 test_visc, &
                 nucleate_in%cavitation_tension(im_liquid), &
                 total_density, &
                 test_den,vapor_density, &
                 test_pressure, &
                 saturation_pres, &
                 vapor_mass_frac, &
                 vapor_vol_frac, &
                 vapor_mass_source, &
                 vapor_vfrac_source)
              else
               print *,"test_visc invalid"
               stop
              endif

              if (vapor_vfrac_source*LL.gt.zero) then
               make_seed=1
              else if (vapor_vfrac_source*LL.le.zero) then
               ! do nothing
              else
               print *,"vapor_vfrac_source invalid"
               stop
              endif
             else
              print *,"cavitation_tension invalid"
              stop
             endif
            else
             print *,"vapor_vol_frac invalid"
             stop
            endif
           else
            print *,"vapor_density invalid"
            stop
           endif
          else
           print *,"dt invalid"
           stop
          endif
         else
          print *,"cur_time invalid"
          stop
         endif
        else if (prev_time.eq.zero) then
         ! do nothing
        else
         print *,"prev_time invalid"
         stop
        endif
       else if ((local_freezing_model.eq.1).or. & !source term
                (local_freezing_model.eq.2).or. & !Hydrate
                (local_freezing_model.eq.3).or. & !wildfire
                (local_freezing_model.eq.4).or. & !Tanasawa or Schrage
                (local_freezing_model.eq.5).or. & !fully saturated evap/cond
                (local_freezing_model.eq.6)) then !Palmore/Desjardins
        ! do nothing
       else
        print *,"local_freezing_model invalid"
        stop
       endif

       if (make_seed.eq.1) then
        ! create unidirectional seed
        ! initialize volume fraction, level set function, centroid,
        ! density, temperature, and vapor mass fraction.
        use_ls_data=0
        mof_verbose=0
        continuous_mof=0
        tessellate=0

        do im_local=1,nmat
         ibase_raw=(im_local-1)*ngeom_raw+1
         ibase_recon=(im_local-1)*ngeom_recon+1
         do dir=0,SDIM
          mofdata(ibase_recon+dir)= &
            nucleate_out%Snew(D_DECL(i,j,k),mofbase+ibase_raw+dir)
         enddo
          ! order=0
         mofdata(ibase_recon+SDIM+1)=zero
         do dir=SDIM+2,ngeom_recon-1
          mofdata(ibase_recon+dir)=zero  ! slope, intercept
         enddo
        enddo  ! im_local=1..nmat

        call make_vfrac_sum_ok_base(tessellate,mofdata,nmat,SDIM,204)

        call multimaterial_MOF( &
         nucleate_in%bfact, &
         nucleate_in%dx, &
         xsten,nhalf, &
         mof_verbose, &
         use_ls_data, &
         LS_stencil, &
         geom_xtetlist(1,1,1,nucleate_in%tid+1), &
         geom_xtetlist(1,1,1,nucleate_in%tid+1), &
         nmax, &
         nmax, &
         mofdata, &
         multi_centroidA, &
         continuous_mof, &
         nmat,SDIM,4)

        call multi_get_volume_tessellate( &
         nucleate_in%bfact, &
         nucleate_in%dx, &
         xsten,nhalf, &
         mofdata, &
         geom_xtetlist(1,1,1,nucleate_in%tid+1), &
         nmax, &
         nmax, &
         nmat, &
         SDIM, &
         4)

        call CISBOX( &
         xsten,nhalf, &
         nucleate_in%xlo, &
         nucleate_in%dx, &
         i,j,k, &
         nucleate_in%bfact, &
         nucleate_in%level, &
         volcell,cencell,SDIM)
 
        ibasesrc=(im_source-1)*ngeom_recon+1

        if (mofdata(ibasesrc).gt.VOFTOL_NUCLEATE) then

         nucleate_out%LSnew(D_DECL(i,j,k),im_source)=-nucleate_in%dx(1)
         nucleate_out%LSnew(D_DECL(i,j,k),im_dest)=nucleate_in%dx(1)
         do dir=1,SDIM
          nucleate_out%LSnew(D_DECL(i,j,k),nmat+SDIM*(im_source-1)+dir)=zero
          nucleate_out%LSnew(D_DECL(i,j,k),nmat+SDIM*(im_dest-1)+dir)=zero
         enddo

         vfluid_sum=zero
         do im_local=1,nmat
          if (is_rigid(nmat,im_local).eq.0) then
           ibase_raw=(im_local-1)*ngeom_raw+1
           vfluid_sum=vfluid_sum+ &
            nucleate_out%Snew(D_DECL(i,j,k),mofbase+ibase_raw)
          else if (is_rigid(nmat,im_local).eq.1) then
           ! do nothing
          else
           print *,"is_rigid(nmat,im_local) invalid"
           stop
          endif
         enddo ! im_local=1..nmat
         if (vfluid_sum.gt.VOFTOL_NUCLEATE) then
          ibasesrc=(im_source-1)*ngeom_raw+1
          VOF_source=nucleate_out%Snew(D_DECL(i,j,k),mofbase+ibasesrc)
          if (VOF_source.gt.VOFTOL_NUCLEATE) then
           nucleate_out%Snew(D_DECL(i,j,k),mofbase+ibasesrc)=zero
           ibasedst=(im_dest-1)*ngeom_raw+1
           VOF_dest=nucleate_out%Snew(D_DECL(i,j,k),mofbase+ibasedst)
           nucleate_out%Snew(D_DECL(i,j,k),mofbase+ibasedst)= &
              VOF_dest+VOF_source
           if (VOF_dest+VOF_source.gt.zero) then
            do dir=1,SDIM
             cen_dst(dir)=nucleate_out%Snew(D_DECL(i,j,k),mofbase+ibasedst+dir)
             cen_src(dir)=nucleate_out%Snew(D_DECL(i,j,k),mofbase+ibasesrc+dir)
             nucleate_out%Snew(D_DECL(i,j,k),mofbase+ibasedst+dir)= &
               (VOF_dest*cen_dst(dir)+VOF_source*cen_src(dir))/ &
               (VOF_dest+VOF_source)
            enddo ! dir=1..sdim
           else
            print *,"VOF_dest+VOF_source invalid"
            stop
           endif
          else
           print *,"VOF_source invalid"
           stop
          endif
         else
          print *,"vfluid_sum invalid"
          stop
         endif
        else
         print *,"mofdata(ibasesrc) invalid"
         stop
        endif
           
       else if (make_seed.eq.0) then
        ! do nothing
       else
        print *,"make_seed invalid"
        stop
       endif
      else
       print *,"Snew(vofcomp) invalid"
       stop
      endif

      end subroutine get_vel_phasechange_NUCLEATE

       ! expansion_fact=
       ! either: 1-den_dst/den_src (distribute_from_target==0)
       !     or: 1-den_src/den_dst (distribute_from_target==1)
      subroutine get_vel_phasechange( &
       for_estdt, &
       xI, &
       ispec, &
       molar_mass, &
       species_molar_mass, &
       local_freezing_model, &
       local_Tanasawa_or_Schrage, & ! 1=Tanasawa  2=Schrage
       species_evaporation_density, &
       distribute_from_target, &
       vel, &
       densrc_I,dendst_I, & ! replaced with vapor_den if freezing_model=5,6
       densrc_probe,dendst_probe, &
       ksrc,kdst, &
       Tsrc_probe,Tdst_probe, &
       Tsat, &
       Tsrc_INT,Tdst_INT, &
       LL, &
       source_perim_factor, &
       dest_perim_factor, &
       microlayer_substrate_source, &
       microlayer_angle_source, &
       microlayer_size_source, &
       macrolayer_size_source, &
       microlayer_substrate_dest, &
       microlayer_angle_dest, &
       microlayer_size_dest, &
       macrolayer_size_dest, &
       dxprobe_source, &
       dxprobe_dest, &
       im_source,im_dest, &
       time,dt, &
       alpha, &
       beta, &
       expansion_fact, &
       K_f, &
       Cmethane_in_hydrate, &
       C_w0, &
       PHYDWATER, &
       VOFsrc,VOFdst)
      use hydrateReactor_module
      use global_utility_module

      IMPLICIT NONE

      INTEGER_T, intent(in) :: for_estdt
      REAL_T, intent(in) :: xI(SDIM)
      INTEGER_T, intent(in) :: local_freezing_model
      INTEGER_T, intent(in) :: local_Tanasawa_or_Schrage !1=Tanasawa 2=Schrage
       ! MEHDI EVAPORATION
      INTEGER_T, intent(in) :: ispec ! 0 if no species  1..num_species_var
       ! MEHDI EVAPORATION
      REAL_T, intent(in) :: molar_mass(num_materials)
      REAL_T, intent(in) :: species_molar_mass(num_species_var+1)
      REAL_T, intent(in) :: species_evaporation_density
      INTEGER_T, intent(in) :: distribute_from_target
       ! MEHDI EVAPORATION  im_source,im_dest = 1..nmat
      INTEGER_T, intent(in) :: im_source,im_dest
      INTEGER_T :: start_freezing
      INTEGER_T :: nmat
      REAL_T, intent(out) :: vel
      REAL_T, intent(in) :: densrc_I,dendst_I
      REAL_T, intent(in) :: densrc_probe,dendst_probe
      REAL_T, intent(in) :: time,dt,alpha,beta
      REAL_T, intent(in) :: expansion_fact
      REAL_T, intent(in) :: ksrc,kdst
      REAL_T, intent(in) :: Tsrc_probe,Tdst_probe,Tsat
      REAL_T, intent(in) :: LL
      REAL_T, intent(in) :: source_perim_factor,dest_perim_factor
      INTEGER_T, intent(in) :: microlayer_substrate_source
      INTEGER_T, intent(in) :: microlayer_substrate_dest
      REAL_T, intent(in) :: microlayer_angle_source,microlayer_angle_dest
      REAL_T, intent(in) :: microlayer_size_source,microlayer_size_dest
      REAL_T, intent(in) :: macrolayer_size_source,macrolayer_size_dest
      REAL_T, intent(in) :: dxprobe_source
      REAL_T, intent(in) :: dxprobe_dest
      REAL_T, intent(in) :: Tsrc_INT,Tdst_INT
      REAL_T, intent(in) :: K_f
      REAL_T, intent(in) :: Cmethane_in_hydrate,C_w0,PHYDWATER
      REAL_T, intent(in) :: VOFsrc,VOFdst

      REAL_T DTsrc,DTdst
      REAL_T velsrc,veldst,velsum
      REAL_T velsrc_micro,veldst_micro
      REAL_T psi_upper,psi_lower,micro_slope
      REAL_T gamma_tanasawa
      REAL_T fluid_molar_mass_Tanasawa ! Tanasawa model
      REAL_T universal_gas
      REAL_T gamma_schrage
      REAL_T Tsrc_ref,psrc_ref
      REAL_T psrc_sat,densrc_sat
      INTEGER_T verb_hydrate

      nmat=num_materials
      if ((im_source.lt.1).or.(im_source.gt.nmat)) then
       print *,"im_source invalid"
       stop
      endif
      if ((im_dest.lt.1).or.(im_dest.gt.nmat)) then
       print *,"im_dest invalid"
       stop
      endif
      if ((densrc_I.le.zero).or.(dendst_I.le.zero)) then
       print *,"density must be positive"
       stop
      endif
      if ((densrc_probe.le.zero).or.(dendst_probe.le.zero)) then
       print *,"density must be positive"
       stop
      endif
      if ((distribute_from_target.ne.0).and. &
          (distribute_from_target.ne.1)) then
       print *,"distribute_from_target invalid"
       stop
      endif
      if ((local_freezing_model.ge.0).and. &
          (local_freezing_model.le.7)) then
       ! do nothing
      else
       print *,"local_freezing_model invalid"
       stop
      endif
      if ((local_freezing_model.eq.2).and. &
          (num_species_var.ne.1)) then
       print *,"must define species var if hydrate model"
       stop
      endif

      if ((VOFsrc.lt.-VOFTOL).or. &
          (VOFdst.lt.-VOFTOL).or. &
          (VOFsrc.gt.one+VOFTOL).or. &
          (VOFdst.gt.one+VOFTOL)) then
       print *,"VOFsrc or VOFdst invalid"
       stop
      endif

      if ((Tsrc_probe.lt.zero).or.(Tdst_probe.lt.zero).or. &
          (Tsat.lt.zero).or.(Tsrc_INT.lt.zero).or. &
          (Tdst_INT.lt.zero)) then
       print *,"temperature cannot be negative in get_vel_phasechange"
       print *,"Tsrc_probe,Tdst_probe,Tsat,TsrcI,TdstI ", &
         Tsrc_probe, Tdst_probe, Tsat, Tsrc_INT, Tdst_INT
       print *,"for_estdt= ",for_estdt
       stop
      endif
      if (dt.le.zero) then
       print *,"dt invalid"
       stop
      endif
      if (time.lt.zero) then
       print *,"time invalid"
       stop
      endif
      if (alpha.lt.zero) then
       print *,"alpha invalid"
       stop
      endif
      if (beta.lt.zero) then
       print *,"beta invalid"
       stop
      endif
       ! expansion_fact=
       ! either: 1-den_dst/den_src
       !     or: 1-den_src/den_dst
      if (expansion_fact.ge.one) then
       print *,"expansion_fact invalid get_vel_phasechange:",expansion_fact
       stop
      endif
      if ((for_estdt.ne.0).and.(for_estdt.ne.1)) then
       print *,"for_estdt invalid"
       stop
      endif
      if ((source_perim_factor.le.zero).or. &
          (source_perim_factor.gt.one).or. &
          (dest_perim_factor.le.zero).or. &
          (dest_perim_factor.gt.one)) then
       print *,"source_perim_factor or dest_perim_factor invalid"
       stop
      endif

      call check_recalesce_status(im_source,start_freezing)

      if (start_freezing.eq.0) then
       vel=zero
      else if (start_freezing.eq.1) then 
       if ((probtype.eq.801).and.(vinletgas.gt.zero)) then
         ! in: get_vel_phasechange
         ! fixed rate of phase change (sanity check)
        vel=vinletgas  ! MDOT/rho_src

        ! local_freezing_model=0 (sharp interface stefan model)
        ! local_freezing_model=1 (source term model)
        ! local_freezing_model=2 (hydrate model)
        ! local_freezing_model=3 (wildfire)
        ! local_freezing_model=4 (source term model-Tanasawa/Schrage Model)
        ! local_freezing_model=5 (Stefan model evaporation/condensation)
        ! local_freezing_model=6 (Palmore and Desjardins)
        ! local_freezing_model=7 (Cavitation)
       else if ((local_freezing_model.eq.0).or. &
                (local_freezing_model.eq.1).or. &
                (local_freezing_model.eq.5).or. &
                (local_freezing_model.eq.6)) then
         ! LL<0 if freezing

        if ((LL.eq.zero).or. &
            (dxprobe_source.le.zero).or. &
            (dxprobe_dest.le.zero)) then
         print *,"LL, dxprobe_source, or dxprobe_dest invalid"
         stop
        endif

         ! local_freezing_model==5, if Tsrc_probe > Tsat then
         ! evaporation will occur.  (source==water destination==vapor within
         !                           the air)
         ! if local_freezing_model==5, and Tsrc_probe < Tsat then
         !  velsrc<0 => then the "rate of mass transfer is negative" which
         ! is disallowed; i.e. no evaporation occurs.
        ! Tsrc_probe is the probe temperature in the source
        DTsrc=Tsrc_probe-Tsat 
        ! Tdst_probe is the probe temperature in the destination
        DTdst=Tdst_probe-Tsat  
        velsrc=ksrc*DTsrc/(LL*dxprobe_source)
        veldst=kdst*DTdst/(LL*dxprobe_dest)

        if (local_freezing_model.eq.0) then

         velsrc_micro=zero
         veldst_micro=zero
       
         if (microlayer_size_source.gt.zero) then
          if ((microlayer_substrate_source.ge.1).and. &
              (microlayer_substrate_source.le.nmat)) then
           if (is_rigid(nmat,microlayer_substrate_source).ne.1) then
            print *,"is_rigid(nmat,microlayer_substrate_source).ne.1"
            stop
           endif
           if (macrolayer_size_source.gt.microlayer_size_source) then
            if ((microlayer_angle_source.gt.zero).and. &
                (microlayer_angle_source.lt.Pi)) then
             micro_slope=tan(half*microlayer_angle_source)
             psi_upper=half*macrolayer_size_source/micro_slope
             psi_lower=half*microlayer_size_source/micro_slope
             velsrc_micro=( &
              half*(Tsat+fort_tempconst(microlayer_substrate_source))-Tsat)* &
              log(psi_upper/psi_lower)* &
              sqrt(one+micro_slope**2)/ &
              (micro_slope*(psi_upper-psi_lower))
             velsrc_micro=source_perim_factor*abs(ksrc*velsrc_micro/LL)
             velsrc=velsrc_micro
            else
             print *,"microlayer_angle_source invalid"
             stop
            endif
           else
            print *,"macrolayer_size_source invalid"
            stop
           endif
          else if (microlayer_substrate_source.eq.0) then
           ! do nothing
          else
           print *,"microlayer_substrate_source invalid"
           stop
          endif
         else if (microlayer_size_source.eq.zero) then
          ! do nothing
         else
          print *,"microlayer_size_source invalid"
          stop
         endif
  
         if (microlayer_size_dest.gt.zero) then
          if ((microlayer_substrate_dest.ge.1).and. &
              (microlayer_substrate_dest.le.nmat)) then
           if (is_rigid(nmat,microlayer_substrate_dest).ne.1) then
            print *,"is_rigid(nmat,microlayer_substrate_dest).ne.1"
            stop
           endif
           if (macrolayer_size_dest.gt.microlayer_size_dest) then
            if ((microlayer_angle_dest.gt.zero).and. &
                (microlayer_angle_dest.lt.Pi)) then
             micro_slope=tan(half*microlayer_angle_dest)
             psi_upper=half*macrolayer_size_dest/micro_slope
             psi_lower=half*microlayer_size_dest/micro_slope
             veldst_micro=( &
              half*(Tsat+fort_tempconst(microlayer_substrate_dest))-Tsat)* &
              log(psi_upper/psi_lower)* &
              sqrt(one+micro_slope**2)/ &
              (micro_slope*(psi_upper-psi_lower))
             veldst_micro=dest_perim_factor*abs(kdst*veldst_micro/LL)
             veldst=veldst_micro
            else
             print *,"microlayer_angle_dest invalid"
             stop
            endif
           else
            print *,"macrolayer_size_dest invalid"
            stop
           endif
          else if (microlayer_substrate_dest.eq.0) then
           ! do nothing
          else
           print *,"microlayer_substrate_dest invalid"
           stop
          endif
         else if (microlayer_size_dest.eq.zero) then
          ! do nothing
         else
          print *,"microlayer_size_dest invalid"
          stop
         endif

        else if (local_freezing_model.eq.1) then
         ! do nothing

         ! our evaporation model corresponds to "boiling"
         ! in which the temperature gradient is assumed constant
         ! in the vapor and the vapor is captured instead of tracked.
         ! The saturation temperature is currently constant, but later
         ! on, the saturation temperature should make use of the
         ! Clausius Clapeyron condition.
         ! 
         ! Interface Temperature used for solving the heat equation:
         !  1. advection (rho Y)_t + div (rho u Y) = div (rho D grad Y)
         !      rho_t Y + rho Y_t + div (rho u) Y + rho u grad Y =
         !      div (rho D grad Y)
         !      Y_t + u dot grad Y = div (rho D grad Y)/rho 
         !  2. rate of mass transfer, input: probe Temperature, mass fraction,
         !     density; output: rate of mass transfer, interface temperature,
         !     interface species
         !  3. diffusion species mass fraction, and temperature
         !  Supermesh for Temperature and species is good.
         !  Supermesh for viscous solver and pressure projection???
        else if (local_freezing_model.eq.5) then

         if (LL.gt.zero) then ! evaporation
          veldst=zero ! ignore temperature gradient in the air.
         else if (LL.lt.zero) then ! condensation
          velsrc=zero
         else if (LL.eq.zero) then
          print *,"LL invalid"
          stop
         else
          print *,"LL invalid"
          stop
         endif 
        else if (local_freezing_model.eq.6) then ! Palmore and Desjardins
         ! do nothing
        else if (local_freezing_model.eq.7) then ! cavitation
         print *,"cavitation model in development"
         stop
        else
         print *,"local_freezing_model invalid"
         stop
        endif

        if (distribute_from_target.eq.0) then ! default
         velsrc=velsrc/densrc_I
         veldst=veldst/densrc_I
        else if (distribute_from_target.eq.1) then
         velsrc=velsrc/dendst_I
         veldst=veldst/dendst_I
        else
         print *,"distribute_from_target invalid"
         stop
        endif

        if (for_estdt.eq.1) then
         velsrc=abs(velsrc)
         veldst=abs(veldst)
         velsrc=max(velsrc,velsrc/(one-expansion_fact))
         veldst=max(veldst,veldst/(one-expansion_fact))
        else if (for_estdt.eq.0) then
         ! do nothing
        else
         print *,"for_estdt invalid"
         stop
        endif

        velsum=velsrc+veldst
        if (velsum.gt.zero) then
         ! do nothing
        else if (velsum.le.zero) then
         velsum=zero
        else
         print *,"velsum invalid in get_vel_phasechange"
         print *,"velsum=",velsum
         print *,"velsrc=",velsrc
         print *,"veldst=",veldst
         print *,"for_estdt=",for_estdt
         print *,"expansion_fact=",expansion_fact
         print *,"densrc_I=",densrc_I
         print *,"densrc_I=",dendst_I
         print *,"distribute_from_target=",distribute_from_target
         print *,"LL=",LL
         print *,"local_freezing_model=",local_freezing_model
         print *,"ksrc,kdst ",ksrc,kdst
         print *,"DTsrc,DTdst ",DTsrc,DTdst
         print *,"dxprobe_source, dxprobe_dest ", &
                 dxprobe_source, dxprobe_dest
         stop
        endif 

        vel=velsum

       else if (local_freezing_model.eq.4) then ! Tanasawa or Schrage

         ! Tanasawa model for a fully saturated gas:
        gamma_tanasawa=0.1
        fluid_molar_mass_Tanasawa=0.07215  ! kg/mol
        fluid_molar_mass_Tanasawa=1000.0*fluid_molar_mass_Tanasawa ! g/mol
        universal_gas=8.314   ! J/(mol K)
        universal_gas=1.0D+7*universal_gas  ! erg/(mol K)

        velsrc=zero
        veldst=zero
        if (LL.gt.zero) then ! evaporation
         if (distribute_from_target.ne.0) then
          print *,"distribute_from_target invalid"
          stop
         endif
          !EVAPORATION
         if (local_Tanasawa_or_Schrage.eq.1) then ! Tanasawa

          if ((Tsrc_INT.gt.Tsat).and.(Tdst_INT.gt.Tsat)) then
           velsrc=two*gamma_tanasawa/abs(gamma_tanasawa-one)
           velsrc=velsrc*sqrt(fluid_molar_mass_Tanasawa/(two*Pi*universal_gas))
           velsrc=velsrc*dendst_I*LL*(half*(Tsrc_INT+Tdst_INT)-Tsat)
           velsrc=velsrc/(Tsat**(1.5))
           velsrc=velsrc/densrc_I ! rate=mdot/densrc_I
           veldst=velsrc

           if (for_estdt.eq.1) then
            velsrc=max(velsrc,velsrc/(one-expansion_fact))
            veldst=velsrc
           else if (for_estdt.eq.0) then
            ! do nothing
           else
            print *,"for_estdt invalid"
            stop
           endif

          endif

         else if (local_Tanasawa_or_Schrage.eq.2) then !approximate schrage
          ! MEHDI EVAPORATION

          ! gamma: Accomodation coefficient
          ! M: Molecular weight (molar mass) [kg/mol]  
          ! m: Mass of a molecule [kg]
          ! n: Material mass [mol]
          ! R: Universal gas constant 8.314462618 [J/(mol K)] 
          ! N_A: Avogadro constant 6.02214076E23 [1/mol]
          ! k_B: Boltzmann constant 1.380649E23 [J/K]
          ! P_x: Pressure (near the interface) [Pa]
          ! T_x: Temperature (near interface) [K]
          !
          ! (M = m N_A)  , (R = N_A k_B) , (k_B / m = R / M)
          !
          ! - Approximate schrage model (using P and T)
          ! mdot=(2 gamma/(2-gamma))
          !      sqrt(M/(2 pi R))
          !      (P_v/sqrt(T_v) - P_l/sqrt(T_l))           {1}
          !
          ! Note: The formulation is at the boundary very close to
          !       the phase-change interface just inside the vapor
          !       region. I think that is why writing the ideal gas
          !       equation makes sense for the liquid region. 
          !             
          ! P V=n R T
          ! P V=n N_A k_B T
          ! P = (n N_A)/V k_B T                            {2}
          !
          ! rho = mass/volume = (n M)/V = (n m N_a)/V
          ! rho/m = (n N_A)/V                              {3}
          !
          ! - Replacing {3} in {2} gives:
          ! P = rho/m k_B T = rho T R / M
          ! P/sqrt(T) = rho/m k_B sqrt(T)                  {4}
          ! 
          ! - Replacing {4} in {1} gives:
          ! mdot=(2 gamma/(2-gamma))
          !      sqrt(M/(2 pi R))
          !      (k_B/m)
          !      (rho_v sqrt(T_v) - rho_l sqrt(T_l))       {5}
          !
          ! - Simplifying the 2nd and 3rd product terms:          
          ! sqrt((M k_B^2)/(2 pi R m^2))= 
          ! sqrt((M k_B^2)/(2 pi N_A k_B m^2))=
          ! sqrt((M k_B)/(2 pi N_A m^2))=
          ! sqrt((k_B)/(2 pi m))
          ! sqrt(R/(2 pi M))
          !
          ! - Approximate schrage model (using rho and T)
          ! => Mass flux (condensation)
          ! mdot=(2 gamma/(2-gamma))
          !      sqrt(R/(2 pi M))
          !      (rho_v sqrt(T_v) - rho_l sqrt(T_l))       {6}
          !
          ! => Mass flux (evaporation)
          ! mdot=(2 gamma/(2-gamma))
          !      sqrt(R/(2 pi M))
          !      (rho_l sqrt(T_l) - rho_v sqrt(T_v))       {6}
          !                &
          ! => Heat flux
          ! qddot = L mdot
          !
          ! Evaporation:
          !     rhol_l => Saturation vapor density at T_l
          !     T_l    => Liquid temeparture at the interface
          !     rho_v  => Vapor density (interface or probe?)
          !     T_v    => Vapor temperature (interface or probe?)
          !
          ! Clausius-Clayperon equation
          ! P_2/P_1=exp(-L/R_specific (1/T_2 - 1/T_1)
          ! P_sat/P_ref = exp ( -L/(R/M) (1/T_sat - 1/T_ref)
          !
         
          if (LL.gt.zero) then
           ! do nothing
          else
           print *,"This Schrage model only for evaporation"
           stop
          endif 
          universal_gas = 8.314462618d0
          Tsrc_ref=20.0d0  ! Kelvin
          psrc_ref=0.090717D+6  ! Pascal  MKS  N/m^2

          ! P_sat/P_ref = exp ( -L/(R/M) (1/T_sat - 1/T_ref)
          ! units of temperature: KELVIN
          if ((Tsrc_probe.gt.zero).and.(Tsrc_probe.lt.1.0D+20)) then
           psrc_sat=psrc_ref*exp(-LL/(universal_gas/molar_mass(im_source))* &
                   (1.0d0/Tsrc_probe - 1.0d0/Tsrc_ref))
          else
           print *,"Tsrc_probe invalid"
           stop
          endif

          !rho = (P M) / (T R)
          densrc_sat=(psrc_sat * molar_mass(im_source))/ &
                     (Tsrc_probe*universal_gas)
          if ((densrc_sat.gt.zero).and.(densrc_sat.lt.1.0D+20)) then
           ! do nothing
          else
           print *,"densrc_sat invalid"
           print *,"densrc_sat=",densrc_sat
           print *,"psrc_sat=",psrc_sat
           print *,"im_source=",im_source
           print *,"Tsrc_probe=",Tsrc_probe
           print *,"universal_gas=",universal_gas
           print *,"molar_mass(im_source)=",molar_mass(im_source)
           stop
          endif
          
          ! mdot=(2 gamma/(2-gamma))
          !      sqrt(R/(2 pi M))
          !      (rho_l_sat sqrt(T_l) - rho_v sqrt(T_v))       {6}
          ! NOT SURE ABOUT UNIT OF "mdot"
          ! LiangETAL2017  (J => molar flux [mol/cm^2 s])
          ! KharangateMudawar2017 (mdor => mass transfer rate [kg/m^2 s]
          !
          gamma_schrage=0.01d0 
          velsrc=two*gamma_schrage/(two-gamma_schrage)
          if (molar_mass(im_source).gt.zero) then
           velsrc=velsrc*sqrt(universal_gas/(2.0d0*Pi*molar_mass(im_source)))
           velsrc=velsrc*(densrc_sat*sqrt(Tsrc_probe)- &
                          dendst_probe*sqrt(Tdst_probe))
           if (velsrc.gt.zero) then
            if (densrc_I.gt.zero) then
             velsrc=velsrc/densrc_I ! rate=mdot/densrc_I
             veldst=velsrc
            else
             print *,"densrc_I invalid"
             stop
            endif
           else if (velsrc.le.zero) then
            velsrc=zero
           else
            print *,"velsrc bust"
            stop
           endif
          else
           print *,"molar_mass invalid"
           stop
          endif

          if (for_estdt.eq.1) then
           velsrc=max(velsrc,velsrc/(one-expansion_fact))
           veldst=velsrc
          else if (for_estdt.eq.0) then
           ! do nothing
          else
           print *,"for_estdt invalid"
           stop
          endif

         else
          print *,"local_Tanasawa_or_Schrage invalid"
          stop
         endif
        else if (LL.lt.zero) then ! condensation
         if (distribute_from_target.ne.1) then
          print *,"distribute_from_target invalid"
          stop
         endif
         if (local_Tanasawa_or_Schrage.eq.1) then ! Tanasawa

          if ((Tsrc_INT.lt.Tsat).and.(Tdst_INT.lt.Tsat)) then
           velsrc=two*gamma_tanasawa/abs(gamma_tanasawa-one)
           velsrc=velsrc*sqrt(fluid_molar_mass_Tanasawa/(two*Pi*universal_gas))
           velsrc=velsrc*densrc_I*LL*(half*(Tsrc_INT+Tdst_INT)-Tsat)
           velsrc=velsrc/(Tsat**(1.5))
           velsrc=velsrc/dendst_I ! rate=mdot/dendst_I
           veldst=velsrc
           if (for_estdt.eq.1) then
            velsrc=max(velsrc,velsrc/(one-expansion_fact))
            veldst=velsrc
           else if (for_estdt.eq.0) then
            ! do nothing
           else
            print *,"for_estdt invalid"
            stop
           endif
          endif

         else if (local_Tanasawa_or_Schrage.eq.2) then !schrage
          ! MEHDI EVAPORATION (CONDENSATION)
         else
          print *,"local_Tanasawa_or_Schrage invalid"
          stop
         endif

        else if (LL.eq.zero) then
         print *,"LL invalid"
         stop
        else
         print *,"LL invalid"
         stop
        endif

        if ((velsrc.lt.zero).or.(veldst.lt.zero)) then
         print *,"velsrc or veldst invalid"
         print *,"velsrc=",velsrc
         print *,"veldst=",veldst
         stop
        endif

        vel=velsrc

       else if (local_freezing_model.eq.2) then

        if (distribute_from_target.ne.0) then
         print *,"distribute_from_target invalid"
         stop
        endif

        verb_hydrate=0
        if (((VOFsrc.ge.VOFTOL).and.(VOFdst.ge.VOFTOL)).or. &
            (for_estdt.eq.0)) then
         call HYDRATE_FORMATION_RATE(time,Cmethane_in_hydrate, &
          C_w0,Tsrc_probe,PHYDWATER,vel,Tsat,K_f,verb_hydrate)

         if (for_estdt.eq.1) then
          vel=max(vel,vel/(one-expansion_fact))
         else if (for_estdt.eq.0) then
          ! do nothing
         else
          print *,"for_estdt invalid"
          stop
         endif

        else if (((VOFsrc.le.VOFTOL).or.(VOFdst.le.VOFTOL)).and. &
                 (for_estdt.eq.1)) then
         vel=zero
        else
         print *,"VOFsrc, VOFdst, or for_estdt invalid"
         stop
        endif

       else
        print *,"local_freezing_model invalid"
        stop
       endif

      else
       print *,"start_freezing invalid"
       stop
      endif

      return
      end subroutine get_vel_phasechange


      subroutine length1(z,zout)
      IMPLICIT NONE
      REAL_T z(2),zout
      
      zout = sqrt(z(1)*z(1)+z(2)*z(2))
      return 

      end subroutine length1
      
      subroutine DOT1(a,b,c)
      IMPLICIT NONE
      REAL_T a(2),b(2),c
      
      c = a(1)*b(1)+a(2)*b(2)
      return 

      end subroutine DOT1

      subroutine distsub(p,a,b,dist)
      IMPLICIT NONE
      REAL_T t,t1,t2,t3,t4,p(2),b(2),a(2)
      REAL_T dist,pb(2),pa(2),ab(2),temp(2)
      INTEGER_T i
       
      do i=1,2
       ab(i)=b(i)-a(i)
       pb(i)=b(i)-p(i)
       pa(i)=a(i)-p(i)
      enddo
! one should now check if dot(pa,pb)/dot(pa,pa) is between 0 and 1
      call DOT1(pb,ab,t1) 
      call DOT1(ab,ab,t2)
      t = t1/t2       
! t =DOT(pa,pb)/DOT(ab,ab)
      if ((t.gt.0).and.(t.lt.1))  then
       call DOT1(pa,ab,t3)
       do i=1,2
! the second part of temp is the projection of p onto ab	  
        temp(i) = t2*p(i)-t1*a(i)+t3*b(i)
! temp(i) =DOT(ab,ab)*p(i)-DOT(pb,ab)*a(i)+DOT(pa,ab)*b(i)
       enddo
       call length1(temp,t4)
       dist = t4/t2
! dist = 1/DOT(ab,ab)*length(temp)
      else
       call length1(pa,t1)
       call length1(pb,t2)
       dist = min(t1,t2)
      endif

      return 
      end subroutine distsub
      
      
      subroutine setupwave(zed,t)
      IMPLICIT NONE
      REAL_T o(101),kk,t,ar(101),aa,bb
      INTEGER_T i
      COMPLEX*16 zed(199),A,B,A3,A4,A5,II
      COMPLEX*16 P0(101),P1(101),P2(101),Q0(101),Q1(101)
      COMPLEX*16 Q2(101),Q3(101),Q4(101),Q5(101), tang,d

      kk=20
      II=DCMPLX(cos(Pi/2),sin(Pi/2))
!     plunging breaker
      A=2.4*DCMPLX(cos(Pi/3),sin(Pi/3))
      B=2.4*DCMPLX(cos(Pi/3),sin(Pi/3))
      A3=DCMPLX(0,0.6)
      A4=DCMPLX(0,-0.6)
      A5=DCMPLX(-0.35,0)

!     spilling breaker        
!     A=DCMPLX(cos(pi/4),sin(pi/4))
!     B=DCMPLX(cos(pi/4),sin(pi/4))
!     A3=DCMPLX(0,0.5)
!     A4=DCMPLX(0,-0.5)
!     A5=DCMPLX(-0.2,0)

      do i=1,101
       ar(i)=1
!      o(i)=-2+(i-1)/(23.0+2*t)
       o(i)=-2.2+(i-1)/(25.0)
      enddo
      do i=1,101
       P0(i) = t*ar(i)
       P1(i) = t*o(i)-sqrt(kk)*(1/(2*t)-1/(6*t**3))*II*ar(i)
       P2(i) = t*o(i)**2-kk*(1/(12*t**3)-7/(90*t**5)+1/(84*t**7))*ar(i)- &
                sqrt(kk)*(1/t-1/(3*t**3))*II*o(i)

       Q0(i) = 1*ar(i)
       Q1(i) = o(i)-sqrt(kk)/2.*(1/(3*t**2)-1/(5*t**4))*II*ar(i)
       Q2(i) = o(i)**2-kk*(1/(60*t**4)-13/(630*t**6)+1/(180*t**8))*ar(i)- &
                sqrt(kk)*(1/(3*t**2)-1/(5*t**4))*II*o(i)
       Q3(i) = o(i)**3-1.5*sqrt(kk)*(1/(3*t**2)-1/(5*t**4))*II*o(i)**2+ &
                3*kk*(1/(60*t**4)-13/(630*t**6)+1/(180*t**8))*o(i)+ &
                II*kk**1.5*(1/(840*t**6)-17/(7560*t**8))*ar(i)
       Q4(i) = o(i)**4-2*sqrt(kk)*(1/(3*t**2)-1/(5*t**4))*II*o(i)**3+ &
                6*kk*(1/(60*t**4)-13/(630*t**6)+1/(180*t**8))*o(i)**2+ &
                4*II*kk**1.5*(1/(840*t**6)-17/(7560*t**8))*o(i)+ &
                2*kk**2/(30240*t**8)*ar(i) 
       Q5(i) = o(i)**5-2.5*sqrt(kk)*(1/(3*t**2)-1/(5*t**4))*II*o(i)**4+ &
                10*kk*(1/(60*t**4)-13/(630*t**6)+1/(180*t**8))*o(i)**3+ &
                10*II*kk**1.5*(1/(840*t**6)-17/(7560*t**8))*o(i)**2+ &
                10*kk**2/(30240*t**8)*o(i)

       zed(i+49) = A*(P0(i)+P2(i)/2.)*II-B*(Q0(i)+Q2(i)/2.)+A3*Q3(i)+A4*Q4(i)+ &
                A5*Q5(i)-0.03*II*Q5(i)+8.1*t*ar(i)-t**1.5*II*ar(i)

      enddo


      tang = zed(50)-zed(51)
      tang = t*DREAL(tang)+II*DIMAG(tang)
      do i = 1,49
       zed(50-i) = zed(50-i+1)+tang
       tang = DREAL(tang)+II*DIMAG(tang)/i**(0.5)
      enddo


!     aa and bb are as in aa*exp(-t^2/c)+bb
      d=zed(150)-zed(50)
      aa=DIMAG(d)
      bb=DIMAG(zed(50))
      do i=1,49
       zed(i+150) = DREAL(zed(150))-i+II*(aa*exp(-REAL(i)**2/800)+bb)
      enddo
      return 
      end subroutine setupwave

 
       ! vel is initialized with the current velocity.
      subroutine vel_freestream(x,dir,vel,time, &
       presbc_array, &
       outflow_velocity_buffer_size, & !(1,1),(2,1),(3,1),(1,2),(2,2),(3,2)
       problo,probhi)
      use global_utility_module
      IMPLICIT NONE

      REAL_T, intent(in) :: problo(SDIM),probhi(SDIM)
      REAL_T, intent(in) :: x(SDIM)
      REAL_T, intent(in) :: time
      REAL_T, intent(inout) :: vel
      INTEGER_T, intent(in) :: dir
      INTEGER_T dirloc
      INTEGER_T, intent(in) :: presbc_array(SDIM,2,num_materials_vel)
      REAL_T, intent(in) :: outflow_velocity_buffer_size(2*SDIM)
      REAL_T local_buffer(2*SDIM)
      REAL_T buf,dist
      INTEGER_T dirbc,side,ibuf
      REAL_T problen(SDIM)


      if ((dir.lt.0).or.(dir.ge.SDIM)) then
       print *,"dir invalid in vel_freestream"
       stop
      endif

      do dirloc=1,SDIM
       problen(dirloc)=probhi(dirloc)-problo(dirloc)
       if (problen(dirloc).le.zero) then
        print *,"problen(dirloc).le.zero"
        stop
       else if (problen(dirloc).gt.zero) then
        ! do nothing
       else
        print *,"problen bust"
        stop
       endif
      enddo

      do ibuf=1,2*SDIM
       local_buffer(ibuf)=outflow_velocity_buffer_size(ibuf)
      enddo

      buf=problen(1)/128.0

      if (is_in_probtype_list().eq.1) then

       call SUB_velfreestream(problen,local_buffer)

      else if (probtype.eq.201) then
       if (SDIM.eq.3) then
        dirbc=2
        side=1 
        ibuf=(side-1)*SDIM+dirbc
        if (local_buffer(ibuf).eq.zero) then
         local_buffer(ibuf)=buf
        endif
        side=2
        ibuf=(side-1)*SDIM+dirbc
        if (local_buffer(ibuf).eq.zero) then
         local_buffer(ibuf)=buf
        endif
       endif ! sdim==3
       dirbc=1
       side=1
       ibuf=(side-1)*SDIM+dirbc
       if (local_buffer(ibuf).eq.zero) then
        local_buffer(ibuf)=buf
       endif
       side=2
       ibuf=(side-1)*SDIM+dirbc
       if (local_buffer(ibuf).eq.zero) then
        local_buffer(ibuf)=buf
       endif
      else if (probtype.eq.710) then
       dirbc=SDIM
       side=2
       buf=probhi(SDIM)-yblob2
       ibuf=(side-1)*SDIM+dirbc
       if (local_buffer(ibuf).eq.zero) then
        local_buffer(ibuf)=buf
       endif
      else if (probtype.eq.5700) then
       buf=problen(1)/32.0
       dirbc=1
       side=2
       ibuf=(side-1)*SDIM+dirbc
       if (local_buffer(ibuf).eq.zero) then
        local_buffer(ibuf)=buf
       endif
! 3D jetbend outflow conditions
! axis_dir=2 => pressure inflow BC
      else if ((probtype.eq.53).and.(axis_dir.ne.2)) then
       buf=problen(1)/32.0
       dirbc=2
       side=1
       ibuf=(side-1)*SDIM+dirbc
       if (local_buffer(ibuf).eq.zero) then
        local_buffer(ibuf)=buf
       endif
       dirbc=1
       side=2
       ibuf=(side-1)*SDIM+dirbc
       if (local_buffer(ibuf).eq.zero) then
        local_buffer(ibuf)=buf
       endif
       dirbc=2
       ibuf=(side-1)*SDIM+dirbc
       if (local_buffer(ibuf).eq.zero) then
        local_buffer(ibuf)=buf
       endif
       dirbc=SDIM
       ibuf=(side-1)*SDIM+dirbc
       if (local_buffer(ibuf).eq.zero) then
        local_buffer(ibuf)=buf
       endif
      endif

      do dirbc=1,SDIM
       do side=1,2
        ibuf=(side-1)*SDIM+dirbc
        if (local_buffer(ibuf).eq.zero) then
         ! do nothing
        else if ((local_buffer(ibuf).gt.zero).and. &
                 (local_buffer(ibuf).le.problen(dirbc)*(one+VOFTOL))) then
      
         if (presbc_array(dirbc,side,1).eq.EXT_DIR) then
          if (side.eq.1) then
           dist=(x(dirbc)-problo(dirbc))
           if (dist.lt.-VOFTOL*problen(dirbc)) then
            print *,"dist.lt.-VOFTOL*problen"
            stop
           else if (dist.le.local_buffer(ibuf)) then
            if (dir+1.eq.dirbc) then
             if (vel.gt.zero) then
              vel=zero
             else if (vel.le.zero) then
              ! do nothing
             else
              print *,"vel invalid"
              stop
             endif
            else if ((dir.ge.0).and.(dir.lt.SDIM)) then
             vel=zero
            else
             print *,"dir invalid"
             stop
            endif
           else if ((dist.ge.local_buffer(ibuf)).and. &
                    (dist.le.problen(dirbc)*(one+VOFTOL))) then
            ! do nothing
           else
            print *,"dist invalid"
            stop
           endif

          else if (side.eq.2) then

           dist=(probhi(dirbc)-x(dirbc))
           if (dist.lt.-VOFTOL*problen(dirbc)) then
            print *,"dist.lt.-VOFTOL*problen"
            stop
           else if (dist.le.local_buffer(ibuf)) then
            if (dir+1.eq.dirbc) then
             if (vel.lt.zero) then
              vel=zero
             else if (vel.ge.zero) then
              ! do nothing
             else
              print *,"vel invalid"
              stop
             endif
            else if ((dir.ge.0).and.(dir.lt.SDIM)) then
             vel=zero
            else
             print *,"dir invalid"
             stop
            endif
           else if ((dist.ge.local_buffer(ibuf)).and. &
                    (dist.le.problen(dirbc)*(one+VOFTOL))) then
            ! do nothing
           else
            print *,"dist invalid"
            stop
           endif

          else
           print *,"side invalid"
           stop
          endif
         else if ((presbc_array(dirbc,side,1).eq.INT_DIR).or. &
                  (presbc_array(dirbc,side,1).eq.REFLECT_EVEN).or. &
                  (presbc_array(dirbc,side,1).eq.FOEXTRAP)) then
          ! do nothing
         else
          print *,"presbc_array invalid"
          print *,"probtype,dirbc,side,presbc_array ",probtype,dirbc,side, &
            presbc_array(dirbc,side,1)
          stop
         endif
        else 
         print *,"local_buffer invalid"
         print *,"ibuf,dirbc,side,problen,local_buffer ", &
          ibuf,dirbc,side,problen(dirbc),local_buffer(ibuf)
         print *,"probtype= ",probtype
         stop
        endif
       enddo ! side=1..2
      enddo ! dirbc=1..SDIM

      return
      end subroutine vel_freestream

subroutine initialvel(N1parm,N2parm,vel_lr,     &
 vel_lz,vel_gr, vel_gz, r1,r2,W1bar,W2bar,Re,We,RGASRWATER)

implicit none

REAL_T Re,We,RGASRWATER
integer, intent(in)          :: N1parm
integer, intent(in)          :: N2parm
integer, parameter          :: nn=0
real*8 :: alpha_real  ! xblob9
real*8 :: alpha_imag  ! yblob9

integer                     :: M, j, k, ii,jj
complex*16                  :: alpha
complex*16, dimension(:,:), allocatable :: eigenv
complex*16, dimension(:), allocatable :: omega1

complex*16, dimension(0:N1parm) :: vel_lr
complex*16, dimension(0:N1parm) :: vel_lz
complex*16, dimension(0:N2parm) :: vel_gr
complex*16, dimension(0:N2parm) :: vel_gz

real*8, dimension(0:N1parm) :: r1
real*8, dimension(0:N2parm) :: r2
real*8 :: fr,fi,f
real*8  :: omega_real,omega_imag,ki,kr
real*8, dimension(0:N1parm)          :: W1bar
real*8, dimension(0:N2parm)          :: W2bar


alpha_real=xblob9
alpha_imag=yblob9
print *,"alpha_real,alpha_imag ",alpha_real,alpha_imag
alpha=DCMPLX(alpha_real, alpha_imag)

! u, v, w, p, f
M=(N1parm+N2parm+2)*4+1

allocate(omega1(M))
allocate(eigenv(M,M))

print *,"calling tlsa M=",M
call tlsa(M, alpha, omega1, eigenv, N1parm, N2parm, nn, r1, r2,W1bar,W2bar, &
 Re,We,RGASRWATER)
print *,"done with tlsa"

k=0
do j=1,M
  kr=real(omega1(j))
  ki=aimag(omega1(j))
!  if ((abs(kr).lt.1.0D-8).and.(ki.gt.1.D-2).and.(ki.lt.1.E0)) then
  if ((abs(kr).lt.2.0).and.(ki.gt.0.0).and.(ki.lt.1.E0)) then
   k=k+1
   omega_real=kr
   omega_imag=ki
   fr=real(eigenv(M,j))
   fi=aimag(eigenv(M,j))
   f=fr*fr+fi*fi
   write(*,*) "the growthrate is (omega real, omega imag: ",   &
     omega_real,omega_imag

   do ii=0,N1parm
     if (ii+1.gt.M) then
      print *,"ii too big"
      stop
     endif
     kr=real(eigenv(ii+1,j))
     ki=aimag(eigenv(ii+1,j))
     vel_lr(ii)=DCMPLX((kr*fr+ki*fi)/f,(ki*fr-kr*fi)/f)
     if (ii+2*N1parm+3.gt.M) then
      print *,"ii too big"
      stop
     endif
     kr=real(eigenv(ii+2*N1parm+3,j))
     ki=aimag(eigenv(ii+2*N1parm+3,j))
     vel_lz(ii)=DCMPLX((kr*fr+ki*fi)/f,(ki*fr-kr*fi)/f)
   enddo
   jj=4*N1parm+5
   do ii=0,N2parm
     if (ii+jj.gt.M) then
      print *,"ii+jj too big"
      stop
     endif
     kr=real(eigenv(jj+ii,j))
     ki=aimag(eigenv(jj+ii,j))
     vel_gr(ii)=DCMPLX((kr*fr+ki*fi)/f,(ki*fr-kr*fi)/f)
     if (jj+2*N2parm+2+ii.gt.M) then
      print *,"index too big"
      stop
     endif
     kr=real(eigenv(jj+2*N2parm+2+ii,j))
     ki=aimag(eigenv(jj+2*N2parm+2+ii,j))
     vel_gz(ii)=DCMPLX((kr*fr+ki*fi)/f,(ki*fr-kr*fi)/f)
   enddo
  endif
enddo
if(k==0) then
  write(*,*) "no suitable eigenvalues"
  stop
endif
deallocate(omega1)
deallocate(eigenv)
return

end subroutine initialvel

subroutine normcomplexmat(A,M)
implicit none

integer M,argi,argj,i,j
complex*16 A(M,M)
real*8 magmax,minreal,maxreal,mincomplex,maxcomplex,tr,ti,magtemp

 magmax=0.0
 minreal=1.0D+20
 maxreal=-1.0D+20
 mincomplex=1.0D+20
 maxcomplex=-1.0D+20
 do i=1,M
 do j=1,M
  tr=real(A(i,j))
  ti=aimag(A(i,j))
  magtemp=sqrt(tr**2+ti**2)
  if (magtemp.gt.magmax) then
   magmax=magtemp
   argi=i
   argj=j
  endif
  if (tr.gt.maxreal) then
   maxreal=tr
  endif
  if (tr.lt.minreal) then
   minreal=tr
  endif
  if (ti.gt.maxcomplex) then
   maxcomplex=ti
  endif
  if (ti.lt.mincomplex) then
   mincomplex=ti
  endif
 enddo
 enddo
 print *,"M=",M
 print *,"magmax,argi,argj ",magmax,argi,argj
 print *,"maxreal=",maxreal
 print *,"minreal=",minreal
 print *,"maxcomplex=",maxcomplex
 print *,"mincomplex=",mincomplex

return
end subroutine


subroutine tlsa(M, alpha, omega, eigenv,N1parm,N2parm,nn,r1,r2,W1bar,W2bar, &
  Re,We,RGASRWATER)
implicit none

REAL_T Re,We,RGASRWATER
integer, intent(in)                      :: M,N1parm,N2parm,nn
complex*16, intent(in)                   :: alpha
complex*16, dimension(1:M)               :: omega
complex*16, dimension(1:M,1:M)           :: eigenv
REAL*8, dimension(0:N1parm)              :: r1
REAL*8, dimension(0:N2parm)              :: r2


integer                            :: i, j
integer                            :: LWORK
integer                            :: LDA
integer                            :: LDB
integer                            :: ldvl
integer                            :: ldvr
complex*16, dimension(M)           :: alpha1
complex*16, dimension(M)           :: beta1
complex*16, dimension(M,M)         :: vr
complex*16, dimension(M,M)         :: A
complex*16, dimension(M,M)         :: B
complex*16, dimension(:),allocatable      :: WORK
double precision,dimension(:),allocatable      :: RWORK

real*8                   :: temp,maxbeta
real*8, dimension(0:N1parm)          :: W1bar
real*8, dimension(0:N2parm)          :: W2bar

LWORK=20*M
LDA=M
LDB=M
ldvl=M
ldvr=M

print *,"before initialize N1,N2,nn,alpha ",N1parm,N2parm,nn,alpha
call initialize(M,A,B,alpha,N1parm,N2parm,nn,r1,r2,W1bar,W2bar, &
  Re,We,RGASRWATER)
print *,"after initialize"

allocate(RWORK(20*M))
allocate(WORK(LWORK))

#ifdef HAS_BLAS
print *,"before zggev M,LDA,LDB ",M,LDA,LDB
print *,"norm of A"
call normcomplexmat(A,M)
print *,"norm of B"
call normcomplexmat(B,M)
call zggev(jobvl,jobvr,M,A,LDA,B,LDB,alpha1,beta1,vl,ldvl,vr,ldvr,WORK, &
          LWORK,RWORK,INFO)
print *,"after zggev"
#endif
#ifndef HAS_BLAS
print *,"this routine can only be called if USEBLAS=TRUE"
stop
#endif

maxbeta=0.0d0
do i=1,M
 temp=sqrt(aimag(beta1(i))**2+real(beta1(i))**2)
 if (temp.gt.maxbeta) then
  maxbeta=temp
 endif
enddo
do i=1,M
  temp=sqrt(aimag(beta1(i))**2+real(beta1(i))**2)
  if(temp<=(1.0D-10)*maxbeta) then
     omega(i)=1.0D+30
  else
     omega(i)=alpha1(i)/beta1(i)
  endif
  do j=1,M
     eigenv(i,j)=vr(i,j)
  enddo
enddo
deallocate(WORK)
deallocate(RWORK)
end subroutine tlsa

subroutine initialize(M,A,B,alpha,N1parm,N2parm,nn,r1,r2,W1bar,W2bar, &
  ReIN,WeIN,RGASRWATER)
use global_utility_module
IMPLICIT NONE

REAL_T ReIN,WeIN,RGASRWATER
integer, intent(in)                :: M,N1parm,N2parm,nn
complex*16, intent(in)             :: alpha 
complex*16, dimension(0:M-1,0:M-1) :: A
complex*16, dimension(0:M-1,0:M-1) :: B

real*8, parameter :: PI_lsa = 3.1415926535898d0
!lsaproblem_type=0 Rayleigh capillary test
!lsaproblem_type=1 Co-flowing jet test with Lin's basic flow
INTEGER :: lsaproblem_type

real*8  ::  N, Q, l, Re, We, Fr

integer                            :: i, j, k
real*8                             :: alphai,alphar,alphai2,alphar2,alphari
real*8, dimension(0:N1parm)         :: C1
real*8, dimension(0:N1parm,0:N1parm)    :: E1
real*8, dimension(0:N1parm,0:N1parm)    :: ER1
real*8, dimension(0:N1parm,0:N1parm)    :: F1
real*8, dimension(0:N1parm,0:N1parm)    :: ERE1
real*8, dimension(0:N1parm,0:N1parm)    :: E1alt
real*8, dimension(0:N1parm,0:N1parm)    :: F1alt
real*8, dimension(0:N1parm,0:N1parm)    :: ERE1alt
real*8, dimension(0:N2parm)         :: C2
real*8, dimension(0:N2parm,0:N2parm)    :: E2
real*8, dimension(0:N2parm,0:N2parm)    :: ER2
real*8, dimension(0:N2parm,0:N2parm)    :: F2
real*8, dimension(0:N2parm,0:N2parm)    :: ERE2
real*8, dimension(0:M-1,0:M-1)  :: Ar
real*8, dimension(0:M-1,0:M-1)  :: Ai
real*8, dimension(0:M-1,0:M-1)  :: Br
real*8, dimension(0:M-1,0:M-1)  :: Bi
 
real*8          :: NQ,Q1,NQ2,Q2
real*8, dimension(0:N1parm)          :: eta
real*8, dimension(0:N2parm)          :: xi
real*8, dimension(0:N1parm)          :: r1
real*8, dimension(0:N2parm)          :: r2
real*8, dimension(0:N1parm)          :: W1bar,DW1bar
real*8, dimension(0:N1parm)          :: DDW1bar
real*8, dimension(0:N2parm)          :: W2bar,DW2bar
real*8, dimension(0:N2parm)          :: DDW2bar

real*8 :: rj2,rj
  
integer IU,IV,IW,IP
integer IU2,IV2,IW2,IP2
integer IFVAR
integer ICONT,IUMOM,IVMOM,IWMOM
integer ICONT2,IUMOM2,IVMOM2,IWMOM2
integer IUNOSLIP,IVNOSLIP,IWNOSLIP
integer IUJUMP,IVJUMP,IWJUMP,IPJUMP,IFEQN,ITAN1parmEQN,ITAN2parmEQN
integer IEXTRAEQN
real*8 :: coeff,coeff2,coeff3,coeff4,coeff5,coeff6,coeff7,RR


lsaproblem_type=NINT(radblob9)
print *,"lsaproblem_type=",lsaproblem_type


N=get_user_viscconst(2,fort_denconst(2),fort_tempconst(2))/ &
  get_user_viscconst(1,fort_denconst(1),fort_tempconst(1))

Q=fort_denconst(2)/fort_denconst(1)
l=RGASRWATER
Re=ReIN
We=WeIN
Fr=1.0E12

print *,"N,Q,l,Re,We,Fr ",N,Q,l,Re,We,Fr

do k=0,N1parm
   eta(k)=-dcos(PI_lsa*DBLE(k)/DBLE(N1parm))
   r1(k)=(1.0d0+eta(k))/2.0d0
   if(lsaproblem_type==0) then
      W1bar(k)=0.0d0
      DW1bar(k)=-0.0d0
      DDW1bar(k)=-0.0d0
   elseif(lsaproblem_type==1) then
      RR=Re/Fr
      coeff=(1.0d0-Q)*RR*(2.0d0*log(l)+1.0d0-l*l)/4.0d0
      coeff2=(N-coeff)/(N-1.0d0+l*l)
      W1bar(k)=1.0d0-coeff2*(r1(k)**2)
      DW1bar(k)=-2.0d0*coeff2*r1(k)
      DDW1bar(k)=-2.0d0*coeff2
      W1bar(k)=-W1bar(k)
      DW1bar(k)=-DW1bar(k)
      DDW1bar(k)=-DDW1bar(k)
   endif

enddo
do k=0,N2parm
   xi(k)=-dcos(PI_lsa*DBLE(k)/DBLE(N2parm))
   r2(k)=1.0d0+(xi(k)+1.0d0)*(l-1.0d0)/2.0d0

   if(lsaproblem_type==0) then
      W2bar(k)=0.0d0
      DW2bar(k)=-0.0d0
      DDW2bar(k)=-0.0d0
   elseif(lsaproblem_type==1) then
      RR=Re/Fr
      coeff=(1.0d0-Q)*RR*(2.0d0*log(l)+1.0d0-l*l)/4.0d0
      coeff2=(N-coeff)/(N*(N-1.0d0+l*l))
      coeff3=(1.0d0-Q)*RR/(4.0d0*N)
      coeff4=l*l*(coeff3-coeff2)
      coeff5=(coeff2-coeff3)
      coeff6=-2.0d0*coeff3
      coeff7=coeff4+coeff6*log(l)
      W2bar(k)=-coeff5*(r2(k))**2+coeff6*log(r2(k))-coeff7
      DW2bar(k)=-2.0d0*coeff5*r2(k)+coeff6/r2(k)
      DDW2bar(k)=-2.0d0*coeff5-coeff6/(r2(k)**2)
      W2bar(k)=-W2bar(k)
      DW2bar(k)=-DW2bar(k)
      DDW2bar(k)=-DDW2bar(k)
   endif
enddo

do i=1,N1parm-1
   C1(i)=1.0d0
   enddo
C1(0)=2.0d0
C1(N1parm)=2.0d0
do j=0,N1parm
   do k=0,N1parm
    if (j.ne.k) then
     E1(j,k)=C1(j)/(C1(k)*(eta(j)-eta(k)))
     if(mod(j+k,2).NE.0) then
      E1(j,k)=-E1(j,k)
     endif
    endif
   enddo
enddo
do j=1,N1parm-1
   E1(j,j)=-eta(j)/(2.0d0*(1.0d0-eta(j)*eta(j)))
enddo
E1(0,0)=-(2.0d0*N1parm*N1parm+1.0d0)/6.0d0
E1(N1parm,N1parm)=-E1(0,0)

do j=0,N1parm
do k=0,N1parm
 E1(j,k)=E1(j,k)*2.0d0
enddo
enddo

do j=0,N1parm
 do k=0,N1parm
  F1(j,k)=0.0d0
  do i=0,N1parm
    F1(j,k)=F1(j,k)+E1(j,i)*E1(i,k)
  enddo
 enddo
enddo

! multiply the columns by r1
do j=0,N1parm
do k=0,N1parm
 ER1(j,k)=E1(j,k)*r1(k)
enddo
enddo
    
do j=0,N1parm
 do k=0,N1parm
  ERE1(j,k)=0.0d0
  do i=0,N1parm
    ERE1(j,k)=ERE1(j,k)+ER1(j,i)*E1(i,k)
  enddo
 enddo
enddo
   
do j=0,N1parm
 do k=0,N1parm
  if (j.eq.0) then
   E1alt(j,k)=E1(j,k)
  else
   E1alt(j,k)=E1(j,k)*r1(k)/r1(j)
  endif
 enddo
 if (j.ne.0) then
  E1alt(j,j)=E1alt(j,j)-1.0d0/r1(j)
 endif
enddo
    
do j=0,N1parm
 do k=0,N1parm
  if (j.eq.0) then
   F1alt(j,k)=F1(j,k)
  else
   F1alt(j,k)=(F1(j,k)*r1(k)-2.0d0*E1alt(j,k))/r1(j)
  endif
 enddo
enddo

do j=0,N1parm
 do k=0,N1parm
  ERE1alt(j,k)=E1alt(j,k)+r1(j)*F1alt(j,k)
 enddo
enddo
    
do i=1,N2parm-1
   C2(i)=1.0d0
enddo
C2(0)=2.0d0
C2(N2parm)=2.0d0
do j=0,N2parm
 do k=0,N2parm
  if (j.ne.k) then
   E2(j,k)=C2(j)/(C2(k)*(xi(j)-xi(k)))
   if(mod(j+k,2).NE.0) then
    E2(j,k)=-E2(j,k)
   endif
  endif
 enddo
enddo
do j=1,N2parm-1
   E2(j,j)=-xi(j)/(2.0d0*(1.0d0-xi(j)*xi(j)))
enddo
E2(0,0)=-(2.0d0*N2parm*N2parm+1.0d0)/6.0d0
E2(N2parm,N2parm)=-E2(0,0)

do j=0,N2parm
do k=0,N2parm
 E2(j,k)=E2(j,k)*2.0d0/(l-1.0d0)
enddo
enddo

do j=0,N2parm
 do k=0,N2parm
  F2(j,k)=0.0d0
  do i=0,N2parm
   F2(j,k)=F2(j,k)+E2(j,i)*E2(i,k)
  enddo
 enddo
enddo

! multiply the columns by r1
do j=0,N2parm
do k=0,N2parm
 ER2(j,k)=E2(j,k)*r2(k)
enddo
enddo

do j=0,N2parm
 do k=0,N2parm
  ERE2(j,k)=0.0d0
  do i=0,N2parm
    ERE2(j,k)=ERE2(j,k)+ER2(j,i)*E2(i,k)
  enddo
 enddo
enddo


alphai=aimag(alpha)
alphar=real(alpha)
alphai2=alphai*alphai
alphar2=alphar*alphar
alphari=alphai*alphar

!write(*,*) alphar, alphai, alphari, alphar2, alphai2

! initialize Ar and Ai
do j=0, M-1
   do k=0,M-1
      Ar(j,k)=0.0d0
      Ai(j,k)=0.0d0
   enddo
enddo

IU=0
IV=IU+N1parm+1
IW=IV+N1parm+1
IP=IW+N1parm+1

IU2=IP+N1parm+1
IV2=IU2+N2parm+1
IW2=IV2+N2parm+1
IP2=IW2+N2parm+1

IFVAR=IP2+N2parm+1

if (IFVAR+1.ne.M) then
 print *,"number of variables invalid"
 stop
endif

ICONT=0
IUMOM=ICONT+N1parm
IVMOM=IUMOM+N1parm
IWMOM=IVMOM+N1parm

ICONT2=IWMOM+N1parm
IUMOM2=ICONT2+N2parm-1
IVMOM2=IUMOM2+N2parm
IWMOM2=IVMOM2+N2parm-1
   
IUNOSLIP=IWMOM2+N2parm-1
IVNOSLIP=IUNOSLIP+1
IWNOSLIP=IVNOSLIP+1

IUJUMP=IWNOSLIP+1
IVJUMP=IUJUMP+1
IWJUMP=IVJUMP+1
IPJUMP=IWJUMP+1
IFEQN=IPJUMP+1
ITAN1parmEQN=IFEQN+1
ITAN2parmEQN=ITAN1parmEQN+1
   
IEXTRAEQN=ITAN2parmEQN+1
   
if (IEXTRAEQN+2.ne.M) then
 print *,"number of equations invalid"
 stop
endif
   
NQ=1.0
Q1=1.0
  
NQ2=N/Q
Q2=Q
! at centerline:
! if nn=0, u=v=0  p and w are finite
! if nn=1, 2u'+iv'=0, u+iv=0  w=p=0
! o.t. u=v=w=p=0
j=0
Ar(j+ICONT,j+IP)=1.0d0

do j=1,N1parm-1
 rj=r1(j)
 do k=0,N1parm
  Ar(j+ICONT,k+IU)=ER1(j,k)/rj
 enddo
 Ai(j+ICONT,j+IV)=nn/rj
 Ar(j+ICONT,j+IW)=-alphai
 Ai(j+ICONT,j+IW)=alphar

 do k=0,N1parm
   Ar(j+ICONT,k+IU)=Ar(j+ICONT,k+IU)*rj
 enddo
 Ai(j+ICONT,j+IV)=Ai(j+ICONT,j+IV)*rj
 Ar(j+ICONT,j+IW)=Ar(j+ICONT,j+IW)*rj
 Ai(j+ICONT,j+IW)=Ai(j+ICONT,j+IW)*rj
enddo

j=0
if (nn.ne.1) then 
 Ar(j+IUMOM,j+IU)=1.0d0
else if (nn.eq.1) then
 do k=0,N1parm
  Ar(j+IUMOM,k+IU)=2.0d0*E1(0,k)
  Ai(j+IUMOM,k+IV)=E1(0,k)
 enddo
endif

do j=1,N1parm-1
 rj=r1(j)
 rj2=rj**2
 do k=0,N1parm
   Ar(j+IUMOM,k+IU)=Q1*NQ*ERE1(j,k)/rj
 enddo
 do k=0,N1parm
  Ar(j+IUMOM,k+IP)=-Re*E1alt(j,k)
 enddo
 Ar(j+IUMOM,j+IU)=Ar(j+IUMOM,j+IU)-Q1*(NQ*((nn**2+1.0d0)/rj2+     &
            alphar2-alphai2)-Re*alphai*W1bar(j))
 Ai(j+IUMOM,j+IU)=-Q1*(Re*alphar*W1bar(j)+2.0d0*NQ*alphari)
 Ai(j+IUMOM,j+IV)=-2.0*nn*NQ*Q1/rj2
 do k=0,N1parm
   Ar(j+IUMOM,k+IU)=Ar(j+IUMOM,k+IU)*rj2
   Ar(j+IUMOM,k+IP)=Ar(j+IUMOM,k+IP)*rj2
 enddo
 Ai(j+IUMOM,j+IU)=Ai(j+IUMOM,j+IU)*rj2
 Ai(j+IUMOM,j+IV)=Ai(j+IUMOM,j+IV)*rj2
enddo

j=0
if (nn.ne.1) then
 Ar(j+IVMOM,j+IV)=1.0d0
else
 Ar(j+IVMOM,j+IU)=1.0d0
 Ai(j+IVMOM,j+IV)=1.0d0
endif

do j=1,N1parm-1
 rj=r1(j)
 rj2=rj**2
 do k=0,N1parm
   Ar(j+IVMOM,k+IV)=NQ*Q1*ERE1(j,k)/rj
 enddo
 Ar(j+IVMOM,j+IV)=Ar(j+IVMOM,j+IV)-Q1*(NQ*((nn**2+1.0d0)/rj2+     &
            alphar2-alphai2)-Re*alphai*W1bar(j))
 Ai(j+IVMOM,j+IV)=-Q1*(Re*alphar*W1bar(j)+2.0d0*NQ*alphari)
 Ai(j+IVMOM,j+IU)=Q1*2.0d0*nn*NQ/rj2
 Ai(j+IVMOM,j+IP)=-Re*nn/rj

 do k=0,N1parm
   Ar(j+IVMOM,k+IV)=Ar(j+IVMOM,k+IV)*rj2
 enddo
 Ai(j+IVMOM,j+IV)=Ai(j+IVMOM,j+IV)*rj2
 Ai(j+IVMOM,j+IU)=Ai(j+IVMOM,j+IU)*rj2
 Ai(j+IVMOM,j+IP)=Ai(j+IVMOM,j+IP)*rj2

enddo

j=0
Ar(j+IWMOM,j+IW)=1.0d0

do j=1,N1parm-1
 rj=r1(j)
 rj2=rj**2
 do k=0,N1parm
   Ar(j+IWMOM,k+IW)=NQ*Q1*ERE1alt(j,k)/rj
 enddo
 Ar(j+IWMOM,j+IW)=Ar(j+IWMOM,j+IW)-Q1*(NQ*((nn**2)/rj2+     &
            alphar2-alphai2)-Re*alphai*W1bar(j))
 Ai(j+IWMOM,j+IW)=-Q1*(Re*alphar*W1bar(j)+2.0d0*NQ*alphari)
 Ar(j+IWMOM,j+IU)=-Re*Q1*DW1bar(j)
 Ar(j+IWMOM,j+IP)=Re*alphai
 Ai(j+IWMOM,j+IP)=-Re*alphar
 
 do k=0,N1parm
   Ar(j+IWMOM,k+IW)=Ar(j+IWMOM,k+IW)*rj2
 enddo
 Ai(j+IWMOM,j+IW)=Ai(j+IWMOM,j+IW)*rj2
 Ar(j+IWMOM,j+IU)=Ar(j+IWMOM,j+IU)*rj2
 Ar(j+IWMOM,j+IP)=Ar(j+IWMOM,j+IP)*rj2
 Ai(j+IWMOM,j+IP)=Ai(j+IWMOM,j+IP)*rj2
 
enddo
  
 
do j=1,N2parm-1
 rj=r2(j)
 do k=0,N2parm
   Ar(j+ICONT2-1,k+IU2)=ER2(j,k)/rj
 enddo
 Ai(j+ICONT2-1,j+IV2)=nn/rj
 Ar(j+ICONT2-1,j+IW2)=-alphai
 Ai(j+ICONT2-1,j+IW2)=alphar
 
 do k=0,N2parm
   Ar(j+ICONT2-1,k+IU2)=Ar(j+ICONT2-1,k+IU2)*rj
 enddo
 Ai(j+ICONT2-1,j+IV2)=Ai(j+ICONT2-1,j+IV2)*rj
 Ar(j+ICONT2-1,j+IW2)=Ar(j+ICONT2-1,j+IW2)*rj
 Ai(j+ICONT2-1,j+IW2)=Ai(j+ICONT2-1,j+IW2)*rj

enddo
 
do j=1,N2parm-1
 rj=r2(j)
 rj2=rj**2
 do k=0,N2parm
   Ar(j+IUMOM2-1,k+IU2)=NQ2*Q2*ERE2(j,k)/rj
 enddo
 do k=0,N2parm
  Ar(j+IUMOM2-1,k+IP2)=-Re*E2(j,k)
 enddo
 Ar(j+IUMOM2-1,j+IU2)=Ar(j+IUMOM2-1,j+IU2)-Q2*(NQ2*((nn**2+1.0d0)/rj2+     &
            alphar2-alphai2)-Re*alphai*W2bar(j))
 Ai(j+IUMOM2-1,j+IU2)=-Q2*(Re*alphar*W2bar(j)+2.0d0*NQ2*alphari)
 Ai(j+IUMOM2-1,j+IV2)=-2.0*nn*Q2*NQ2/rj2
 
 do k=0,N2parm
   Ar(j+IUMOM2-1,k+IU2)=Ar(j+IUMOM2-1,k+IU2)*rj2
   Ar(j+IUMOM2-1,k+IP2)=Ar(j+IUMOM2-1,k+IP2)*rj2
 enddo
 Ai(j+IUMOM2-1,j+IU2)=Ai(j+IUMOM2-1,j+IU2)*rj2
 Ai(j+IUMOM2-1,j+IV2)=Ai(j+IUMOM2-1,j+IV2)*rj2
enddo

j=N2parm
rj=r2(j)
rj2=rj**2
do k=0,N2parm
  Ar(j+IUMOM2-1,k+IU2)=NQ2*Q2*ERE2(j,k)/rj
enddo
do k=0,N2parm
 Ar(j+IUMOM2-1,k+IP2)=-Re*E2(j,k)
enddo
Ar(j+IUMOM2-1,j+IU2)=Ar(j+IUMOM2-1,j+IU2)-Q2*(NQ2*((nn**2+1.0d0)/rj2+     &
           alphar2-alphai2)-Re*alphai*W2bar(j))
Ai(j+IUMOM2-1,j+IU2)=-Q2*(Re*alphar*W2bar(j)+2.0d0*NQ2*alphari)
Ai(j+IUMOM2-1,j+IV2)=-2.0*nn*Q2*NQ2/rj2

do k=0,N2parm
  Ar(j+IUMOM2-1,k+IU2)=Ar(j+IUMOM2-1,k+IU2)*rj2
  Ar(j+IUMOM2-1,k+IP2)=Ar(j+IUMOM2-1,k+IP2)*rj2
enddo
Ai(j+IUMOM2-1,j+IU2)=Ai(j+IUMOM2-1,j+IU2)*rj2
Ai(j+IUMOM2-1,j+IV2)=Ai(j+IUMOM2-1,j+IV2)*rj2

do j=1,N2parm-1
 rj=r2(j)
 rj2=rj**2
 do k=0,N2parm
   Ar(j+IVMOM2-1,k+IV2)=NQ2*Q2*ERE2(j,k)/rj
 enddo
 Ar(j+IVMOM2-1,j+IV2)=Ar(j+IVMOM2-1,j+IV2)-Q2*(NQ2*((nn**2+1.0d0)/rj2+     &
            alphar2-alphai2)-Re*alphai*W2bar(j))
 Ai(j+IVMOM2-1,j+IV2)=-Q2*(Re*alphar*W2bar(j)+2.0d0*NQ2*alphari)
 Ai(j+IVMOM2-1,j+IU2)=2.0*nn*NQ2*Q2/rj2
 Ai(j+IVMOM2-1,j+IP2)=-Re*nn/rj

 do k=0,N2parm
   Ar(j+IVMOM2-1,k+IV2)=Ar(j+IVMOM2-1,k+IV2)*rj2
 enddo
 Ai(j+IVMOM2-1,j+IV2)=Ai(j+IVMOM2-1,j+IV2)*rj2
 Ai(j+IVMOM2-1,j+IU2)=Ai(j+IVMOM2-1,j+IU2)*rj2
 Ai(j+IVMOM2-1,j+IP2)=Ai(j+IVMOM2-1,j+IP2)*rj2
enddo

do j=1,N2parm-1
 rj=r2(j)
 rj2=rj**2
 do k=0,N2parm
   Ar(j+IWMOM2-1,k+IW2)=NQ2*Q2*ERE2(j,k)/rj
 enddo
 Ar(j+IWMOM2-1,j+IW2)=Ar(j+IWMOM2-1,j+IW2)-Q2*(NQ2*((nn**2)/rj2+     &
            alphar2-alphai2)-Re*alphai*W2bar(j))
 Ai(j+IWMOM2-1,j+IW2)=-Q2*(Re*alphar*W2bar(j)+2.0d0*NQ2*alphari)
 Ar(j+IWMOM2-1,j+IU2)=-Re*Q2*DW2bar(j)
 Ar(j+IWMOM2-1,j+IP2)=Re*alphai
 Ai(j+IWMOM2-1,j+IP2)=-Re*alphar

 do k=0,N2parm
   Ar(j+IWMOM2-1,k+IW2)=Ar(j+IWMOM2-1,k+IW2)*rj2
 enddo
 Ai(j+IWMOM2-1,j+IW2)=Ai(j+IWMOM2-1,j+IW2)*rj2
 Ar(j+IWMOM2-1,j+IU2)=Ar(j+IWMOM2-1,j+IU2)*rj2
 Ar(j+IWMOM2-1,j+IP2)=Ar(j+IWMOM2-1,j+IP2)*rj2
 Ai(j+IWMOM2-1,j+IP2)=Ai(j+IWMOM2-1,j+IP2)*rj2

enddo


Ar(IUNOSLIP,IU2+N2parm)=1.0d0
Ar(IVNOSLIP,IV2+N2parm)=1.0d0
Ar(IWNOSLIP,IW2+N2parm)=1.0d0

Ar(IUJUMP,IU+N1parm)=1.0
Ar(IUJUMP,IU2)=-1.0

Ar(IVJUMP,IV+N1parm)=1.0
Ar(IVJUMP,IV2)=-1.0
Ar(IVJUMP,IFVAR)=0.0d0

Ar(IWJUMP,IW+N1parm)=1.0
Ar(IWJUMP,IW2)=-1.0
Ar(IWJUMP,IFVAR)=DW1bar(N1parm)-DW2bar(0)
  
Ar(IFEQN,IFVAR)=-alphai*W1bar(N1parm)
Ai(IFEQN,IFVAR)=alphar*W1bar(N1parm)
Ar(IFEQN,IU+N1parm)=-1.0

Ar(IPJUMP,IP+N1parm)=1.0
Ar(IPJUMP,IP2)=-1.0
do k=0,N1parm
 Ar(IPJUMP,IU+k)=-(2.0/Re)*E1(N1parm,k)
enddo
do k=0,N2parm
 Ar(IPJUMP,IU2+k)=(2.0/Re)*N*E2(0,k)
enddo
Ar(IPJUMP,IFVAR)=(1.0/We)*(1.0-nn*nn-alphar2+alphai2)
Ai(IPJUMP,IFVAR)=(1.0/We)*(-2.0d0*alphari)
 
do k=0,N1parm
 Ar(ITAN1parmEQN,IV+k)=E1(N1parm,k)
enddo
do k=0,N2parm
 Ar(ITAN1parmEQN,IV2+k)=-N*E2(0,k)
enddo
Ar(ITAN1parmEQN,IV+N1parm)=Ar(ITAN1parmEQN,IV+N1parm)-1.0d0
Ar(ITAN1parmEQN,IV2)=Ar(ITAN1parmEQN,IV2)+N*1.0d0
Ai(ITAN1parmEQN,IU+N1parm)=nn
Ai(ITAN1parmEQN,IU2)=-N*nn
Ar(ITAN1parmEQN,IFVAR)=0.0d0
 
Ar(ITAN2parmEQN,IU+N1parm)=-alphai
Ai(ITAN2parmEQN,IU+N1parm)=alphar
Ar(ITAN2parmEQN,IU2)=N*alphai
Ai(ITAN2parmEQN,IU2)=-N*alphar
do k=0,N1parm
 Ar(ITAN2parmEQN,IW+k)=E1alt(N1parm,k)
enddo
do k=0,N2parm
 Ar(ITAN2parmEQN,IW2+k)=-N*E2(0,k)
enddo
Ar(ITAN2parmEQN,IFVAR)=(DDW1bar(N1parm)-N*DDW2bar(0))
 
j=N1parm
rj=r1(j)
do k=0,N1parm
   Ar(IEXTRAEQN,k+IU)=ER1(j,k)/rj
enddo
Ai(IEXTRAEQN,j+IV)=nn/rj
Ai(IEXTRAEQN,j+IW)=alphar
Ar(IEXTRAEQN,j+IW)=-alphai
do k=0,N1parm
   Ar(IEXTRAEQN,k+IU)=Ar(IEXTRAEQN,k+IU)*rj
enddo
Ai(IEXTRAEQN,j+IV)=Ai(IEXTRAEQN,j+IV)*rj
Ar(IEXTRAEQN,j+IW)=Ar(IEXTRAEQN,j+IW)*rj
Ai(IEXTRAEQN,j+IW)=Ai(IEXTRAEQN,j+IW)*rj
j=0
rj=r2(j)
do k=0,N2parm
   Ar(IEXTRAEQN+1,k+IU2)=ER2(j,k)/rj
enddo
Ai(IEXTRAEQN+1,j+IV2)=nn/rj
Ai(IEXTRAEQN+1,j+IW2)=alphar
Ar(IEXTRAEQN+1,j+IW2)=-alphai

do k=0,N2parm
   Ar(IEXTRAEQN+1,k+IU2)=Ar(IEXTRAEQN+1,k+IU2)*rj
enddo
Ai(IEXTRAEQN+1,j+IV2)=Ai(IEXTRAEQN+1,j+IV2)*rj
Ar(IEXTRAEQN+1,j+IW2)=Ar(IEXTRAEQN+1,j+IW2)*rj
Ai(IEXTRAEQN+1,j+IW2)=Ai(IEXTRAEQN+1,j+IW2)*rj

do i=0,M-1
   do j=0,M-1
      A(j,i)=DCMPLX(Ar(j,i),Ai(j,i))
   enddo
enddo

do j=0, M-1
   do i=0, M-1
      Br(i,j)=0.0d0
      Bi(i,j)=0.0d0
   enddo
enddo

! opposite signs since B represents terms moved to RHS
do j=1,N1parm-1
 rj=r1(j)
 rj2=rj**2
 Bi(IUMOM+j,IU+j)=-Re*Q1
 Bi(IUMOM+j,IU+j)=Bi(IUMOM+j,IU+j)*rj2
enddo
do j=1,N1parm-1
 rj=r1(j)
 rj2=rj**2
 Bi(IVMOM+j,IV+j)=-Re*Q1
 Bi(IVMOM+j,IV+j)=Bi(IVMOM+j,IV+j)*rj2
enddo
do j=1,N1parm-1
 rj=r1(j)
 rj2=rj**2
 Bi(IWMOM+j,IW+j)=-Re*Q1
 Bi(IWMOM+j,IW+j)=Bi(IWMOM+j,IW+j)*rj2
enddo

do j=1,N2parm
 rj=r2(j)
 rj2=rj**2
 Bi(IUMOM2+j-1,IU2+j)=-Re*Q2
 Bi(IUMOM2+j-1,IU2+j)=Bi(IUMOM2+j-1,IU2+j)*rj2
enddo
do j=1,N2parm-1
 rj=r2(j)
 rj2=rj**2
 Bi(IVMOM2+j-1,IV2+j)=-Re*Q2
 Bi(IVMOM2+j-1,IV2+j)=Bi(IVMOM2+j-1,IV2+j)*rj2
enddo
do j=1,N2parm-1
 rj=r2(j)
 rj2=rj**2
 Bi(IWMOM2+j-1,IW2+j)=-Re*Q2
 Bi(IWMOM2+j-1,IW2+j)=Bi(IWMOM2+j-1,IW2+j)*rj2
enddo
Bi(IFEQN,IFVAR)=1.0d0

do i=0,M-1
   do j=0,M-1
      B(j,i)=DCMPLX(Br(j,i),Bi(j,i))
   enddo
enddo
   
return
end subroutine initialize

! RGASRWATER=ratio of domain width to liquid domain width
subroutine tlsa2d(M, alpha, omega, eigenv,N1parm,N2parm, &
  r1,r2,Re,We,RGASRWATER,density_ratio,viscosity_ratio)
implicit none

REAL_T density_ratio,viscosity_ratio
REAL_T Re,We,RGASRWATER
integer, intent(in)                      :: M,N1parm,N2parm
complex*16, intent(in)                   :: alpha
complex*16, dimension(1:M)               :: omega
complex*16, dimension(1:M,1:M)           :: eigenv
REAL*8, dimension(0:N1parm)              :: r1
REAL*8, dimension(0:N2parm)              :: r2


integer                            :: i, j
integer                            :: LWORK
integer                            :: LDA
integer                            :: LDB
integer                            :: ldvl
integer                            :: ldvr
complex*16, dimension(M)           :: alpha1
complex*16, dimension(M)           :: beta1
complex*16, dimension(M,M)         :: vr
complex*16, dimension(M,M)         :: A
complex*16, dimension(M,M)         :: B
complex*16, dimension(:),allocatable      :: WORK
double precision,dimension(:),allocatable      :: RWORK

real*8                   :: temp,maxbeta

LWORK=20*M
LDA=M
LDB=M
ldvl=M
ldvr=M

print *,"before initialize2d N1,N2,alpha ",N1parm,N2parm,alpha
if ((N1parm+N2parm+2)*3+1-6.ne.M) then
 print *,"M invalid in tlsa2d"
 stop
endif

call initialize2d(M,A,B,alpha,N1parm,N2parm,r1,r2, &
  Re,We,RGASRWATER,density_ratio,viscosity_ratio)
print *,"after initialize2d"

allocate(RWORK(20*M))
allocate(WORK(LWORK))

#ifdef HAS_BLAS
print *,"before zggev M,LDA,LDB ",M,LDA,LDB
print *,"norm of A"
call normcomplexmat(A,M)
print *,"norm of B"
call normcomplexmat(B,M)
call zggev(jobvl,jobvr,M,A,LDA,B,LDB,alpha1,beta1,vl,ldvl,vr,ldvr,WORK, &
          LWORK,RWORK,INFO)
print *,"after zggev"
#endif
#ifndef HAS_BLAS
print *,"this routine can only be called if USEBLAS=TRUE"
stop
#endif

maxbeta=0.0d0
do i=1,M
 temp=sqrt(aimag(beta1(i))**2+real(beta1(i))**2)
 if (temp.gt.maxbeta) then
  maxbeta=temp
 endif
enddo
do i=1,M
  temp=sqrt(aimag(beta1(i))**2+real(beta1(i))**2)
  if(temp<=(1.0D-10)*maxbeta) then
     omega(i)=1.0D+30
  else
     omega(i)=alpha1(i)/beta1(i)
  endif
  do j=1,M
     eigenv(i,j)=vr(i,j)
  enddo
enddo
deallocate(WORK)
deallocate(RWORK)
end subroutine tlsa2d

subroutine initialize2d(M,A,B,alpha,N1parm,N2parm,r1,r2, &
  ReIN,WeIN,RGASRWATER,density_ratio,viscosity_ratio)
IMPLICIT NONE

REAL_T density_ratio,viscosity_ratio
REAL_T ReIN,WeIN,RGASRWATER
integer, intent(in)                :: M,N1parm,N2parm
complex*16, intent(in)             :: alpha 
complex*16, dimension(0:M-1,0:M-1) :: A
complex*16, dimension(0:M-1,0:M-1) :: B

real*8, parameter :: PI_lsa = 3.1415926535898d0

real*8  ::  N, Q, l, Re, We

integer :: i, j, k
real*8  :: alphai,alphar,alphai2,alphar2,alphari
real*8, dimension(0:N1parm)         :: C1
real*8, dimension(0:N1parm,0:N1parm)    :: E1
real*8, dimension(0:N1parm,0:N1parm)    :: F1
real*8, dimension(0:N2parm)         :: C2
real*8, dimension(0:N2parm,0:N2parm)    :: E2
real*8, dimension(0:N2parm,0:N2parm)    :: F2
real*8, dimension(0:M-1,0:M-1)  :: Ar
real*8, dimension(0:M-1,0:M-1)  :: Ai
real*8, dimension(0:M-1,0:M-1)  :: Br
real*8, dimension(0:M-1,0:M-1)  :: Bi
 
real*8          :: NQ,Q1,NQ2,Q2
real*8, dimension(0:N1parm)          :: eta
real*8, dimension(0:N2parm)          :: xi
real*8, dimension(0:N1parm)          :: r1
real*8, dimension(0:N2parm)          :: r2

! no more IV and IV2 
integer IU,IW,IP
integer IU2,IW2,IP2
integer IFVAR
! no more IVMOM and IVMOM2
integer ICONT,IUMOM,IWMOM
integer ICONT2,IUMOM2,IWMOM2
! no more NOSLIP,JUMP for u,v,w
! no more ITAN2parmEQN
integer IPJUMP,IFEQN,ITAN1parmEQN
integer IEXTRAEQN


! u,w,p,F
if ((N1parm+N2parm+2)*3+1-6.ne.M) then
 print *,"M invalid in initialize2d"
 stop
endif

! N=fort_viscconst(2)/fort_viscconst(1)
! Q=fort_denconst(2)/fort_denconst(1)
N=viscosity_ratio
Q=density_ratio
l=RGASRWATER
Re=ReIN
We=WeIN

print *,"N is mugas/muwater"
print *,"Q is rhogas/rhowater"
print *,"N,Q,l,Re,We ",N,Q,l,Re,We

! liquid for 0<r<1
do k=0,N1parm
   eta(k)=-dcos(PI_lsa*DBLE(k)/DBLE(N1parm))
   r1(k)=(1.0d0+eta(k))/2.0d0
enddo
! gas for 1<r<l
do k=0,N2parm
   xi(k)=-dcos(PI_lsa*DBLE(k)/DBLE(N2parm))
   r2(k)=1.0d0+(xi(k)+1.0d0)*(l-1.0d0)/2.0d0
enddo

! see pages 34 and 35 of Yaohong's thesis
do i=1,N1parm-1
   C1(i)=1.0d0
enddo
C1(0)=2.0d0
C1(N1parm)=2.0d0
do j=0,N1parm
   do k=0,N1parm
    if (j.ne.k) then
     E1(j,k)=C1(j)/(C1(k)*(eta(j)-eta(k)))
     if(mod(j+k,2).NE.0) then
      E1(j,k)=-E1(j,k)
     endif
    endif
   enddo
enddo
do j=1,N1parm-1
   E1(j,j)=-eta(j)/(2.0d0*(1.0d0-eta(j)*eta(j)))
enddo
E1(0,0)=-(2.0d0*N1parm*N1parm+1.0d0)/6.0d0
E1(N1parm,N1parm)=-E1(0,0)

! account for S_11 and S_12 terms (page 36)
do j=0,N1parm
do k=0,N1parm
 E1(j,k)=E1(j,k)*2.0d0
enddo
enddo

do j=0,N1parm
 do k=0,N1parm
  F1(j,k)=0.0d0
  do i=0,N1parm
    F1(j,k)=F1(j,k)+E1(j,i)*E1(i,k)
  enddo
 enddo
enddo

! treatment at r=0 (page 36 of Yaohong's thesis) is not used in 2D.

do i=1,N2parm-1
   C2(i)=1.0d0
enddo
C2(0)=2.0d0
C2(N2parm)=2.0d0
do j=0,N2parm
 do k=0,N2parm
  if (j.ne.k) then
   E2(j,k)=C2(j)/(C2(k)*(xi(j)-xi(k)))
   if(mod(j+k,2).NE.0) then
    E2(j,k)=-E2(j,k)
   endif
  endif
 enddo
enddo
do j=1,N2parm-1
   E2(j,j)=-xi(j)/(2.0d0*(1.0d0-xi(j)*xi(j)))
enddo
E2(0,0)=-(2.0d0*N2parm*N2parm+1.0d0)/6.0d0
E2(N2parm,N2parm)=-E2(0,0)

! account for S_21 and S_22 terms (page 36)
do j=0,N2parm
do k=0,N2parm
 E2(j,k)=E2(j,k)*2.0d0/(l-1.0d0)
enddo
enddo

do j=0,N2parm
 do k=0,N2parm
  F2(j,k)=0.0d0
  do i=0,N2parm
   F2(j,k)=F2(j,k)+E2(j,i)*E2(i,k)
  enddo
 enddo
enddo

! treatment for "r" is not needed in 2D X-Y.


alphai=aimag(alpha)
alphar=real(alpha)
alphai2=alphai*alphai
alphar2=alphar*alphar
alphari=alphai*alphar

!write(*,*) alphar, alphai, alphari, alphar2, alphai2

! initialize Ar and Ai
do j=0, M-1
   do k=0,M-1
      Ar(j,k)=0.0d0
      Ai(j,k)=0.0d0
   enddo
enddo

! these are the unknowns (correspond to matrix columns)
! u, w, p, f  (v is radial velocity; not used in 2d)
! implicit noslip condition at r=0
! implicit continuity at r=1
IU=0
IW=IU+N1parm-1
IP=IW+N1parm-1

! implicit noslip condition at r=l
IU2=IP+N1parm+1
IW2=IU2+N2parm
IP2=IW2+N2parm

IFVAR=IP2+N2parm+1

if (IFVAR+1.ne.M) then
 print *,"number of variables invalid for 2D problem"
 stop
endif

! these are the various equations
! no continuity equation at the origin, instead dp/dr-(1/Re)(u_rr+u_zz)=0
! no equations for liquid or gas at r=0 or r=1
ICONT=0
IUMOM=ICONT+N1parm  
IWMOM=IUMOM+N1parm-1  
ICONT2=IWMOM+N1parm-1  ! continuity equation at r=1 comes later
IUMOM2=ICONT2+N2parm-1  ! last comp. for IUMOM2 is dp/dr-(1/Re)u_rr=0 at r=l
IWMOM2=IUMOM2+N2parm
IPJUMP=IWMOM2+N2parm-1
IFEQN=IPJUMP+1
ITAN1parmEQN=IFEQN+1

! 2 extra equations corresponding to continuity equations for 
! liquid and gas at r=1
IEXTRAEQN=ITAN1parmEQN+1
   
if (IEXTRAEQN+2.ne.M) then
 print *,"number of equations invalid"
 stop
endif
   
NQ=1.0  ! dimensionless kinematic viscosity in water.
Q1=1.0  ! dimensionless density in water
  
NQ2=N/Q  ! dimensionless kinematic viscosity in gas
Q2=Q     ! dimensionless density in gas

! at r=0,l, dp/dr=nu (u_rr+u_zz)
! at r=0,l, u=w=0 
do k=0,N1parm
 Ar(ICONT,k+IP)=-Re*E1(0,k)  ! -Re * dp/dr
enddo
! N=mu_gas/mu_liquid
! Q=den_gas/den_liquid
do k=0,N1parm-2
 Ar(ICONT,k+IU)=NQ*Q1*F1(0,k+1) ! nu u_rr,  NQ=1 Q1=1 NQ2=N/Q Q2=Q
enddo
Ar(ICONT,IU2)=NQ*Q1*F1(0,N1parm)

do j=0,N1parm-2
 do k=0,N1parm-2
  Ar(j+ICONT+1,k+IU)=E1(j+1,k+1)  ! du/dr
 enddo
 Ar(j+ICONT+1,IU2)=E1(j+1,N1parm)

   ! dw/dz
 Ar(j+ICONT+1,j+IW)=-alphai  
 Ai(j+ICONT+1,j+IW)=alphar
enddo

do j=0,N1parm-2
 do k=0,N1parm-2
   Ar(j+IUMOM,k+IU)=Q1*NQ*F1(j+1,k+1)  ! nu u_rr
 enddo
 Ar(j+IUMOM,IU2)=Q1*NQ*F1(j+1,N1parm)  ! nu u_rr

 do k=0,N1parm
  Ar(j+IUMOM,k+IP)=-Re*E1(j+1,k)  ! -Re dp/dr
 enddo
 Ar(j+IUMOM,j+IU)=Ar(j+IUMOM,j+IU)-Q1*NQ*(alphar2-alphai2) ! nu u_zz
 Ai(j+IUMOM,j+IU)=-Q1*2.0d0*NQ*alphari  ! nu u_zz
enddo

do j=0,N1parm-2
 do k=0,N1parm-2
   Ar(j+IWMOM,k+IW)=NQ*Q1*F1(j+1,k+1)  ! nu w_rr
 enddo
 Ar(j+IWMOM,IW2)=Q1*NQ*F1(j+1,N1parm)  ! nu w_rr


 Ar(j+IWMOM,j+IW)=Ar(j+IWMOM,j+IW)-Q1*NQ*(alphar2-alphai2) ! nu w_zz
 Ai(j+IWMOM,j+IW)=-Q1*2.0d0*NQ*alphari  ! nu w_zz
 Ar(j+IWMOM,j+IP+1)=Re*alphai  ! -Re dp/dr
 Ai(j+IWMOM,j+IP+1)=-Re*alphar ! -Re dp/dr
 
enddo
  
do j=0,N2parm-2
 do k=0,N2parm-1
   Ar(j+ICONT2,k+IU2)=E2(j+1,k)  !  du/dr
 enddo
 Ar(j+ICONT2,j+IW2+1)=-alphai  ! dw/dz
 Ai(j+ICONT2,j+IW2+1)=alphar   ! dw/dz
enddo
 
do j=0,N2parm-2
 do k=0,N2parm-1
   Ar(j+IUMOM2,k+IU2)=NQ2*Q2*F2(j+1,k)  ! nu u_rr
 enddo
 do k=0,N2parm
  Ar(j+IUMOM2,k+IP2)=-Re*E2(j+1,k)  ! -Re dp/dr
 enddo
   ! nu u_zz
 Ar(j+IUMOM2,j+IU2+1)=Ar(j+IUMOM2,j+IU2+1)-Q2*NQ2*(alphar2-alphai2)
 Ai(j+IUMOM2,j+IU2+1)=-Q2*2.0d0*NQ2*alphari
enddo

! last comp. of IUMOM2 is dp/dr-(1/Re)(u_rr+u_zz)=0 at r=l
 ! nu u_rr
do k=0,N2parm-1
  Ar(N2parm+IUMOM2-1,k+IU2)=NQ2*Q2*F2(N2parm,k)  !NQ=1 Q1=1  NQ2=N/Q  Q2=Q
enddo
 ! -Re dp/dr
do k=0,N2parm
 Ar(N2parm+IUMOM2-1,k+IP2)=-Re*E2(N2parm,k)
enddo

do j=0,N2parm-2
 do k=0,N2parm-1
   Ar(j+IWMOM2,k+IW2)=NQ2*Q2*F2(j+1,k)  ! nu w_rr
 enddo
  ! nu w_zz
 Ar(j+IWMOM2,j+IW2+1)=Ar(j+IWMOM2,j+IW2+1)-Q2*NQ2*(alphar2-alphai2)
 Ai(j+IWMOM2,j+IW2+1)=-Q2*2.0d0*NQ2*alphari
  ! -Re dp/dr
 Ar(j+IWMOM2,j+IP2+1)=Re*alphai
 Ai(j+IWMOM2,j+IP2+1)=-Re*alphar
enddo

Ar(IFEQN,IU2)=-1.0

Ar(IPJUMP,IP+N1parm)=1.0
Ar(IPJUMP,IP2)=-1.0
do k=0,N1parm-2
 Ar(IPJUMP,IU+k)=-(2.0/Re)*E1(N1parm,k+1)
enddo

Ar(IPJUMP,IU2)=-(2.0/Re)*E1(N1parm,N1parm)+(2.0/Re)*N*E2(0,0)

do k=1,N2parm-1
 Ar(IPJUMP,IU2+k)=(2.0/Re)*N*E2(0,k)
enddo
Ar(IPJUMP,IFVAR)=(1.0/We)*(-alphar2+alphai2)
Ai(IPJUMP,IFVAR)=(1.0/We)*(-2.0d0*alphari)
 
Ar(ITAN1parmEQN,IU2)=N*alphai-alphai
Ai(ITAN1parmEQN,IU2)=-N*alphar+alphar
do k=0,N1parm-2
 Ar(ITAN1parmEQN,IW+k)=E1(N1parm,k+1)
enddo
Ar(ITAN1parmEQN,IW2)=E1(N1parm,N1parm)-N*E2(0,0)
do k=1,N2parm-1
 Ar(ITAN1parmEQN,IW2+k)=-N*E2(0,k)
enddo
 
! du1/dr at r=1
do k=0,N1parm-2
   Ar(IEXTRAEQN,k+IU)=E1(N1parm,k+1)
enddo
Ar(IEXTRAEQN,IU2)=E1(N1parm,N1parm)

! dw1/dz at r=1
Ai(IEXTRAEQN,IW2)=alphar
Ar(IEXTRAEQN,IW2)=-alphai

! du2/dr at r=1
do k=0,N2parm-1
   Ar(IEXTRAEQN+1,k+IU2)=E2(0,k)
enddo
! dw2/dz at r=1
Ai(IEXTRAEQN+1,IW2)=alphar
Ar(IEXTRAEQN+1,IW2)=-alphai

do i=0,M-1
   do j=0,M-1
      A(j,i)=DCMPLX(Ar(j,i),Ai(j,i))
   enddo
enddo

do j=0, M-1
   do i=0, M-1
      Br(i,j)=0.0d0
      Bi(i,j)=0.0d0
   enddo
enddo

! opposite signs since B represents terms moved to RHS
do j=0,N1parm-2
 Bi(IUMOM+j,IU+j)=-Re*Q1
enddo
do j=0,N1parm-2
 Bi(IWMOM+j,IW+j)=-Re*Q1
enddo

do j=0,N2parm-2
 Bi(IUMOM2+j,IU2+j+1)=-Re*Q2
enddo
do j=0,N2parm-2
 Bi(IWMOM2+j,IW2+j+1)=-Re*Q2
enddo
Bi(IFEQN,IFVAR)=1.0d0

do i=0,M-1
   do j=0,M-1
      B(j,i)=DCMPLX(Br(j,i),Bi(j,i))
   enddo
enddo
   
return
end subroutine initialize2d





       subroutine velinterpolation(N1parm,N2parm,r1,r2,vel_lr,   &
         vel_lz,vel_gr, vel_gz, x, y, dist, x_vel, y_vel,W1bar,W2bar)
       implicit none
       integer :: N1parm, N2parm
       real*8, dimension(0:N1parm) :: r1
       real*8, dimension(0:N2parm) :: r2
       real*8, dimension(0:N1parm) :: W1bar
       real*8, dimension(0:N2parm) :: W2bar

       complex*16, dimension(0:N1parm) :: vel_lr, vel_lz
       complex*16, dimension(0:N2parm) :: vel_gr, vel_gz
       real*8 :: x, y, dist
       real*8 :: x_vel, y_vel,W

       real*8    :: Pi_lsa
       real*8    :: lint,xr, xi, yr, yi
       real*8    :: txr, txi, tyr, tyi, kr,ki, theta
       integer :: i, j


       Pi_lsa=4.0*ATAN(1.0)
       if (dist.ge.0) then
        xr=0.0d0
        xi=0.0d0
        yr=0.0d0
        yi=0.0d0
        W=0.0d0
        do i=1, N1parm
         lint=1.0d0
         txr=real(vel_lr(i))
         txi=aimag(vel_lr(i))
         tyr=real(vel_lz(i))
         tyi=aimag(vel_lz(i))
         do j=1, i-1
          lint=lint*(x-r1(j))/(r1(i)-r1(j))
         enddo
         do j=i+1,N1parm
          lint=lint*(x-r1(j))/(r1(i)-r1(j))
         enddo
         xr=xr+txr*lint
         xi=xi+txi*lint
         yr=yr+tyr*lint
         yi=yi+tyi*lint
         W=W+W1bar(i)*lint
        enddo
       else
        xr=0.0d0
        xi=0.0d0
        yr=0.0d0
        yi=0.0d0
        W=0.0d0
        do i=0, N2parm
         lint=1.0d0
         txr=real(vel_gr(i))
         txi=aimag(vel_gr(i))
         tyr=real(vel_gz(i))
         tyi=aimag(vel_gz(i))
         do j=0, i-1
          lint=lint*(x-r2(j))/(r2(i)-r2(j))
         enddo
         do j=i+1,N2parm
          lint=lint*(x-r2(j))/(r2(i)-r2(j))
         enddo
         xr=xr+txr*lint
         xi=xi+txi*lint
         yr=yr+tyr*lint
         yi=yi+tyi*lint
         W=W+W2bar(i)*lint
        enddo
       endif
       theta=2.0d0*Pi_lsa*y/yblob
       kr=cos(theta)
       ki=sin(theta)
       x_vel=radblob*(xr*ki+xi*kr)
       y_vel=radblob*(yr*ki+yi*kr)+W
       return
       end subroutine velinterpolation

       subroutine integrand_function(x,den_ratio,beta,ff)
       IMPLICIT NONE

       REAL_T x,den_ratio,beta,ff,eps

       eps=one-one/den_ratio
       if (den_ratio.lt.one) then
        print *,"den_ratio invalid"
        stop
       endif
       if ((eps.lt.zero).or.(eps.gt.one)) then
        print *,"eps invalid in integrand_function"
        stop
       endif
       ff=two*(beta**3)*exp((beta-x)*(beta+x-two*eps*beta*beta/x))/(x*x)

       return
       end subroutine integrand_function

       subroutine exp_integral(lobound,hibound,beta,den_ratio,N,ff)
       IMPLICIT NONE

       INTEGER_T N,i
       REAL_T lobound,hibound,beta,den_ratio,h,ff,midpt,x

       h=(hibound-lobound)/N
       ff=zero
       do i=1,N
        x=lobound+(i-half)*h
        call integrand_function(x,den_ratio,beta,midpt)
        ff=ff+midpt*h
       enddo

       return
       end subroutine exp_integral

       subroutine bisection_function(beta,den_ratio,JA,ff_bisect)
       IMPLICIT NONE

       REAL_T beta,den_ratio,JA,hibound,ff_bisect,ff_int
       INTEGER_T N

       if (beta.le.zero) then
        print *,"beta cannot be <= 0"
        stop
       endif
  
         ! beta is dimensionless:
         ! r_interface=2 beta sqrt(alpha t)
       hibound=ten+beta
       N=1000
      
       call exp_integral(beta,hibound,beta,den_ratio,N,ff_int)
       ff_bisect=JA-ff_int

       return
       end subroutine bisection_function

       subroutine find_beta(beta,den_ratio,Jacob_number) 
       IMPLICIT NONE

       REAL_T Jacob_number,den_ratio
       REAL_T beta
       REAL_T ff_a,ff_b,ff_c
       REAL_T a,b,c
       INTEGER_T niter

       beta=one
       call bisection_function(beta,den_ratio,Jacob_number,ff_a)
       niter=0
       do while (ff_a.lt.zero)
        beta=beta/two
        call bisection_function(beta,den_ratio,Jacob_number,ff_a)
        niter=niter+1
       enddo
       a=beta

       b=beta
       call bisection_function(beta,den_ratio,Jacob_number,ff_b)
       niter=0
       do while (ff_b.gt.0.0) 
        beta=2.0*beta
        call bisection_function(beta,den_ratio,Jacob_number,ff_b)
        b=beta
        niter=niter+1
       enddo
       b=beta
 
       do niter=1,64
        c=(a+b)/2.0
        beta=c
        call bisection_function(beta,den_ratio,Jacob_number,ff_c)
        if (ff_a*ff_c.le.0.0) then
         b=c
         ff_b=ff_c
        else if (ff_c*ff_b.le.0.0) then
         a=c
         ff_a=ff_c
        else
         print *,"bisection failure"
         print *,"niter=",niter
         print *,"a,b,c ",a,b,c
         print *,"fa,fb,fc ",ff_a,ff_b,ff_c
         stop
        endif
       enddo ! niter
       return

       end subroutine find_beta

       subroutine superheat_temperature( &
         alpha,beta,den_ratio,T_superheat, &
         Jacob_number,T_saturation,rstefan,time,temperature)
       IMPLICIT NONE

       REAL_T alpha,den_ratio
       REAL_T beta,T_superheat,Jacob_number,T_saturation
       REAL_T rstefan,time,temperature,s,hibound,ff_int
       INTEGER_T N

       if (time.le.zero) then
        print *,"time invalid"
        stop
       endif
       if (beta.le.zero) then
        print *,"beta cannot be <= 0"
        stop
       endif
       s=half*rstefan/sqrt(alpha*time)

       hibound=ten+s
       N=1000
       call exp_integral(s,hibound,beta,den_ratio,N,ff_int)
       temperature=ff_int*(T_saturation-T_superheat)/Jacob_number+ &
         T_superheat

       return
       end subroutine superheat_temperature

 
       end module probf90_module


       subroutine FORT_SETFORTSCALES(pressure_scale, &
        velocity_scale)

       use probcommon_module

       IMPLICIT NONE

       REAL_T, intent(in) :: pressure_scale,velocity_scale

       if ((pressure_scale.gt.zero).and. &
           (velocity_scale.gt.zero)) then
        ! do nothing
       else
        print *,"scales invalid in set fort scales "
        print *,"pressure scale = ",pressure_scale
        print *,"velocity scale = ",velocity_scale
        stop
       endif

       if (abs(one-pressure_scale/velocity_scale**2).gt.1.0D-5) then
        print *,"scales invalid in set fort scales "
        print *,"pressure scale = ",pressure_scale
        print *,"velocity scale = ",velocity_scale
        stop
       endif

       global_pressure_scale=pressure_scale
       global_velocity_scale=velocity_scale

       return
       end subroutine FORT_SETFORTSCALES

       subroutine FORT_OVERRIDELSBC(homflag)
       use probcommon_module
       IMPLICIT NONE

       INTEGER_T homflag


       if (homflag.eq.0) then
         ls_homflag=0
       else if (homflag.eq.1) then
         ls_homflag=1
       else
        print *,"homflag invalid in override ls bc"
        stop
       endif

       return
       end

       subroutine FORT_OVERRIDEPBC(homflag,project_option)
       use probcommon_module
       IMPLICIT NONE

       INTEGER_T homflag,project_option


       if ((project_option.eq.0).or. &
           (project_option.eq.1).or. &
           (project_option.eq.10).or. &
           (project_option.eq.13).or. & !FSI_material_exists 1st project
           (project_option.eq.11).or. & !FSI_material_exists 2nd project
           (project_option.eq.12)) then  ! pressure extension
        if (homflag.eq.0) then
         pres_homflag=0
        else if (homflag.eq.1) then
         pres_homflag=1
        else
         print *,"homflag invalid in override pbc"
         stop
        endif
       else if (project_option.eq.3) then ! viscosity
        if (homflag.eq.0) then
         vel_homflag=0
        else if (homflag.eq.1) then
         vel_homflag=1
        else
         print *,"homflag invalid in override pbc 2"
         stop
        endif
       else if (project_option.eq.2) then  ! temperature
        if (homflag.eq.0) then
         temp_homflag=0
        else if (homflag.eq.1) then
         temp_homflag=1
        else
         print *,"homflag invalid in override pbc 3"
         stop
        endif
       else if ((project_option.ge.100).and. &
                (project_option.lt.100+num_species_var)) then
        if (homflag.eq.0) then
         species_homflag=0
        else if (homflag.eq.1) then
         species_homflag=1
        else
         print *,"homflag invalid in override pbc 4"
         stop
        endif
       else 
        print *,"project_option invalid in override pbc"
        stop
       endif

       return
       end subroutine FORT_OVERRIDEPBC


       subroutine FORT_SET_PERIODIC_VAR(periodic_in)
       use probf90_module

       IMPLICIT NONE

       INTEGER_T periodic_in(SDIM)
       INTEGER_T dir

       do dir=1,SDIM
        fort_is_periodic(dir)=periodic_in(dir)
        if ((fort_is_periodic(dir).ne.0).and. &
            (fort_is_periodic(dir).ne.1)) then
         print *,"fort_is_periodic invalid"
         stop
        endif
       enddo

       end subroutine FORT_SET_PERIODIC_VAR
     
       subroutine FORT_OVERRIDE( &
         ccmax_level, &
         ccbfact_space_order, &
         ccbfact_time_order, &
         ccprescribe_temperature_outflow, &
         rz_flag, &
         ccFSI_flag, &
         ccZEYU_DCA_SELECT, &
         ccinvert_solid_levelset, &
         ccdenfact, &
         ccvelfact, &
         ccn_sites, &
         ccnucleation_init_time, &
         ccpos_sites, &
         ccxblob,ccyblob,cczblob,ccradblob, &
         ccxblob2,ccyblob2,cczblob2,ccradblob2, &
         ccxblob3,ccyblob3,cczblob3,ccradblob3, &
         ccxblob4,ccyblob4,cczblob4,ccradblob4, &
         ccxblob5,ccyblob5,cczblob5,ccradblob5, &
         ccxblob6,ccyblob6,cczblob6,ccradblob6, &
         ccxblob7,ccyblob7,cczblob7,ccradblob7, &
         ccxblob8,ccyblob8,cczblob8,ccradblob8, &
         ccxblob9,ccyblob9,cczblob9,ccradblob9, &
         ccxblob10,ccyblob10,cczblob10,ccradblob10, &
         ccxactive,ccyactive,cczactive, &
         ccractivex, &
         ccractivey, &
         ccractivez, &
         ccprobtype, &
         ccadv_dir, &
         ccadv_vel, &
         ccaxis_dir, &
         ccrgasinlet, &
         ccvinletgas, &
         cctwall, &
         ccadvbot, &
         ccinflow_pressure, &
         ccoutflow_pressure, &
         ccperiod_time, &
         ccproblox,ccprobloy,ccprobloz, &
         ccprobhix,ccprobhiy,ccprobhiz, &
         ccnum_species_var, &
         ccnum_materials_viscoelastic, &
         ccnum_state_material, &
         ccnum_state_base, &
         ccngeom_raw, &
         ccngeom_recon, &
         ccfortran_max_num_materials, &
         ccfort_max_num_eos, &
         ccnum_materials, &
         ccnum_materials_vel, &
         ccnum_materials_scalar_solve, &
         ccmaterial_type, &
         ccnten, &
         ccdrhodt, &
         ccdrhodz, &
         cctempconst, &
         ccinitial_temperature, &
         cctempcutoff, &
         cctempcutoffmax, &
         ccstiffPINF, &
         ccstiffCP, &
         ccstiffGAMMA, &
         ccdenconst, &
         ccden_floor, &
         ccden_ceiling, &
         cccavdenconst, &
         ccviscconst, &
         ccviscconst_eddy, &
         ccviscosity_state_model, &
         ccelastic_viscosity, &
         ccheatviscconst, &
         ccprerecalesce_heatviscconst, &
         ccprerecalesce_viscconst, &
         ccprerecalesce_stiffCP, &
         ccspeciesconst, &
         ccspeciesviscconst, &
         cctension, &
         cctension_slope, &
         cctension_T0, &
         cctension_min, &
         ccprefreeze_tension, &
         ccMUSHY_THICK, &
         ccgravity, &
         ccgravity_dir, &
         ccinvert_gravity, &
         ccstop_time, &
         ioproc)
       use LegendreNodes
       use probf90_module
       use global_utility_module
       use geometry_intersect_module
       use hydrateReactor_module
       use unimaterialChannel_module
       use shockdrop
       use USERDEF_module
       use CAV3D_module
       use HELIX_module
       use TSPRAY_module
       use CAV2Dstep_module
       use ZEYU_droplet_impact_module
       use STUB_module
       use GENERAL_PHASE_CHANGE_module
       use ICE_ON_SUBSTRATE_module
       use SIMPLE_PALMORE_DESJARDINS_module
       use MITSUHIRO_MELTING_module
       use CRYOGENIC_TANK1_module
       use flexible_plate_impact_module
       use CONE3D_module
       use WAVY_Channel_module
       use rigid_FSI_module

       IMPLICIT NONE

       INTEGER_T ccmax_level
       INTEGER_T ccbfact_space_order(0:ccmax_level)
       INTEGER_T ccbfact_time_order
       INTEGER_T ccnum_materials

       INTEGER_T ccnten
       REAL_T ccMUSHY_THICK
       REAL_T ccgravity
       INTEGER_T ccgravity_dir
       INTEGER_T ccinvert_gravity
       INTEGER_T ccFSI_flag(ccnum_materials)
       INTEGER_T ccZEYU_DCA_SELECT
       INTEGER_T ccinvert_solid_levelset
       INTEGER_T ccprescribe_temperature_outflow
       INTEGER_T rz_flag,ioproc
       INTEGER_T ccprobtype,ccadv_dir,ccaxis_dir

       REAL_T ccdenfact,ccvelfact
       REAL_T ccxblob,ccyblob,cczblob,ccradblob
       REAL_T ccxblob2,ccyblob2,cczblob2,ccradblob2
       REAL_T ccxblob3,ccyblob3,cczblob3,ccradblob3
       REAL_T ccxblob4,ccyblob4,cczblob4,ccradblob4
       REAL_T ccxblob5,ccyblob5,cczblob5,ccradblob5
       REAL_T ccxblob6,ccyblob6,cczblob6,ccradblob6
       REAL_T ccxblob7,ccyblob7,cczblob7,ccradblob7
       REAL_T ccxblob8,ccyblob8,cczblob8,ccradblob8
       REAL_T ccxblob9,ccyblob9,cczblob9,ccradblob9
       REAL_T ccxblob10,ccyblob10,cczblob10,ccradblob10
       REAL_T ccxactive,ccyactive,cczactive
       REAL_T ccractivex,ccractivey,ccractivez
       REAL_T ccadv_vel,ccrgasinlet
       REAL_T ccvinletgas,cctwall
       REAL_T ccadvbot
       REAL_T ccinflow_pressure
       REAL_T ccoutflow_pressure
       REAL_T ccperiod_time
       REAL_T ccproblox,ccprobloy,ccprobloz
       REAL_T ccprobhix,ccprobhiy,ccprobhiz
       REAL_T ccstop_time

       INTEGER_T ccnum_species_var

       INTEGER_T ccnum_materials_viscoelastic
       INTEGER_T nelastic

       INTEGER_T ccnum_state_material
       INTEGER_T ccnum_state_base
       INTEGER_T ccngeom_raw
       INTEGER_T ccngeom_recon
       INTEGER_T ccfortran_max_num_materials
       INTEGER_T ccfort_max_num_eos
       INTEGER_T ccnum_materials_vel
       INTEGER_T ccnum_materials_scalar_solve

       INTEGER_T ccmaterial_type(ccnum_materials)
       REAL_T ccdrhodt(ccnum_materials)
       REAL_T ccdrhodz(ccnum_materials)
       REAL_T cctempconst(ccnum_materials)
       REAL_T ccinitial_temperature(ccnum_materials)
       REAL_T cctempcutoff(ccnum_materials)
       REAL_T cctempcutoffmax(ccnum_materials)
       REAL_T ccstiffPINF(ccnum_materials)
       REAL_T ccstiffCP(ccnum_materials)
       REAL_T ccstiffGAMMA(ccnum_materials)
       REAL_T ccdenconst(ccnum_materials)
       REAL_T ccden_floor(ccnum_materials)
       REAL_T ccden_ceiling(ccnum_materials)
       REAL_T cccavdenconst(ccnum_materials)
       REAL_T ccviscconst(ccnum_materials)
       REAL_T ccviscconst_eddy(ccnum_materials)
       INTEGER_T ccviscosity_state_model(ccnum_materials)
       REAL_T ccelastic_viscosity(ccnum_materials)
       REAL_T ccheatviscconst(ccnum_materials)
       REAL_T ccprerecalesce_heatviscconst(ccnum_materials)
       REAL_T ccprerecalesce_viscconst(ccnum_materials)
       REAL_T ccprerecalesce_stiffCP(ccnum_materials)
       REAL_T ccspeciesconst((ccnum_species_var+1)*ccnum_materials)
       REAL_T ccspeciesviscconst((ccnum_species_var+1)*ccnum_materials)
       REAL_T cctension(ccnten)
       REAL_T cctension_slope(ccnten)
       REAL_T cctension_T0(ccnten)
       REAL_T cctension_min(ccnten)
       REAL_T ccprefreeze_tension(ccnten)

       INTEGER_T ccn_sites
       REAL_T ccnucleation_init_time
       REAL_T ccpos_sites(400)

       character*12 namestr1
       character*13 namestr2
       INTEGER_T i

       INTEGER_T im,iten
       INTEGER_T nten
       INTEGER_T level,bfactmax
       REAL_T :: massfrac_parm(ccnum_species_var+1)

       probtype=ccprobtype
       num_materials=ccnum_materials

! USER DEFINED (used by "is_in_probtype_list")
! IN ORDER TO ADD A NEW TEST PROBLEM:
! 1. increment probtype_list_size by 1.
! 2. set used_probtypes( <new value for probtype_list_size> ) = new_probtype
! 3. a) link template subroutine names to new module names 
!       (see probtype.eq.2002 below for an example)
!    b) add appropriate "use" command to the beginning of this routine. 
! 4. create new module file (e.g. by copying an existing module file)
! 5. update Make.package accordingly (2 places)
! 6. create inputs file
       probtype_list_size=6
       used_probtypes(1)=2000 ! flexible_plate_impact
       used_probtypes(2)=421  ! CRYOGENIC_TANK1
       used_probtypes(3)=414  ! MITSUHIRO_MELTING
       used_probtypes(4)=2001 ! ICE_ON_SUBSTRATE
       used_probtypes(5)=2002 ! 1D TEST FROM PALMORE and Desjardins
       used_probtypes(6)=55   ! GENERAL_PHASE_CHANGE

       SUB_INIT_MODULE=>INIT_STUB_MODULE
       SUB_LS=>STUB_LS
       SUB_VEL=>STUB_VEL
       SUB_EOS=>EOS_STUB
       SUB_SOUNDSQR=>SOUNDSQR_STUB
       SUB_INTERNAL=>INTERNAL_STUB
       SUB_TEMPERATURE=>TEMPERATURE_STUB
       SUB_PRES=>STUB_PRES
       SUB_STATE=>STUB_STATE
       SUB_LS_BC=>STUB_LS_BC
       SUB_VEL_BC=>STUB_VEL_BC
       SUB_PRES_BC=>STUB_PRES_BC
       SUB_STATE_BC=>STUB_STATE_BC
       SUB_HEATSOURCE=>STUB_HEATSOURCE
       SUB_EB_heat_source=>STUB_EB_heat_source
       SUB_microcell_heat_coeff=>STUB_microcell_heat_coeff
       SUB_velfreestream=>STUB_velfreestream
       SUB_nucleation=>STUB_nucleation
       SUB_CFL_HELPER=>STUB_CFL_HELPER
       SUB_hydro_pressure_density=>STUB_hydro_pressure_density

       if (probtype.eq.421) then
        SUB_INIT_MODULE=>INIT_CRYOGENIC_TANK1_MODULE
        SUB_LS=>CRYOGENIC_TANK1_LS
        SUB_VEL=>CRYOGENIC_TANK1_VEL
        SUB_EOS=>EOS_CRYOGENIC_TANK1
        SUB_SOUNDSQR=>SOUNDSQR_CRYOGENIC_TANK1
        SUB_INTERNAL=>INTERNAL_CRYOGENIC_TANK1
        SUB_TEMPERATURE=>TEMPERATURE_CRYOGENIC_TANK1
        SUB_PRES=>CRYOGENIC_TANK1_PRES
        SUB_STATE=>CRYOGENIC_TANK1_STATE
        SUB_LS_BC=>CRYOGENIC_TANK1_LS_BC
        SUB_VEL_BC=>CRYOGENIC_TANK1_VEL_BC
        SUB_PRES_BC=>CRYOGENIC_TANK1_PRES_BC
        SUB_STATE_BC=>CRYOGENIC_TANK1_STATE_BC
        SUB_HEATSOURCE=>CRYOGENIC_TANK1_HEATSOURCE
       else if (probtype.eq.414) then
        SUB_INIT_MODULE=>INIT_MITSUHIRO_MELTING_MODULE
        SUB_LS=>MITSUHIRO_MELTING_LS
        SUB_VEL=>MITSUHIRO_MELTING_VEL
        SUB_EOS=>EOS_MITSUHIRO_MELTING
        SUB_SOUNDSQR=>SOUNDSQR_MITSUHIRO_MELTING
        SUB_INTERNAL=>INTERNAL_MITSUHIRO_MELTING
        SUB_TEMPERATURE=>TEMPERATURE_MITSUHIRO_MELTING
        SUB_PRES=>MITSUHIRO_MELTING_PRES
        SUB_STATE=>MITSUHIRO_MELTING_STATE
        SUB_LS_BC=>MITSUHIRO_MELTING_LS_BC
        SUB_VEL_BC=>MITSUHIRO_MELTING_VEL_BC
        SUB_PRES_BC=>MITSUHIRO_MELTING_PRES_BC
        SUB_STATE_BC=>MITSUHIRO_MELTING_STATE_BC
        SUB_HEATSOURCE=>MITSUHIRO_MELTING_HEATSOURCE
       else if (probtype.eq.2001) then
        SUB_INIT_MODULE=>INIT_ICE_ON_SUBSTRATE_MODULE
        SUB_LS=>ICE_ON_SUBSTRATE_LS
        SUB_VEL=>ICE_ON_SUBSTRATE_VEL
        SUB_EOS=>EOS_ICE_ON_SUBSTRATE
        SUB_SOUNDSQR=>SOUNDSQR_ICE_ON_SUBSTRATE
        SUB_INTERNAL=>INTERNAL_ICE_ON_SUBSTRATE
        SUB_TEMPERATURE=>TEMPERATURE_ICE_ON_SUBSTRATE
        SUB_PRES=>ICE_ON_SUBSTRATE_PRES
        SUB_STATE=>ICE_ON_SUBSTRATE_STATE
        SUB_LS_BC=>ICE_ON_SUBSTRATE_LS_BC
        SUB_VEL_BC=>ICE_ON_SUBSTRATE_VEL_BC
        SUB_PRES_BC=>ICE_ON_SUBSTRATE_PRES_BC
        SUB_STATE_BC=>ICE_ON_SUBSTRATE_STATE_BC
        SUB_HEATSOURCE=>ICE_ON_SUBSTRATE_HEATSOURCE
       else if (probtype.eq.2002) then
        SUB_INIT_MODULE=>INIT_SIMPLE_PALMORE_DESJARDINS_MODULE
        SUB_LS=>SIMPLE_PALMORE_DESJARDINS_LS
        SUB_VEL=>SIMPLE_PALMORE_DESJARDINS_VEL
        SUB_EOS=>EOS_SIMPLE_PALMORE_DESJARDINS
        SUB_SOUNDSQR=>SOUNDSQR_SIMPLE_PALMORE_DESJARDINS
        SUB_INTERNAL=>INTERNAL_SIMPLE_PALMORE_DESJARDINS
        SUB_TEMPERATURE=>TEMPERATURE_SIMPLE_PALMORE_DESJARDINS
        SUB_PRES=>SIMPLE_PALMORE_DESJARDINS_PRES
        SUB_STATE=>SIMPLE_PALMORE_DESJARDINS_STATE
        SUB_LS_BC=>SIMPLE_PALMORE_DESJARDINS_LS_BC
        SUB_VEL_BC=>SIMPLE_PALMORE_DESJARDINS_VEL_BC
        SUB_PRES_BC=>SIMPLE_PALMORE_DESJARDINS_PRES_BC
        SUB_STATE_BC=>SIMPLE_PALMORE_DESJARDINS_STATE_BC
        SUB_HEATSOURCE=>SIMPLE_PALMORE_DESJARDINS_HEATSOURCE
        SUB_SUMINT=>SIMPLE_PALMORE_DESJARDINS_SUMINT ! compare with analytical
       else if (probtype.eq.2000) then
        SUB_INIT_MODULE=>INIT_flexible_plate_impact_MODULE
        SUB_LS=>flexible_plate_impact_LS
        SUB_VEL=>flexible_plate_impact_VEL
        SUB_EOS=>EOS_flexible_plate_impact
        SUB_SOUNDSQR=>SOUNDSQR_flexible_plate_impact
        SUB_INTERNAL=>INTERNAL_flexible_plate_impact
        SUB_TEMPERATURE=>TEMPERATURE_flexible_plate_impact
        SUB_PRES=>flexible_plate_impact_PRES
        SUB_STATE=>flexible_plate_impact_STATE
        SUB_LS_BC=>flexible_plate_impact_LS_BC
        SUB_VEL_BC=>flexible_plate_impact_VEL_BC
        SUB_PRES_BC=>flexible_plate_impact_PRES_BC
        SUB_STATE_BC=>flexible_plate_impact_STATE_BC
        SUB_HEATSOURCE=>flexible_plate_impact_HEATSOURCE
       else if (probtype.eq.55) then
        SUB_INIT_MODULE=>INIT_GENERAL_PHASE_CHANGE_MODULE
        SUB_LS=>GENERAL_PHASE_CHANGE_LS
        SUB_VEL=>GENERAL_PHASE_CHANGE_VEL
        SUB_EOS=>EOS_GENERAL_PHASE_CHANGE
        SUB_SOUNDSQR=>SOUNDSQR_GENERAL_PHASE_CHANGE
        SUB_INTERNAL=>INTERNAL_GENERAL_PHASE_CHANGE
        SUB_TEMPERATURE=>TEMPERATURE_GENERAL_PHASE_CHANGE
        SUB_PRES=>GENERAL_PHASE_CHANGE_PRES
        SUB_STATE=>GENERAL_PHASE_CHANGE_STATE
        SUB_LS_BC=>GENERAL_PHASE_CHANGE_LS_BC
        SUB_VEL_BC=>GENERAL_PHASE_CHANGE_VEL_BC
        SUB_PRES_BC=>GENERAL_PHASE_CHANGE_PRES_BC
        SUB_STATE_BC=>GENERAL_PHASE_CHANGE_STATE_BC
        SUB_HEATSOURCE=>GENERAL_PHASE_CHANGE_HEATSOURCE
        SUB_EB_heat_source=>GENERAL_PHASE_CHANGE_EB_heat_source
        SUB_microcell_heat_coeff=>GENERAL_PHASE_CHANGE_microcell_heat_coeff
        SUB_velfreestream=>GENERAL_PHASE_CHANGE_velfreestream
        SUB_nucleation=>GENERAL_PHASE_CHANGE_nucleation
        SUB_CFL_HELPER=>GENERAL_PHASE_CHANGE_CFL_HELPER
        SUB_hydro_pressure_density=>GENERAL_PHASE_CHANGE_hydro_pressure_density
       else
        ! assign null routines here that would cause the program to abort
        ! if called.
        SUB_INIT_MODULE=>NULL()
        SUB_LS=>NULL()
        SUB_VEL=>NULL()
        SUB_EOS=>NULL()
        SUB_SOUNDSQR=>NULL()
        SUB_INTERNAL=>NULL()
        SUB_TEMPERATURE=>NULL()
        SUB_PRES=>NULL()
        SUB_STATE=>NULL()
        SUB_LS_BC=>NULL()
        SUB_VEL_BC=>NULL()
        SUB_PRES_BC=>NULL()
        SUB_STATE_BC=>NULL()
        SUB_HEATSOURCE=>NULL()
        SUB_EB_heat_source=>NULL()
        SUB_microcell_heat_coeff=>NULL()
        SUB_velfreestream=>NULL()
        SUB_nucleation=>NULL()
        SUB_CFL_HELPER=>NULL()
        SUB_hydro_pressure_density=>NULL()
       endif

       global_pressure_scale=one
       global_velocity_scale=one

       fort_max_level=ccmax_level
       do level=0,fort_max_level
        bfact_space_order(level)=ccbfact_space_order(level)
       enddo
       bfact_time_order=ccbfact_time_order

       if (fort_max_level.lt.0) then
        print *,"fort_max_level invalid"
        stop
       endif
       do level=0,fort_max_level
        if (bfact_space_order(level).lt.1) then
         print *,"bfact_space_order invalid: ",bfact_space_order(level)
         stop
        endif
       enddo
       if (bfact_time_order.lt.1) then
        print *,"bfact_time_order invalid"
        stop
       endif
       bfactmax=16
       call sanity_check(bfactmax+2)
       call init_cache(bfactmax+2)

       if (ioproc.eq.1) then
        print *,"LEGEND FOR SPECTRAL ELEMENT NODES"
        print *,"0 Legendre Nodes"
        print *,"1 Clenshaw Curtis Nodes (Chebychev)"
        print *,"SPTYPE= ",SPTYPE
        print *,"TMTYPE= ",TMTYPE
       else if (ioproc.eq.0) then
        ! do nothing
       else
        print *,"ioproc invalid"
        stop
       endif
        
       problox=ccproblox
       probloy=ccprobloy
       probloz=ccprobloz
       probhix=ccprobhix
       probhiy=ccprobhiy
       probhiz=ccprobhiz

       if (SDIM.eq.2) then
        probhiz=probhiy
        probloz=probloy
       endif

       problenx=probhix-problox
       probleny=probhiy-probloy
       problenz=probhiz-probloz

       if ((problenx.le.zero).or. &
           (probleny.le.zero).or. &
           (problenz.le.zero)) then
        print *,"problenx or probleny or problenz invalid"
        stop
       endif

       fort_stop_time=ccstop_time

       prescribe_temperature_outflow= &
         ccprescribe_temperature_outflow

       levelrz=rz_flag
       denfact=ccdenfact
       velfact=ccvelfact

       n_sites=ccn_sites
       nucleation_init_time=ccnucleation_init_time

       if (nucleation_init_time.lt.zero) then
        print *,"nucleation_init_time.lt.zero"
        stop
       endif

       if ((n_sites.lt.0).or.(4*n_sites.gt.400)) then
        print *,"n_sites invalid"
        stop
       endif
       do i=1,4*n_sites
        pos_sites(i)=ccpos_sites(i)
       enddo
       
       xblob=ccxblob
       yblob=ccyblob
       zblob=cczblob
       radblob=ccradblob

       xblob2=ccxblob2
       yblob2=ccyblob2
       zblob2=cczblob2
       radblob2=ccradblob2

       xblob3=ccxblob3
       yblob3=ccyblob3
       zblob3=cczblob3
       radblob3=ccradblob3

       xblob4=ccxblob4
       yblob4=ccyblob4
       zblob4=cczblob4
       radblob4=ccradblob4

       xblob5=ccxblob5
       yblob5=ccyblob5
       zblob5=cczblob5
       radblob5=ccradblob5

       xblob6=ccxblob6
       yblob6=ccyblob6
       zblob6=cczblob6
       radblob6=ccradblob6

       xblob7=ccxblob7
       yblob7=ccyblob7
       zblob7=cczblob7
       radblob7=ccradblob7

       xblob8=ccxblob8
       yblob8=ccyblob8
       zblob8=cczblob8
       radblob8=ccradblob8

       xblob9=ccxblob9
       yblob9=ccyblob9
       zblob9=cczblob9
       radblob9=ccradblob9

       xblob10=ccxblob10
       yblob10=ccyblob10
       zblob10=cczblob10
       radblob10=ccradblob10

       xblobarr(1)=xblob 
       yblobarr(1)=yblob 
       zblobarr(1)=zblob 
       radblobarr(1)=radblob 

       xblobarr(2)=xblob2 
       yblobarr(2)=yblob2 
       zblobarr(2)=zblob2
       radblobarr(2)=radblob2 

       xblobarr(3)=xblob3 
       yblobarr(3)=yblob3 
       zblobarr(3)=zblob3
       radblobarr(3)=radblob3 

       xblobarr(4)=xblob4 
       yblobarr(4)=yblob4 
       zblobarr(4)=zblob4
       radblobarr(4)=radblob4 

       xblobarr(5)=xblob5 
       yblobarr(5)=yblob5 
       zblobarr(5)=zblob5
       radblobarr(5)=radblob5 

       xblobarr(6)=xblob6 
       yblobarr(6)=yblob6 
       zblobarr(6)=zblob6
       radblobarr(6)=radblob6 

       xblobarr(7)=xblob7 
       yblobarr(7)=yblob7 
       zblobarr(7)=zblob7
       radblobarr(7)=radblob7 

       xblobarr(8)=xblob8 
       yblobarr(8)=yblob8 
       zblobarr(8)=zblob8
       radblobarr(8)=radblob8 

       xblobarr(9)=xblob9 
       yblobarr(9)=yblob9 
       zblobarr(9)=zblob9
       radblobarr(9)=radblob9 

       xblobarr(10)=xblob10 
       yblobarr(10)=yblob10 
       zblobarr(10)=zblob10
       radblobarr(10)=radblob10 

       xactive=ccxactive
       yactive=ccyactive
       zactive=cczactive
       ractivex=ccractivex
       ractivey=ccractivey
       ractivez=ccractivez

       adv_dir=ccadv_dir
       adv_vel=ccadv_vel
       axis_dir=ccaxis_dir
       rgasinlet=ccrgasinlet
       vinletgas=ccvinletgas
       twall=cctwall
       advbot=ccadvbot
       inflow_pressure=ccinflow_pressure
       outflow_pressure=ccoutflow_pressure
       period_time=ccperiod_time

       fort_max_num_eos=ccfort_max_num_eos

       do im=1,num_materials

        fort_material_type(im)=ccmaterial_type(im)
        FSI_flag(im)=ccFSI_flag(im)
        if (fort_material_type(im).eq.0) then
         ! do nothing
        else if (fort_material_type(im).eq.999) then
         if ((FSI_flag(im).ne.1).and. &
             (FSI_flag(im).ne.2).and. &
             (FSI_flag(im).ne.4)) then
          print *,"FSI_flag invalid"
          stop
         endif
        else if ((fort_material_type(im).gt.0).and. &
                 (fort_material_type(im).le.fort_max_num_eos)) then
         ! do nothing
        else
         print *,"fort_material_type invalid"
         stop
        endif

       enddo ! im=1..num_materials

       fort_ZEYU_DCA_SELECT=ccZEYU_DCA_SELECT

       invert_solid_levelset=ccinvert_solid_levelset
       if ((invert_solid_levelset.ne.0).and. &
           (invert_solid_levelset.ne.1)) then
        print *,"invert_solid_levelset invalid in override"
        stop
       endif

       num_species_var=ccnum_species_var
       num_materials_viscoelastic=ccnum_materials_viscoelastic
       fort_max_num_materials=ccfortran_max_num_materials
       num_materials_vel=ccnum_materials_vel
       num_materials_scalar_solve=ccnum_materials_scalar_solve

       num_state_base=ccnum_state_base
       if (num_state_base.ne.2) then
        print *,"num_state_base invalid 60"
        stop
       endif
       num_state_material=num_state_base  ! den,T
       num_state_material=num_state_material+num_species_var

       if (num_state_material.ne.ccnum_state_material) then
        print *,"ccnum_state_material invalid"
        stop
       endif

       if ((num_species_var.lt.0).or. &
           (num_materials_viscoelastic.lt.0).or. &
           (num_materials_viscoelastic.gt.num_materials).or. &
           (fort_max_num_materials.ne.MAX_NUM_MATERIALS).or. &
           (num_materials.lt.1).or. &
           (num_materials.gt.fort_max_num_materials).or. &
           (num_materials.gt.100).or. &
           (num_materials_vel.ne.1).or. &
           ((num_materials_scalar_solve.ne.1).and. &
            (num_materials_scalar_solve.ne.num_materials)) ) then
        print *,"material parameters illegal"
        stop
       endif

       ngeom_raw=ccngeom_raw
       ngeom_recon=ccngeom_recon

       if (ngeom_recon.ne.2*SDIM+3) then
        print *,"ngeom_recon invalid"
        stop
       endif
       if (ngeom_raw.ne.SDIM+1) then
        print *,"ngeom_raw invalid"
        stop
       endif

       if (ioproc.eq.1) then

        print *,"fort_max_level= ",fort_max_level
        do level=0,fort_max_level
         print *,"level,bfact_space_order ",level,bfact_space_order(level)
        enddo
        print *,"bfact_time_order ",bfact_time_order

        print *,"fort material parameters"
        print *,"numspec,num_mat_visc,max_num_materials,num_materials ", &
         num_species_var,num_materials_viscoelastic, &
         fort_max_num_materials,num_materials
        print *,"num_materials_vel ",num_materials_vel
        print *,"num_materials_scalar_solve ",num_materials_scalar_solve
        print *,"fort_max_num_eos ",fort_max_num_eos
        print *,"ngeom_raw ",ngeom_raw
        print *,"ngeom_recon ",ngeom_recon
        print *,"fort: num_state_material ",num_state_material
        print *,"fort: num_state_base ",num_state_base

       else if (ioproc.eq.0) then
        ! do nothing
       else
        print *,"ioproc invalid"
        stop
       endif

       do im=1,num_species_var*num_materials
        fort_speciesconst(im)=ccspeciesconst(im)
        fort_speciesviscconst(im)=ccspeciesviscconst(im)
       enddo

       do im=1,num_materials

        fort_drhodt(im)=ccdrhodt(im)
        fort_drhodz(im)=ccdrhodz(im)
        fort_tempconst(im)=cctempconst(im)
        fort_initial_temperature(im)=ccinitial_temperature(im)
        fort_tempcutoff(im)=cctempcutoff(im) ! default 1.0E-8
        fort_tempcutoffmax(im)=cctempcutoffmax(im) ! default 1.0D+99
        fort_stiffPINF(im)=ccstiffPINF(im)
        fort_stiffCP(im)=ccstiffCP(im)
        fort_stiffGAMMA(im)=ccstiffGAMMA(im)
        fort_denconst(im)=ccdenconst(im)
        fort_density_floor(im)=ccden_floor(im)
        fort_density_ceiling(im)=ccden_ceiling(im)
        fort_cavdenconst(im)=cccavdenconst(im)
        fort_viscconst(im)=ccviscconst(im)
        fort_viscconst_eddy(im)=ccviscconst_eddy(im)
        fort_viscosity_state_model(im)= &
          ccviscosity_state_model(im)
        fort_elastic_viscosity(im)=ccelastic_viscosity(im)
        fort_heatviscconst(im)=ccheatviscconst(im)
        fort_prerecalesce_heatviscconst(im)=ccprerecalesce_heatviscconst(im)
        fort_prerecalesce_viscconst(im)=ccprerecalesce_viscconst(im)
        fort_prerecalesce_stiffCP(im)=ccprerecalesce_stiffCP(im)

        fort_im_elastic_map(im)=-1

       enddo ! im=1..num_materials

       nelastic=0
       do im=1,num_materials
        if (fort_elastic_viscosity(im).eq.zero) then
         ! do nothing
        else if (fort_elastic_viscosity(im).gt.zero) then
         nelastic=nelastic+1
         fort_im_elastic_map(nelastic)=im-1
        else
         print *,"fort_elastic_viscosity(im) invalid"
         stop
        endif
       enddo ! im=1..num_materials

       if (nelastic.ne.num_materials_viscoelastic) then
        print *,"nelastic.ne.num_materials_viscoelastic"
        stop
       endif

       nten=( (num_materials-1)*(num_materials-1)+ &
          num_materials-1 )/2
       if (nten.ne.ccnten) then
        print *,"nten or ccnten invalid"
        print *,"nten=",nten
        print *,"ccnten=",ccnten
        stop
       endif
       if (nten.gt.999) then
        print *,"too many surface tension coefficients, increase max"
        print *,"nten= ",nten
        stop
       endif
       do iten=1,nten
        fort_tension(iten)=cctension(iten)
        fort_tension_slope(iten)=cctension_slope(iten)
        fort_tension_T0(iten)=cctension_T0(iten)
        fort_tension_min(iten)=cctension_min(iten)
        fort_prefreeze_tension(iten)=ccprefreeze_tension(iten)
       enddo

       if (ioproc.eq.1) then
        print *,"n_sites= ",n_sites
        do i=1,4*n_sites
         print *,"i,pos_sites=",i,pos_sites(i)
        enddo 
        do im=1,num_materials
         print *,"im,mat type ",im,fort_material_type(im)
         print *,"im,drhodt ",im,fort_drhodt(im)
         print *,"im,drhodz ",im,fort_drhodz(im)
         print *,"im,temp ",im,fort_tempconst(im)
         print *,"im,initial_temp ",im,fort_initial_temperature(im)
         print *,"im,tempcutoff ",im,fort_tempcutoff(im)
         print *,"im,tempcutoffmax ",im,fort_tempcutoffmax(im)
         print *,"im,stiffPINF ",im,fort_stiffPINF(im)
         print *,"im,stiffCP ",im,fort_stiffCP(im)
         print *,"im,stiffGAMMA ",im,fort_stiffGAMMA(im)
         print *,"im,den ",im,fort_denconst(im)
         print *,"im,den_floor ",im,fort_density_floor(im)
         print *,"im,den_ceiling ",im,fort_density_ceiling(im)
         print *,"im,cavden ",im,fort_cavdenconst(im)
         print *,"im,visc ",im,fort_viscconst(im)
         print *,"im,visc_eddy ",im,fort_viscconst_eddy(im)
         print *,"im,viscosity_state_model ",im, &
          fort_viscosity_state_model(im)
         print *,"im,fort_elastic_viscosity ",im,fort_elastic_viscosity(im)
         print *,"im,fort_im_elastic_map ",im,fort_im_elastic_map(im)
         print *,"im,heatvisc ",im,fort_heatviscconst(im)
         print *,"im,prerecalesce_heatvisc ",im, &
          fort_prerecalesce_heatviscconst(im)
         print *,"im,prerecalesce_visc ",im, &
          fort_prerecalesce_viscconst(im)
         print *,"im,prerecalesce_cp ",im, &
          fort_prerecalesce_stiffCP(im)
        enddo ! im
        do im=1,num_species_var*num_materials
         print *,"im,species ",im,fort_speciesconst(im)
         print *,"im,speciesvisc ",im,fort_speciesviscconst(im)
        enddo

        do iten=1,nten
         print *,"iten,tension ",iten,fort_tension(iten)
         print *,"iten,tension_slope ",iten,fort_tension_slope(iten)
         print *,"iten,tension_T0 ",iten,fort_tension_T0(iten)
         print *,"iten,tension_min ",iten,fort_tension_min(iten)
         print *,"iten,prefreeze_tension ",iten,fort_prefreeze_tension(iten)
        enddo
       endif

       FORT_MUSHY_THICK=ccMUSHY_THICK

       gravity=ccgravity
       gravity_dir=ccgravity_dir
       invert_gravity=ccinvert_gravity

       call init_density_at_depth()

       pres_homflag=0
       vel_homflag=0
       temp_homflag=0
       species_homflag=0
       ls_homflag=1  ! default 90 degree contact angle.

       inflow_count=0
       outflow_count=0
       last_inflow_index=1
       last_outflow_index=1

       if (is_in_probtype_list().eq.1) then
 
        call SUB_INIT_MODULE()

       else if ((probtype.eq.110).and.(SDIM.eq.2)) then

        print *,"opening InflowBC.dat and OutflowBC.dat"
        namestr1='InflowBC.dat' 
        namestr2='OutflowBC.dat' 

        open(unit=11,file=namestr1)
        read(11,*) inflow_count
        print *,"inflow_count= ",inflow_count
        do i=1,inflow_count
         read(11,*) inflow_time(i),inflow_velocity(i), &
           inflow_elevation(i)
        enddo
        close(11)

        open(unit=12,file=namestr2)
        read(12,*) outflow_count
        print *,"outflow_count= ",outflow_count
        do i=1,outflow_count
         read(12,*) outflow_time(i),outflow_velocity(i), &
           outflow_elevation(i)
        enddo
        close(12)

        call shallow_water_solve()

        ! above: probtype==110
       else if ((probtype.eq.1).and. &
                ((axis_dir.eq.150).or. &
                 (axis_dir.eq.151))) then

        call shockdrop_init()

       else if (probtype.eq.411) then

        call INIT_CAV3D_MODULE()

       else if (probtype.eq.401) then

        call INIT_HELIX_MODULE()

       else if (probtype.eq.402) then

        call INIT_TSPRAY_MODULE()
       else if (probtype.eq.412) then

        call INIT_CAV2Dstep_MODULE()

       else if (probtype.eq.413) then

        call INIT_ZEYU_droplet_impact_MODULE()

       else if (probtype.eq.533) then

        call INIT_rigid_FSI_MODULE()

       else if (probtype.eq.311) then

        call INIT_USERDEF_MODULE()

       else if (probtype.eq.222) then

        call INIT_CONE3D_MODULE()

       else if (probtype.eq.915) then

        call INIT_WAVY_MODULE()

       else if (probtype.eq.199) then ! hydrate
        if (num_materials.ne.3) then
         print *,"num_materials invalid probtype=199"
         stop
        endif
        if (num_species_var.ne.1) then
         print *,"num_species_var invalid"
         stop
        endif
         ! 1=water 2=methane 3=hydrate
        call INIT_HYDRATE_MODULE( &
         fort_tempconst(1),fort_tempconst(3), &
         fort_tempconst(2), &
         fort_denconst(1),fort_denconst(3), &
         fort_denconst(2), &
         outflow_pressure, &
         probhiy,probhix, &
         yblob,yblob2) 
       
        ! in: subroutine FORT_OVERRIDE
       else if (probtype.eq.220) then
        if (num_materials.ne.3) then
         print *,"num_materials invalid probtype=220"
         stop
        endif
        if (num_species_var.ne.0) then
         print *,"num_species_var invalid probtype=220"
         stop
        endif
         ! 1=Material 2=ghost material 3=fiber
        call UNIMAT_INIT_MODULE( &
         fort_denconst(1), &
         fort_tempconst(1), &
         outflow_pressure, &
         velfact, &
         probhix, &
         probhiy) 
 
       else
        ! do nothing 
       endif

        ! this loop occurs after user defined initialization.
       do im=1,num_materials
        call init_massfrac_parm(fort_denconst(im),massfrac_parm,im)
        call INTERNAL_material(fort_denconst(im),massfrac_parm, &
            fort_tempconst(im), &
            fort_energyconst(im),fort_material_type(im),im)
        call INTERNAL_material(fort_denconst(im),massfrac_parm, &
            fort_tempcutoff(im), &
            fort_energycutoff(im),fort_material_type(im),im)
       enddo

       if (ioproc.eq.1) then
        do im=1,num_materials
         print *,"im,energy ",im,fort_energyconst(im)
         print *,"im,energycutoff ",im,fort_energycutoff(im)
        enddo
       else if (ioproc.ne.0) then
        print *,"ioproc invalid"
        stop
       endif

       if (ioproc.eq.1) then
        print *,"prescribe_temperature_outflow (fortran)= ", &
         prescribe_temperature_outflow
        print *,"density_at_depth ",density_at_depth

        print *,"fort: problox,y,z,hix,y,z ",problox,probloy,probloz, &
         probhix,probhiy,probhiz
        print *,"fort: problenx,y,z ",problenx,probleny,problenz

        if ((FORT_MUSHY_THICK.ge.one).and. &
            (FORT_MUSHY_THICK.le.four)) then
         ! do nothing
        else
         print *,"MUSHY_THICK invalid"
         stop
        endif

        if ((gravity_dir.lt.1).or.(gravity_dir.gt.SDIM).or. &
            (invert_gravity.lt.0).or.(invert_gravity.gt.1).or. &
            (ls_homflag.lt.0).or.(ls_homflag.gt.1).or. &
            (pres_homflag.lt.0).or.(pres_homflag.gt.1).or. &
            (vel_homflag.lt.0).or.(vel_homflag.gt.1).or. &
            (temp_homflag.lt.0).or.(temp_homflag.gt.1).or. &
            (species_homflag.lt.0).or.(species_homflag.gt.1).or. &
            (prescribe_temperature_outflow.lt.0).or. &
            (prescribe_temperature_outflow.gt.3)) then
         print *,"parameters invalid"
         stop
        endif

        print *,"fort:MUSHY_THICK ",FORT_MUSHY_THICK

        print *,"fort:gravity,gravity_dir,invert_gravity ",gravity, &
         gravity_dir,invert_gravity
        print *,"fort:pres,vel,temp,spec,ls homflag ",pres_homflag, &
         vel_homflag,temp_homflag,species_homflag,ls_homflag

        print *,"fort: stop_time ",fort_stop_time

        print *,"fort: rz ",levelrz
        do im=1,num_materials
         print *,"fort: im,FSI_flag ",im,FSI_flag(im)
        enddo
        print *,"fort: invert_solid_levelset ",invert_solid_levelset
        print *,"fort: denfact,velfact,xblob,yblob,zblob ", &
         denfact,velfact,xblob,yblob,zblob
        print *,"fort: radblob,probtype,adv_dir,adv_vel,axis_dir ", &
         radblob,probtype,adv_dir,adv_vel,axis_dir
        print *,"fort: xblob2,yblob2,zblob2,radblob2", &
         xblob2,yblob2,zblob2,radblob2
        print *,"fort: xblob3,yblob3,zblob3,radblob3", &
         xblob3,yblob3,zblob3,radblob3
        print *,"fort: xblob4,yblob4,zblob4,radblob4", &
         xblob4,yblob4,zblob4,radblob4
        print *,"fort: xblob5,yblob5,zblob5,radblob5", &
         xblob5,yblob5,zblob5,radblob5
        print *,"fort: xblob6,yblob6,zblob6,radblob6", &
         xblob6,yblob6,zblob6,radblob6
        print *,"fort: xblob7,yblob7,zblob7,radblob7", &
         xblob7,yblob7,zblob7,radblob7
        print *,"fort: xblob8,yblob8,zblob8,radblob8", &
         xblob8,yblob8,zblob8,radblob8
        print *,"fort: xblob9,yblob9,zblob9,radblob9", &
         xblob9,yblob9,zblob9,radblob9
        print *,"fort: xblob10,yblob10,zblob10,radblob10", &
         xblob10,yblob10,zblob10,radblob10

        print *,"fort: xactive,yactive,zactive,ractivexyz", &
         xactive,yactive,zactive,ractivex,ractivey,ractivez
        print *,"fort:vinletgas",vinletgas
        print *,"fort:rgasinlet",rgasinlet
        print *,"fort:advbot",advbot
        print *,"fort: inflow_pressure ",inflow_pressure
        print *,"fort: outflow_pressure ",outflow_pressure
        print *,"fort:period_time",period_time
        print *,"fort:twall",twall
        print *,"fort:fort_ZEYU_DCA_SELECT",fort_ZEYU_DCA_SELECT

        print *,"fort:end of override routine"

       else if (ioproc.ne.0) then
        print *,"ioproc invalid"
        stop
       endif

       do im=1,num_materials
        if (fort_material_type(im).eq.0) then
         ! do nothing
        else if (fort_material_type(im).eq.999) then
         ! do nothing
        else if ((fort_material_type(im).gt.0).and. &
                 (fort_material_type(im).le.fort_max_num_eos)) then
         call debug_EOS(im)
        else
         print *,"fort_material_type invalid"
         stop
        endif
       enddo ! im=1..num_materials
       
       return
       end subroutine FORT_OVERRIDE


      subroutine FORT_INITDATASOLID( &
       nmat, &
       nparts, &
       nFSI_sub, &
       nFSI, &
       ngrowFSI, &
       im_solid_map, &
       time, &
       tilelo,tilehi, &
       fablo,fabhi, &
       bfact, &
       solid,DIMS(solid), &
       dx,xlo,xhi)

      use probf90_module
      use global_distance_module
      use global_utility_module

      IMPLICIT NONE

      INTEGER_T nmat
      INTEGER_T nparts
      INTEGER_T nFSI_sub
      INTEGER_T nFSI
      INTEGER_T ngrowFSI
      INTEGER_T im_solid_map(nparts)
      REAL_T time
      INTEGER_T tilelo(SDIM),tilehi(SDIM)
      INTEGER_T fablo(SDIM),fabhi(SDIM)
      INTEGER_T bfact
      INTEGER_T growlo(3),growhi(3)
      INTEGER_T DIMDEC(solid)
      REAL_T    dx(SDIM)
      REAL_T    xlo(SDIM), xhi(SDIM)
      REAL_T    solid(DIMV(solid),nFSI)

      INTEGER_T i,j,k,dir
      REAL_T distsolid
      REAL_T temp_solid_mat
      REAL_T vel(SDIM)
      REAL_T xsten(-1:1,SDIM)
      INTEGER_T im
      INTEGER_T nhalf
      INTEGER_T partid
      INTEGER_T ibase

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif
      if ((nparts.lt.1).or.(nparts.ge.nmat)) then
       print *,"nparts invalid"
       stop
      endif
      if (nFSI_sub.ne.12) then
       print *,"nFSI_sub.ne.12"
       stop
      endif
      if (nFSI.ne.nparts*nFSI_sub) then
       print *,"nFSI.ne.nparts*nFSI_sub"
       stop
      endif
      if (ngrowFSI.ne.3) then
       print *,"ngrowFSI invalid"
       stop
      endif

      nhalf=1
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif

      if ((time.ge.zero).and.(time.le.1.0D+20)) then
       ! do nothing
      else if (time.ge.1.0D+20) then
       print *,"WARNING time.ge.1.0D+20 in initdata_solid"
      else if (time.lt.zero) then
       print *,"time invalid in initdata_solid"
       stop
      else
       print *,"time bust in initdata_solid"
       stop
      endif

      call checkbound(fablo,fabhi,DIMS(solid),ngrowFSI,-1,1301)

      if ((adv_dir.lt.1).or.(adv_dir.gt.2*SDIM+1)) then
       print *,"adv_dir invalid initdatasolid (10)"
       stop
      endif
      call growntilebox(tilelo,tilehi,fablo,fabhi,growlo,growhi,ngrowFSI) 

      do i=growlo(1),growhi(1)
      do j=growlo(2),growhi(2)
      do k=growlo(3),growhi(3)

       call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)

       do partid=1,nparts

        im=im_solid_map(partid)+1
        if ((im.lt.1).or.(im.gt.nmat)) then
         print *,"im invalid82"
         stop
        endif

        ibase=(partid-1)*nFSI_sub

        if (is_lag_part(nmat,im).eq.1) then

         if (FSI_flag(im).eq.1) then ! prescribed solid (EUL)
          call materialdistsolid(xsten(0,1),xsten(0,2),xsten(0,SDIM), &
            distsolid,time,im) 
          call velsolid(xsten(0,1),xsten(0,2),xsten(0,SDIM),vel,time,im,dx)
          call tempsolid(xsten(0,1),xsten(0,2),xsten(0,SDIM), &
           temp_solid_mat,time,im)
          solid(D_DECL(i,j,k),ibase+4)=distsolid
          solid(D_DECL(i,j,k),ibase+5)=temp_solid_mat
          do dir=1,SDIM
           solid(D_DECL(i,j,k),ibase+dir)=vel(dir)
          enddo
         else if ((FSI_flag(im).eq.2).or. & ! prescribed solid (CAD)
                  (FSI_flag(im).eq.4).or. & ! CTML FSI
                  (FSI_flag(im).eq.6).or. & ! ice (CAD)
                  (FSI_flag(im).eq.7)) then ! fluid (CAD)
          ! do nothing
         else
          print *,"FSI_flag invalid"
          stop
         endif

        else
         print *,"is_lag_part invalid FORT_INITDATASOLID"
         stop
        endif

       enddo ! partid=1..nparts

      enddo
      enddo
      enddo

      return
      end subroutine FORT_INITDATASOLID

       ! called when solidheat_flag=1,2  (not =0)
      subroutine FORT_INITSOLIDTEMP( &
       nmat, &
       nden, &
       time, &
       tilelo,tilehi, &
       fablo,fabhi, &
       bfact, &
       snew,DIMS(snew), &
       lsnew,DIMS(lsnew), &
       dx,xlo)
      use probf90_module
      use global_utility_module
      use global_distance_module

      IMPLICIT NONE

      INTEGER_T nmat
      INTEGER_T nden
      REAL_T time
      INTEGER_T tilelo(SDIM),tilehi(SDIM)
      INTEGER_T fablo(SDIM),fabhi(SDIM)
      INTEGER_T growlo(3),growhi(3)
      INTEGER_T bfact
      INTEGER_T DIMDEC(snew)
      INTEGER_T DIMDEC(lsnew)
      REAL_T    dx(SDIM)
      REAL_T    xlo(SDIM)
      REAL_T    snew(DIMV(snew),nden)
      REAL_T    lsnew(DIMV(lsnew),nmat*(SDIM+1))

      INTEGER_T i,j,k
      INTEGER_T im
      INTEGER_T im_solid_crit
      INTEGER_T tcomp
      REAL_T distsolid
      REAL_T disttest
      REAL_T temp_solid_mat
      REAL_T xsten(-1:1,SDIM)
      INTEGER_T nhalf
      INTEGER_T im_solid_thermal

      nhalf=1

      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif
      if (nden.ne.nmat*num_state_material) then
       print *,"nden invalid"
       stop
      endif

      if (num_state_base.ne.2) then
       print *,"num_state_base invalid"
       stop
      endif
      if (bfact.lt.1) then
       print *,"bfact out of range"
       stop
      endif

      if ((time.ge.zero).and.(time.le.1.0D+20)) then
       ! do nothing
      else if (time.ge.1.0D+20) then
       print *,"WARNING time.ge.1.0D+20 in initsolidtemp"
      else if (time.lt.zero) then
       print *,"time invalid in initsolidtemp"
       stop
      else
       print *,"time bust in initsolidtemp"
       stop
      endif

      call checkbound(fablo,fabhi,DIMS(snew),1,-1,1303)
      call checkbound(fablo,fabhi,DIMS(lsnew),1,-1,1303)

      im_solid_thermal=im_solid_primary()

      if ((im_solid_thermal.lt.1).or. &
          (im_solid_thermal.gt.nmat)) then
       print *,"im_solid_thermal invalid 18"
       stop
      endif
      call growntilebox(tilelo,tilehi,fablo,fabhi,growlo,growhi,0) 

      do i=growlo(1),growhi(1)
      do j=growlo(2),growhi(2)
      do k=growlo(3),growhi(3)
       call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)

       distsolid=-99999.0
       disttest=-99999.0
       im_solid_crit=0

       do im=1,nmat
        if (is_rigid(nmat,im).eq.1) then
          ! in: INITSOLIDTEMP
         call materialdistsolid(xsten(0,1),xsten(0,2), &
           xsten(0,SDIM),disttest,time,im)
         if ((FSI_flag(im).eq.2).or. & ! prescribed solid (CAD)
             (FSI_flag(im).eq.4)) then ! CTML FSI
          disttest=lsnew(D_DECL(i,j,k),im)
         else if (FSI_flag(im).eq.1) then ! prescribed solid (EUL)
          ! do nothing
         else
          print *,"FSI_flag invalid"
          stop
         endif
         if (disttest.gt.distsolid) then
          distsolid=disttest
          im_solid_crit=im
         endif
        else if (is_rigid(nmat,im).eq.0) then
         ! do nothing
        else
         print *,"is_rigid invalid"
         stop
        endif
       enddo ! im=1..nmat
     
       if ((im_solid_crit.lt.1).or. &
           (im_solid_crit.gt.nmat)) then
        print *,"im_solid_crit invalid in initsolidtemp"
        stop
       endif
 
       call tempsolid(xsten(0,1),xsten(0,2),xsten(0,SDIM), &
         temp_solid_mat,time,im_solid_crit)
       if ((FSI_flag(im_solid_crit).eq.2).or. & ! prescribed solid (CAD)
           (FSI_flag(im_solid_crit).eq.4)) then ! CTML FSU
        tcomp=(im_solid_crit-1)*num_state_material+2  ! den,T
        temp_solid_mat=snew(D_DECL(i,j,k),tcomp)
       else if (FSI_flag(im_solid_crit).eq.1) then ! prescribed solid (EUL)
        ! do nothing
       else
        print *,"FSI_flag(im_solid_crit) invalid"
        stop
       endif

       do im=1,nmat
        tcomp=(im-1)*num_state_material+2  ! den,T
        if ((distsolid.ge.zero).or. &
            (im.eq.im_solid_crit)) then
         snew(D_DECL(i,j,k),tcomp)=temp_solid_mat
        endif
       enddo ! im=1..nmat

      enddo
      enddo
      enddo

      return
      end subroutine FORT_INITSOLIDTEMP


      subroutine FORT_VELFILL ( &
       level, &
       u,DIMS(u), &
       domlo,domhi,dx, &
       xlo,time,bc,scomp,ncomp,bfact)

      use probf90_module
      use global_utility_module

      IMPLICIT NONE

      INTEGER_T scomp,ncomp,bfact,level
      INTEGER_T DIMDEC(u)  ! ulox,uloy,uloz,uhix,uhiy,uhiz
      INTEGER_T domlo(SDIM),domhi(SDIM)
      REAL_T  dx(SDIM), xlo(SDIM), time
      REAL_T  u(DIMV(u))
      INTEGER_T bc(SDIM,2)
      INTEGER_T i,j,k
      INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
      INTEGER_T fablo(SDIM)
      INTEGER_T fabhi(SDIM)
      INTEGER_T borderlo(3)
      INTEGER_T borderhi(3)
      INTEGER_T IWALL(3)
      INTEGER_T velcomp
      INTEGER_T im_vel
      INTEGER_T nhalf
      REAL_T xsten(-3:3,SDIM)

      nhalf=3
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (ncomp.ne.1) then
       print *,"ncomp invalid9"
       stop
      endif

      if ((level.lt.0).or.(level.gt.fort_finest_level)) then
       print *,"level invalid in fill 1"
       stop
      endif

      if (num_materials_vel.ne.1) then
       print *,"num_materials_vel invalid"
       stop
      endif
 
      im_vel=scomp/SDIM
      velcomp=scomp-im_vel*SDIM+1

      if ((im_vel.lt.0).or.(im_vel.ge.num_materials_vel)) then
       print *,"scomp out of range in vel fill"
       stop
      endif
      if ((velcomp.lt.1).or.(velcomp.gt.SDIM)) then
       print *,"velcomp invalid"
       stop
      endif

      call filcc(bfact, &
       u,DIMS(u), &
       domlo,domhi,bc)

      fablo(1)=ARG_L1(u) ! ulox
      fablo(2)=ARG_L2(u) ! uloy
#if (AMREX_SPACEDIM==3)
      fablo(SDIM)=ARG_L3(u) ! uloz
#endif
      fabhi(1)=ARG_H1(u) ! uhix
      fabhi(2)=ARG_H2(u) ! uhiy
#if (AMREX_SPACEDIM==3)
      fabhi(SDIM)=ARG_H3(u) ! uhiz
#endif
      do dir2=1,SDIM
       if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
        print *,"domlo not divisible by bfact"
        stop
       endif
       if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
        print *,"domhi+1 not divisible by bfact"
        stop
       endif
      enddo  ! dir2

      do dir2=1,SDIM
      do side=1,2

       borderlo(3)=0
       borderhi(3)=0
       do dir3=1,SDIM
        borderlo(dir3)=fablo(dir3)
        borderhi(dir3)=fabhi(dir3)
       enddo
       ext_dir_flag=0
       if (bc(dir2,side).eq.EXT_DIR) then
        if (side.eq.1) then
         if (fablo(dir2).lt.domlo(dir2)) then
          ext_dir_flag=1
          borderhi(dir2)=domlo(dir2)-1
          inside_index=domlo(dir2)
         endif
        else if (side.eq.2) then
         if (fabhi(dir2).gt.domhi(dir2)) then
          ext_dir_flag=1
          borderlo(dir2)=domhi(dir2)+1
          inside_index=domhi(dir2)
         endif
        else
         print *,"side invalid"
         stop
        endif
       endif  ! EXT_DIR ?

       if (ext_dir_flag.eq.1) then
        if (MARCO.eq.1) then
         print *,"Marco Arienti's code needs to be migrated"
         stop
        endif
        do i=borderlo(1),borderhi(1)
        do j=borderlo(2),borderhi(2)
        do k=borderlo(3),borderhi(3)

         call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)

         IWALL(1)=i
         IWALL(2)=j
         IWALL(3)=k
         IWALL(dir2)=inside_index

         call velbc_override(time,dir2,side,velcomp, &
          u(D_DECL(i,j,k)), &
          xsten,nhalf,dx,bfact)
        enddo
        enddo
        enddo
       endif            
      enddo ! side
      enddo ! dir2

      return
      end subroutine FORT_VELFILL

       ! gets all components of the velocity at once. 
       ! (for just a single material)
      subroutine FORT_GROUP_VELFILL ( &
       level, &
       u,DIMS(u), &
       domlo,domhi,dx, &
       xlo,time,bc,scomp,ncomp,bfact)

      use probf90_module
      use global_utility_module

      IMPLICIT NONE

      INTEGER_T scomp,ncomp,bfact,level
      INTEGER_T DIMDEC(u)
      INTEGER_T domlo(SDIM),domhi(SDIM)
      REAL_T  dx(SDIM), xlo(SDIM), time
      REAL_T  u(DIMV(u),ncomp)
      INTEGER_T bc(SDIM,2,ncomp)
      INTEGER_T i,j,k
      INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
      INTEGER_T fablo(SDIM)
      INTEGER_T fabhi(SDIM)
      INTEGER_T borderlo(3)
      INTEGER_T borderhi(3)
      INTEGER_T IWALL(3)
      INTEGER_T velcomp
      INTEGER_T im_vel
      INTEGER_T nhalf
      REAL_T xsten(-3:3,SDIM)

      nhalf=3
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (num_materials_vel.ne.1) then
       print *,"num_materials_vel invalid"
       stop
      endif
      im_vel=scomp/SDIM
      if ((im_vel.lt.0).or.(im_vel.ge.num_materials_vel).or. &
          (im_vel*SDIM.ne.scomp)) then
       print *,"scomp invalid in group velfill"
       stop
      endif
      if (ncomp.ne.SDIM) then
       print *,"ncomp invalid10"
       stop
      endif
      if ((level.lt.0).or.(level.gt.fort_finest_level)) then
       print *,"level invalid in fill 2"
       stop
      endif

      fablo(1)=ARG_L1(u)
      fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
      fablo(SDIM)=ARG_L3(u)
#endif
      fabhi(1)=ARG_H1(u)
      fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
      fabhi(SDIM)=ARG_H3(u)
#endif
      do dir2=1,SDIM
       if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
        print *,"domlo not divisible by bfact"
        stop
       endif
       if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
        print *,"domhi+1 not divisible by bfact"
        stop
       endif
      enddo  ! dir2

      do velcomp=1,SDIM
       call filcc(bfact, &
        u(D_DECL(fablo(1),fablo(2),fablo(SDIM)),velcomp), &
        DIMS(u), &
        domlo,domhi, &
        bc(1,1,velcomp))
      enddo ! velcomp

      do velcomp=1,SDIM
      do dir2=1,SDIM
      do side=1,2

       borderlo(3)=0
       borderhi(3)=0
       do dir3=1,SDIM
        borderlo(dir3)=fablo(dir3)
        borderhi(dir3)=fabhi(dir3)
       enddo
       ext_dir_flag=0
       if (bc(dir2,side,velcomp).eq.EXT_DIR) then
        if (side.eq.1) then
         if (fablo(dir2).lt.domlo(dir2)) then
          ext_dir_flag=1
          borderhi(dir2)=domlo(dir2)-1
          inside_index=domlo(dir2)
         endif
        else if (side.eq.2) then
         if (fabhi(dir2).gt.domhi(dir2)) then
          ext_dir_flag=1
          borderlo(dir2)=domhi(dir2)+1
          inside_index=domhi(dir2)
         endif
        else
         print *,"side invalid"
         stop
        endif
       endif

       if (ext_dir_flag.eq.1) then
        if (MARCO.eq.1) then
         print *,"Marco Arienti's code needs to be migrated"
         stop
        endif
        do i=borderlo(1),borderhi(1)
        do j=borderlo(2),borderhi(2)
        do k=borderlo(3),borderhi(3)

         call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)

         IWALL(1)=i
         IWALL(2)=j
         IWALL(3)=k
         IWALL(dir2)=inside_index

         call velbc_override(time,dir2,side,velcomp, &
          u(D_DECL(i,j,k),velcomp), &
          xsten,nhalf,dx,bfact)
        enddo
        enddo
        enddo
       endif            
      enddo
      enddo
      enddo ! dir2,side,velcomp

      return
      end subroutine FORT_GROUP_VELFILL



      subroutine FORT_SOLVFILL ( &
       level, &
       u,DIMS(u), &
       domlo,domhi,dx, &
       xlo,time,bc,scomp,ncomp,bfact)

      use probf90_module
      use global_utility_module

      IMPLICIT NONE

      INTEGER_T scomp,ncomp,bfact,level
      INTEGER_T DIMDEC(u)
      INTEGER_T domlo(SDIM),domhi(SDIM)
      REAL_T  dx(SDIM), xlo(SDIM), time
      REAL_T  u(DIMV(u))
      INTEGER_T bc(SDIM,2)
      INTEGER_T i,j,k
      INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
      INTEGER_T fablo(SDIM)
      INTEGER_T fabhi(SDIM)
      INTEGER_T borderlo(3)
      INTEGER_T borderhi(3)
      INTEGER_T IWALL(3)
      INTEGER_T velcomp
      INTEGER_T im_vel
      INTEGER_T nhalf
      REAL_T xsten(-3:3,SDIM)
      INTEGER_T nparts

      nhalf=3
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (ncomp.ne.1) then
       print *,"ncomp invalid11"
       stop
      endif
      if (num_materials_vel.ne.1) then
       print *,"num_materials_vel invalid"
       stop
      endif

      nparts=0
      do im_vel=1,num_materials
       if (is_lag_part(num_materials,im_vel).eq.1) then
        nparts=nparts+1
       else if (is_lag_part(num_materials,im_vel).eq.0) then
        ! do nothing
       else
        print *,"is_lag_part(num_materials,im_vel) invalid"
        stop
       endif
      enddo
      if ((nparts.lt.1).or.(nparts.gt.num_materials)) then
       print *,"nparts invalid SOLVFILL"
       stop
      endif

      if ((level.lt.0).or.(level.gt.fort_finest_level)) then
       print *,"level invalid in fill 1"
       stop
      endif
 
      im_vel=scomp/SDIM
      velcomp=scomp-im_vel*SDIM+1

      if ((im_vel.lt.0).or.(im_vel.ge.nparts)) then
       print *,"scomp out of range in solv fill"
       stop
      endif
      if ((velcomp.lt.1).or.(velcomp.gt.SDIM)) then
       print *,"velcomp invalid"
       stop
      endif

      call filcc(bfact, &
       u,DIMS(u), &
       domlo,domhi,bc)

      fablo(1)=ARG_L1(u)
      fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
      fablo(SDIM)=ARG_L3(u)
#endif
      fabhi(1)=ARG_H1(u)
      fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
      fabhi(SDIM)=ARG_H3(u)
#endif
      do dir2=1,SDIM
       if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
        print *,"domlo not divisible by bfact"
        stop
       endif
       if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
        print *,"domhi+1 not divisible by bfact"
        stop
       endif
      enddo  ! dir2

      do dir2=1,SDIM
      do side=1,2

       borderlo(3)=0
       borderhi(3)=0
       do dir3=1,SDIM
        borderlo(dir3)=fablo(dir3)
        borderhi(dir3)=fabhi(dir3)
       enddo
       ext_dir_flag=0
       if (bc(dir2,side).eq.EXT_DIR) then
        if (side.eq.1) then
         if (fablo(dir2).lt.domlo(dir2)) then
          ext_dir_flag=1
          borderhi(dir2)=domlo(dir2)-1
          inside_index=domlo(dir2)
         endif
        else if (side.eq.2) then
         if (fabhi(dir2).gt.domhi(dir2)) then
          ext_dir_flag=1
          borderlo(dir2)=domhi(dir2)+1
          inside_index=domhi(dir2)
         endif
        else
         print *,"side invalid"
         stop
        endif
       endif  ! EXT_DIR ?

       if (ext_dir_flag.eq.1) then
        if (MARCO.eq.1) then
         print *,"Marco Arienti's code needs to be migrated"
         stop
        endif
        do i=borderlo(1),borderhi(1)
        do j=borderlo(2),borderhi(2)
        do k=borderlo(3),borderhi(3)

         call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)

         IWALL(1)=i
         IWALL(2)=j
         IWALL(3)=k
         IWALL(dir2)=inside_index

         call velbc_override(time,dir2,side,velcomp, &
          u(D_DECL(i,j,k)), &
          xsten,nhalf,dx,bfact)
        enddo
        enddo
        enddo
       endif            
      enddo ! side
      enddo ! dir2

      return
      end subroutine FORT_SOLVFILL

       ! gets all components of the velocity at once. 
       ! (for just a single material)
      subroutine FORT_GROUP_SOLVFILL ( &
       level, &
       u,DIMS(u), &
       domlo,domhi,dx, &
       xlo,time,bc,scomp,ncomp,bfact)

      use probf90_module
      use global_utility_module

      IMPLICIT NONE

      INTEGER_T scomp,ncomp,bfact,level
      INTEGER_T DIMDEC(u)
      INTEGER_T domlo(SDIM),domhi(SDIM)
      REAL_T  dx(SDIM), xlo(SDIM), time
      REAL_T  u(DIMV(u),ncomp)
      INTEGER_T bc(SDIM,2,ncomp)
      INTEGER_T i,j,k
      INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
      INTEGER_T fablo(SDIM)
      INTEGER_T fabhi(SDIM)
      INTEGER_T borderlo(3)
      INTEGER_T borderhi(3)
      INTEGER_T IWALL(3)
      INTEGER_T velcomp
      INTEGER_T im_vel
      INTEGER_T nhalf
      REAL_T xsten(-3:3,SDIM)
      INTEGER_T nparts

      nhalf=3
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (num_materials_vel.ne.1) then
       print *,"num_materials_vel invalid"
       stop
      endif

      nparts=0
      do im_vel=1,num_materials
       if (is_lag_part(num_materials,im_vel).eq.1) then
        nparts=nparts+1
       else if (is_lag_part(num_materials,im_vel).eq.0) then
        ! do nothing
       else
        print *,"is_lag_part(num_materials,im_vel) invalid"
        stop
       endif
      enddo
      if ((nparts.lt.1).or.(nparts.gt.num_materials)) then
       print *,"nparts invalid GROUP SOLVFILL"
       stop
      endif

      im_vel=scomp/SDIM
      if ((im_vel.lt.0).or.(im_vel.ge.nparts).or. &
          (im_vel*SDIM.ne.scomp)) then
       print *,"scomp invalid in group solvfill"
       stop
      endif
      if (ncomp.ne.SDIM) then
       print *,"ncomp invalid12"
       stop
      endif
      if ((level.lt.0).or.(level.gt.fort_finest_level)) then
       print *,"level invalid in fill 2"
       stop
      endif

      fablo(1)=ARG_L1(u)
      fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
      fablo(SDIM)=ARG_L3(u)
#endif
      fabhi(1)=ARG_H1(u)
      fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
      fabhi(SDIM)=ARG_H3(u)
#endif
      do dir2=1,SDIM
       if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
        print *,"domlo not divisible by bfact"
        stop
       endif
       if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
        print *,"domhi+1 not divisible by bfact"
        stop
       endif
      enddo  ! dir2

      do velcomp=1,SDIM
       call filcc(bfact, &
        u(D_DECL(fablo(1),fablo(2),fablo(SDIM)),velcomp), &
        DIMS(u), &
        domlo,domhi, &
        bc(1,1,velcomp))
      enddo ! velcomp

      do velcomp=1,SDIM
      do dir2=1,SDIM
      do side=1,2

       borderlo(3)=0
       borderhi(3)=0
       do dir3=1,SDIM
        borderlo(dir3)=fablo(dir3)
        borderhi(dir3)=fabhi(dir3)
       enddo
       ext_dir_flag=0
       if (bc(dir2,side,velcomp).eq.EXT_DIR) then
        if (side.eq.1) then
         if (fablo(dir2).lt.domlo(dir2)) then
          ext_dir_flag=1
          borderhi(dir2)=domlo(dir2)-1
          inside_index=domlo(dir2)
         endif
        else if (side.eq.2) then
         if (fabhi(dir2).gt.domhi(dir2)) then
          ext_dir_flag=1
          borderlo(dir2)=domhi(dir2)+1
          inside_index=domhi(dir2)
         endif
        else
         print *,"side invalid"
         stop
        endif
       endif

       if (ext_dir_flag.eq.1) then
        if (MARCO.eq.1) then
         print *,"Marco Arienti's code needs to be migrated"
         stop
        endif
        do i=borderlo(1),borderhi(1)
        do j=borderlo(2),borderhi(2)
        do k=borderlo(3),borderhi(3)

         call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)

         IWALL(1)=i
         IWALL(2)=j
         IWALL(3)=k
         IWALL(dir2)=inside_index

         call velbc_override(time,dir2,side,velcomp, &
          u(D_DECL(i,j,k),velcomp), &
          xsten,nhalf,dx,bfact)
        enddo
        enddo
        enddo
       endif            
      enddo
      enddo
      enddo ! dir2,side,velcomp

      return
      end subroutine FORT_GROUP_SOLVFILL


       ! grad= -dt k grad S 
       ! called from: NavierStokes::viscous_boundary_fluxes
       ! which is called from: NavierStokes::apply_pressure_grad
      subroutine FORT_VISCFLUXFILL ( &
       macrolayer_size, &
       microlayer_substrate, &
       microlayer_temperature_substrate, &
       latent_heat, &
       freezing_model, &
       saturation_temp, &
       nsolveMM_FACE, &
       nsolve, &
       nsolveMM, &
       dir, &
       xlo,dx, &
       velbc, &
       tempbc, &
       temp_dombc, &
       LS,DIMS(LS), &
       area,DIMS(area), &
       xflux,DIMS(xflux), &
       tilelo,tilehi, &
       fablo,fabhi,bfact, &
       domlo,domhi, &
       dt, &
       nmat, &
       nten, &
       solidheat_flag, &
       project_option, &
       time)

      use probf90_module
      use global_utility_module

      IMPLICIT NONE

      REAL_T time
      INTEGER_T nsolveMM_FACE
      INTEGER_T nsolveMM_FACE_test
      INTEGER_T nsolve
      INTEGER_T nsolveMM
      INTEGER_T dir,dir2
      INTEGER_T nmat
      INTEGER_T nten
      INTEGER_T nten_test
      INTEGER_T solidheat_flag
      INTEGER_T project_option
      INTEGER_T DIMDEC(LS)
      INTEGER_T DIMDEC(area)
      INTEGER_T DIMDEC(xflux)
      INTEGER_T tilelo(SDIM),tilehi(SDIM)
      INTEGER_T fablo(SDIM),fabhi(SDIM)
      INTEGER_T growlo(3),growhi(3)
      INTEGER_T growloMAC(3),growhiMAC(3)
      INTEGER_T growlo_strip(3),growhi_strip(3)
      INTEGER_T bfact
      INTEGER_T domlo(SDIM),domhi(SDIM)
      REAL_T  dx(SDIM)
      REAL_T  xlo(SDIM)
      REAL_T  dt
      REAL_T  LS(DIMV(LS),nmat*(SDIM+1))
      REAL_T  area(DIMV(area))
      REAL_T  xflux(DIMV(xflux),nsolveMM_FACE)
      INTEGER_T velbc(SDIM,2,num_materials_vel*SDIM)
      INTEGER_T tempbc(SDIM,2)
      INTEGER_T temp_dombc(SDIM,2)
      REAL_T macrolayer_size(nmat)
      INTEGER_T microlayer_substrate(nmat)
      REAL_T microlayer_temperature_substrate(nmat)
      REAL_T latent_heat(2*nten)
      INTEGER_T freezing_model(2*nten)
      REAL_T saturation_temp(2*nten)

      INTEGER_T i,j,k,ii,jj,kk
      INTEGER_T side
      REAL_T xsten(-3:3,SDIM)
      INTEGER_T nhalf
      REAL_T dist
      REAL_T LSleft,LSright
      REAL_T nn
      REAL_T tempflux
      REAL_T xflux_local
      INTEGER_T im_vel
      INTEGER_T im,im1,im2,ireverse
      INTEGER_T im_solid_tempflux
      REAL_T LL,TSAT,TSUPER,thermal_layer
      INTEGER_T local_freezing_model,heat_flux_model,iten

      im_solid_tempflux=im_solid_primary()
 
      nhalf=3 
      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
 
      if (num_state_base.ne.2) then
       print *,"num_state_base invalid"
       stop
      endif
      if (time.lt.zero) then
       print *,"time invalid"
       stop
      endif
      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif
      nten_test=( (nmat-1)*(nmat-1)+nmat-1 )/2
      if (nten_test.ne.nten) then
       print *,"nten invalid viscfluxfill nten nten test", &
        nten,nten_test
       stop
      endif
      if (num_materials_vel.ne.1) then
       print *,"num_materials_vel invalid"
       stop
      endif

      if ((solidheat_flag.lt.0).or. &
          (solidheat_flag.gt.2)) then
       print *,"solidheat_flag invalid"
       stop
      endif

      if ((dir.lt.0).or.(dir.ge.SDIM)) then
       print *,"dir invalid viscfluxfill"
       stop
      endif

      if (dt.lt.zero) then
       print *,"dt invalid"
       stop
      endif

      call checkbound(fablo,fabhi,DIMS(LS),1,-1,1302)
      call checkbound(fablo,fabhi,DIMS(area),0,dir,1303)
      call checkbound(fablo,fabhi,DIMS(xflux),0,dir,1304)

      call growntilebox(tilelo,tilehi,fablo,fabhi,growlo,growhi,0) 
      call growntileboxMAC(tilelo,tilehi,fablo,fabhi, &
          growloMAC,growhiMAC,0,dir) 

      if (project_option.eq.3) then ! viscosity
       if (nsolve.ne.AMREX_SPACEDIM) then
        print *,"nsolve invalid"
        stop
       endif
       if (nsolveMM.ne.nsolve) then
        print *,"nsolveMM invalid"
        stop
       endif
       nsolveMM_FACE_test=nsolveMM
      else if (project_option.eq.2) then !thermal conduction
       if (nsolve.ne.1) then
        print *,"nsolve invalid"
        stop
       endif
       if (nsolveMM.ne.nsolve*num_materials_scalar_solve) then
        print *,"nsolveMM invalid"
        stop
       endif
       nsolveMM_FACE_test=nsolveMM
       if (num_materials_scalar_solve.eq.1) then
        ! do nothing
       else if (num_materials_scalar_solve.eq.nmat) then
        nsolveMM_FACE_test=nsolveMM_FACE_test*2
       else
        print *,"num_materials_scalar_solve invalid"
        stop
       endif
      else
       print *,"project_option not supported"
       stop
      endif
      
      if (nsolveMM_FACE_test.ne.nsolveMM_FACE) then
       print *,"nsolveMM_FACE invalid"
       stop
      endif

      if (project_option.eq.3) then ! viscosity
       ! do nothing
      else if (project_option.eq.2) then ! thermal conduction

       do im=1,nmat

        if (is_rigid(nmat,im).eq.0) then
         ! do nothing
        else if (is_rigid(nmat,im).eq.1) then

         if ((im_solid_tempflux.lt.1).or. &
             (im_solid_tempflux.gt.nmat)) then
          print *,"im_solid_tempflux invalid"
          stop
         endif
      
         ! 0=diffuse in solid
         ! 1=dirichlet
         ! 2=neumann (insulating or heat flux source/sink)
         if (solidheat_flag.eq.2) then

          heat_flux_model=0

          do ireverse=0,1
          do im1=1,nmat-1
          do im2=im1+1,nmat
           call get_iten(im1,im2,iten,nmat)
           LL=latent_heat(iten+ireverse*nten)
           local_freezing_model=freezing_model(iten+ireverse*nten)
           TSAT=saturation_temp(iten+ireverse*nten)

           if ((LL.ne.zero).and. &
               (local_freezing_model.eq.0).and. &
               ((microlayer_substrate(im1).eq.im).or. &
                (microlayer_substrate(im2).eq.im))) then
            heat_flux_model=1
            if (microlayer_substrate(im1).eq.im) then
             TSUPER=microlayer_temperature_substrate(im1)
             thermal_layer=macrolayer_size(im1) 
             if ((TSUPER.le.zero).or.(thermal_layer.le.zero)) then
              print *,"TSUPER or thermal_layer invalid"
              stop
             endif
              ! -k dT/dx * n
              ! case 1: solid left, fluid right  n=-1
              !   dT/dx=TSAT-TSUPER  
              ! case 2: solid right, fluid left, n=1
              !   dT/dx=TSUPER-TSAT 
             tempflux=-fort_heatviscconst(im1)*(TSUPER-TSAT)/thermal_layer
            else if (microlayer_substrate(im2).eq.im) then
             TSUPER=microlayer_temperature_substrate(im2)
             thermal_layer=macrolayer_size(im2)
             if ((TSUPER.le.zero).or.(thermal_layer.le.zero)) then
              print *,"TSUPER or thermal_layer invalid"
              stop
             endif
              ! -k dT/dx * n
              ! case 1: solid left, fluid right  n=-1
              !   dT/dx=TSAT-TSUPER  
              ! case 2: solid right, fluid left, n=1
              !   dT/dx=TSUPER-TSAT 
             tempflux=-fort_heatviscconst(im2)*(TSUPER-TSAT)/thermal_layer
            else
             print *,"microlayer_substrate invalid"
             stop
            endif
           else if ((LL.eq.zero).or. &
                    (local_freezing_model.gt.0).or. &
                    ((microlayer_substrate(im1).ne.im).and. &
                     (microlayer_substrate(im2).ne.im))) then
            ! do nothing
           else
            print *,"LL, local_freezing_model, or microlayer_substrate invalid"
            stop
           endif
          enddo ! im2
          enddo ! im1
          enddo ! ireverse

          ii=0
          jj=0
          kk=0
          if (dir.eq.0) then
           ii=1
          else if (dir.eq.1) then
           jj=1
          else if ((dir.eq.2).and.(SDIM.eq.3)) then
           kk=1
          else
           print *,"dir invalid viscfluxfill 2"
           stop
          endif

          do i=growloMAC(1),growhiMAC(1)
          do j=growloMAC(2),growhiMAC(2)
          do k=growloMAC(3),growhiMAC(3)
           call gridstenMAC(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf,dir+1)

           LSleft=LS(D_DECL(i-ii,j-jj,k-kk),im)
           LSright=LS(D_DECL(i,j,k),im)
            ! n points from from fluid to solid
            ! Neumann BC approximation assumes that the
            ! interface has a staircase (rasterized) reconstruction.
           if ((LSright.ge.zero).and.(LSleft.lt.zero)) then
            nn=one
           else if ((LSleft.ge.zero).and.(LSright.lt.zero)) then
            nn=-one
           else
            nn=zero
           endif

             ! flux is -k dt grad T
             ! tempfluxsolid returns Q=-k dT/dx * n  (Q>0 => cooling)
             ! n points from fluid to solid
             ! solid on left and fluid on right => n=-1
             ! code should return Q dt n
             ! units of Q are (erg/(cm s Kelvin)) kelvin/cm=
             ! erg/(cm^2 s)
           if (LSleft*LSright.le.zero) then

            if (heat_flux_model.eq.0) then

             call tempfluxsolid(xsten(0,1), &
              xsten(0,2), &
              xsten(0,SDIM), &
              tempflux,time,dir)

             xflux_local=dt*tempflux*nn

            else if (heat_flux_model.eq.1) then
             ! 
             ! tempflux=-k (TSUPER-TSAT)/thermal_layer=-k dT/dx n
             xflux_local=dt*tempflux*nn
            else
             print *,"heat_flux_model invalid"
             stop
            endif

            if (num_materials_scalar_solve.eq.1) then
             xflux(D_DECL(i,j,k),1)=xflux_local
            else if (num_materials_scalar_solve.eq.nmat) then
             do im_vel=1,num_materials_scalar_solve
              xflux(D_DECL(i,j,k),im_vel)=xflux_local
              xflux(D_DECL(i,j,k),im_vel+nsolveMM_FACE/2)=xflux_local
             enddo ! im_vel
            else
             print *,"num_materials_scalar_solve invalid"
             stop
            endif
 
           else if (LSleft*LSright.ge.zero) then
            ! do nothing
           else
            print *,"LSleft or LSright bust"
            stop
           endif

          enddo
          enddo
          enddo

         ! 0=diffuse in solid
         ! 1=dirichlet
         ! 2=neumann 
         else if ((solidheat_flag.eq.0).or. &
                  (solidheat_flag.eq.1)) then
          ! do nothing
         else
          print *,"solidheat_flag invalid"
          stop
         endif

        else
         print *,"is_rigid invalid"
         stop
        endif
    
       enddo ! im=1..nmat
 
       do dir2=1,3
        growlo_strip(dir2)=growloMAC(dir2) 
        growhi_strip(dir2)=growhiMAC(dir2) 
       enddo

       side=1
       if ((temp_dombc(dir+1,side).eq.FOEXTRAP).and. &
           (tilelo(dir+1).eq.domlo(dir+1))) then

        growhi_strip(dir+1)=growlo_strip(dir+1)

        do i=growlo_strip(1),growhi_strip(1) 
        do j=growlo_strip(2),growhi_strip(2) 
        do k=growlo_strip(3),growhi_strip(3) 

         ! do nothing - no problems yet with a prescribed heat flux at
         ! the bottom

        enddo
        enddo
        enddo
       endif  ! side==1 case (left side)

       do dir2=1,3
        growlo_strip(dir2)=growloMAC(dir2) 
        growhi_strip(dir2)=growhiMAC(dir2) 
       enddo

       side=2
       if ((temp_dombc(dir+1,side).eq.FOEXTRAP).and. &
           (tilehi(dir+1).eq.domhi(dir+1))) then

        growlo_strip(dir+1)=growhi_strip(dir+1)

        do i=growlo_strip(1),growhi_strip(1) 
        do j=growlo_strip(2),growhi_strip(2) 
        do k=growlo_strip(3),growhi_strip(3) 

         call gridstenMAC(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf,dir+1)

         ! cooling disk (top wall side==2)
         ! in order to cool from the top, q=-k grad T>0
         ! q=-k (TCOLD-T_ROOM)>0
         if ((probtype.eq.601).and. &
             (side.eq.2).and. &
             (dir.eq.SDIM-1)) then

          if (SDIM.eq.3) then
           dist=sqrt((xsten(0,1)-xblob)**2+(xsten(0,2)-yblob)**2)-radblob
          else if (SDIM.eq.2) then
           dist=abs(xsten(0,1))-radblob
          else
           print *,"dimension bust"
           stop
          endif

          ! Q=- k grad T 
          ! k grad T<0 => Q>0
          if (dist.le.zero) then
           if (radblob2.le.zero) then
            print *,"cooling Q should be positive"
            stop
           endif
           xflux_local=dt*radblob2
          else
           xflux_local=zero
          endif

          if (num_materials_scalar_solve.eq.1) then
           xflux(D_DECL(i,j,k),1)=xflux_local
          else if (num_materials_scalar_solve.eq.nmat) then
           do im_vel=1,num_materials_scalar_solve
            xflux(D_DECL(i,j,k),im_vel)=xflux_local
            xflux(D_DECL(i,j,k),im_vel+nsolveMM_FACE/2)=xflux_local
           enddo ! im_vel
          else 
           print *,"num_materials_scalar_solve invalid"
           stop
          endif

         endif ! cooling disk

        enddo
        enddo
        enddo
       endif  ! side==2 case (right side)

      else
       print *,"project_option not supported"
       stop
      endif  

      return
      end subroutine VISCFLUXFILL


       subroutine FORT_UMACFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module

       IMPLICIT NONE

       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u))
       INTEGER_T bc(SDIM,2)
       INTEGER_T i,j,k
       INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
       INTEGER_T fablo(SDIM)
       INTEGER_T fabhi(SDIM)
       INTEGER_T borderlo(3)
       INTEGER_T borderhi(3)
       INTEGER_T IWALL(3)
       INTEGER_T velcomp,veldir,nmat
       INTEGER_T nsolveMM_FACE
       INTEGER_T nhalf
       REAL_T xsten(-3:3,SDIM)

       nhalf=3
       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif
       nmat=num_materials
       if ((level.lt.0).or.(level.gt.fort_finest_level)) then
        print *,"level invalid in fill 3"
        stop
       endif

       nsolveMM_FACE=num_materials_vel
       if (num_materials_vel.eq.1) then
        ! do nothing
       else if (num_materials_vel.eq.nmat) then
        nsolveMM_FACE=nsolveMM_FACE*2
       else
        print *,"num_materials_vel invalid"
        stop
       endif

       if ((scomp.lt.0).or.(scomp+ncomp.gt.nsolveMM_FACE)) then
        print *,"scomp invalid umacfill"
        stop
       endif

       if (ncomp.ne.1) then
        print *,"ncomp invalid13"
        stop
       endif

       fablo(1)=ARG_L1(u)
       fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
       fablo(SDIM)=ARG_L3(u)
#endif
       fabhi(1)=ARG_H1(u)
       fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
       fabhi(SDIM)=ARG_H3(u)
#endif
       velcomp=1
       veldir=velcomp-1

       do dir2=1,SDIM
        if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
         print *,"domlo not divisible by bfact"
         stop
        endif
        if (dir2.ne.velcomp) then
         if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
          print *,"domhi+1 not divisible by bfact"
          stop
         endif
        else
         if ((domhi(dir2)/bfact)*bfact.ne.domhi(dir2)) then
          print *,"domhi not divisible by bfact"
          stop
         endif
        endif
       enddo  ! dir2

       call efilcc(bfact, &
        u(D_DECL(fablo(1),fablo(2),fablo(SDIM))), &
        DIMS(u), &
        domlo,domhi,bc,veldir)

       do dir2=1,SDIM
       do side=1,2

        borderlo(3)=0
        borderhi(3)=0
        do dir3=1,SDIM
         borderlo(dir3)=fablo(dir3)
         borderhi(dir3)=fabhi(dir3)
        enddo
        ext_dir_flag=0
        if (bc(dir2,side).eq.EXT_DIR) then

         if (dir2.eq.velcomp) then

          if (side.eq.1) then
           if (fablo(dir2).le.domlo(dir2)) then
            ext_dir_flag=1
            borderhi(dir2)=domlo(dir2)
            inside_index=domlo(dir2)
           endif
          else if (side.eq.2) then
           if (fabhi(dir2).ge.domhi(dir2)) then
            ext_dir_flag=1
            borderlo(dir2)=domhi(dir2)
            inside_index=domhi(dir2)
           endif
          else
           print *,"side invalid"
           stop 
          endif

         else if (dir2.ne.velcomp) then

          if (side.eq.1) then
           if (fablo(dir2).lt.domlo(dir2)) then
            ext_dir_flag=1
            borderhi(dir2)=domlo(dir2)-1
            inside_index=domlo(dir2)
           endif
          else if (side.eq.2) then
           if (fabhi(dir2).gt.domhi(dir2)) then
            ext_dir_flag=1
            borderlo(dir2)=domhi(dir2)+1
            inside_index=domhi(dir2)
           endif
          else
           print *,"side invalid"
           stop
          endif

         else
          print *,"dir2 bust"
          stop
         endif

        endif  ! EXT_DIR ?
    
        if (ext_dir_flag.eq.1) then
         if (MARCO.eq.1) then
          print *,"Marco Arienti's code needs to be migrated"
          stop
         endif
         do i=borderlo(1),borderhi(1)
         do j=borderlo(2),borderhi(2)
         do k=borderlo(3),borderhi(3)

          call gridstenMAC(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf,velcomp)

          IWALL(1)=i
          IWALL(2)=j
          IWALL(3)=k
          IWALL(dir2)=inside_index

          call velbc_override(time,dir2,side,velcomp, &
           u(D_DECL(i,j,k)), &
           xsten,nhalf,dx,bfact)
         enddo
         enddo
         enddo
        endif 
       enddo ! side
       enddo ! dir2

       return
       end subroutine FORT_UMACFILL


       subroutine FORT_VMACFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module

       IMPLICIT NONE

       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u))
       INTEGER_T bc(SDIM,2)
       INTEGER_T i,j,k
       INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
       INTEGER_T fablo(SDIM)
       INTEGER_T fabhi(SDIM)
       INTEGER_T borderlo(3)
       INTEGER_T borderhi(3)
       INTEGER_T IWALL(3)
       INTEGER_T velcomp,veldir,nmat
       INTEGER_T nsolveMM_FACE
       INTEGER_T nhalf
       REAL_T xsten(-3:3,SDIM)

       nhalf=3
       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif
       nmat=num_materials
       if ((level.lt.0).or.(level.gt.fort_finest_level)) then
        print *,"level invalid in fill 4"
        stop
       endif

       nsolveMM_FACE=num_materials_vel
       if (num_materials_vel.eq.1) then
        ! do nothing
       else if (num_materials_vel.eq.nmat) then
        nsolveMM_FACE=nsolveMM_FACE*2
       else
        print *,"num_materials_vel invalid"
        stop
       endif

       if ((scomp.lt.0).or.(scomp+ncomp.gt.nsolveMM_FACE)) then
        print *,"scomp invalid vmacfill"
        stop
       endif

       if (ncomp.ne.1) then
        print *,"ncomp invalid vmacfill"
        stop
       endif

       fablo(1)=ARG_L1(u)
       fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
       fablo(SDIM)=ARG_L3(u)
#endif
       fabhi(1)=ARG_H1(u)
       fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
       fabhi(SDIM)=ARG_H3(u)
#endif
       velcomp=2
       veldir=velcomp-1

       do dir2=1,SDIM
        if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
         print *,"domlo not divisible by bfact"
         stop
        endif
        if (dir2.ne.velcomp) then
         if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
          print *,"domhi+1 not divisible by bfact"
          stop
         endif
        else
         if ((domhi(dir2)/bfact)*bfact.ne.domhi(dir2)) then
          print *,"domhi not divisible by bfact"
          stop
         endif
        endif
       enddo  ! dir2

       call efilcc(bfact, &
        u(D_DECL(fablo(1),fablo(2),fablo(SDIM))), &
        DIMS(u), &
        domlo,domhi,bc,veldir)

       do dir2=1,SDIM
       do side=1,2

        borderlo(3)=0
        borderhi(3)=0
        do dir3=1,SDIM
         borderlo(dir3)=fablo(dir3)
         borderhi(dir3)=fabhi(dir3)
        enddo
        ext_dir_flag=0
        if (bc(dir2,side).eq.EXT_DIR) then

         if (dir2.eq.velcomp) then

          if (side.eq.1) then
           if (fablo(dir2).le.domlo(dir2)) then
            ext_dir_flag=1
            borderhi(dir2)=domlo(dir2)
            inside_index=domlo(dir2)
           endif
          else if (side.eq.2) then
           if (fabhi(dir2).ge.domhi(dir2)) then
            ext_dir_flag=1
            borderlo(dir2)=domhi(dir2)
            inside_index=domhi(dir2)
           endif
          else
           print *,"side invalid"
           stop 
          endif

         else if (dir2.ne.velcomp) then

          if (side.eq.1) then
           if (fablo(dir2).lt.domlo(dir2)) then
            ext_dir_flag=1
            borderhi(dir2)=domlo(dir2)-1
            inside_index=domlo(dir2)
           endif
          else if (side.eq.2) then
           if (fabhi(dir2).gt.domhi(dir2)) then
            ext_dir_flag=1
            borderlo(dir2)=domhi(dir2)+1
            inside_index=domhi(dir2)
           endif
          else
           print *,"side invalid"
           stop
          endif

         else
          print *,"dir2 bust"
          stop
         endif

        endif  ! EXT_DIR ?
    
        if (ext_dir_flag.eq.1) then
         if (MARCO.eq.1) then
          print *,"Marco Arienti's code needs to be migrated"
          stop
         endif
         do i=borderlo(1),borderhi(1)
         do j=borderlo(2),borderhi(2)
         do k=borderlo(3),borderhi(3)

          call gridstenMAC(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf,velcomp)

          IWALL(1)=i
          IWALL(2)=j
          IWALL(3)=k
          IWALL(dir2)=inside_index

          call velbc_override(time,dir2,side,velcomp, &
           u(D_DECL(i,j,k)), &
           xsten,nhalf,dx,bfact)
         enddo
         enddo
         enddo
        endif 
       enddo ! side
       enddo ! dir2

       return
       end subroutine FORT_VMACFILL


#if (AMREX_SPACEDIM==3)
       subroutine FORT_WMACFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module

       IMPLICIT NONE

       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u))
       INTEGER_T bc(SDIM,2)
       INTEGER_T i,j,k
       INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
       INTEGER_T fablo(SDIM)
       INTEGER_T fabhi(SDIM)
       INTEGER_T borderlo(3)
       INTEGER_T borderhi(3)
       INTEGER_T IWALL(3)
       INTEGER_T velcomp,veldir,nmat
       INTEGER_T nsolveMM_FACE
       INTEGER_T nhalf
       REAL_T xsten(-3:3,SDIM)

       nhalf=3
       if (SDIM.ne.3) then
        print *,"dimension bust"
        stop
       endif
       if (AMREX_SPACEDIM.ne.3) then
        print *,"dimension bust"
        stop
       endif
       if ((level.lt.0).or.(level.gt.fort_finest_level)) then
        print *,"level invalid in fill 5"
        stop
       endif

       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif
       nmat=num_materials

       nsolveMM_FACE=num_materials_vel
       if (num_materials_vel.eq.1) then
        ! do nothing
       else if (num_materials_vel.eq.nmat) then
        nsolveMM_FACE=nsolveMM_FACE*2
       else
        print *,"num_materials_vel invalid"
        stop
       endif

       if ((scomp.lt.0).or.(scomp+ncomp.gt.nsolveMM_FACE)) then
        print *,"scomp invalid wmacfill"
        stop
       endif

       if (ncomp.ne.1) then
        print *,"ncomp invalid wmacfill"
        stop
       endif

       fablo(1)=ARG_L1(u)
       fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
       fablo(SDIM)=ARG_L3(u)
#endif
       fabhi(1)=ARG_H1(u)
       fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
       fabhi(SDIM)=ARG_H3(u)
#endif
       velcomp=AMREX_SPACEDIM
       veldir=velcomp-1

       do dir2=1,SDIM
        if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
         print *,"domlo not divisible by bfact"
         stop
        endif
        if (dir2.ne.velcomp) then
         if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
          print *,"domhi+1 not divisible by bfact"
          stop
         endif
        else
         if ((domhi(dir2)/bfact)*bfact.ne.domhi(dir2)) then
          print *,"domhi not divisible by bfact"
          stop
         endif
        endif
       enddo  ! dir2

       call efilcc(bfact, &
        u(D_DECL(fablo(1),fablo(2),fablo(SDIM))), &
        DIMS(u), &
        domlo,domhi,bc,veldir)

       do dir2=1,SDIM
       do side=1,2

        borderlo(3)=0
        borderhi(3)=0
        do dir3=1,SDIM
         borderlo(dir3)=fablo(dir3)
         borderhi(dir3)=fabhi(dir3)
        enddo
        ext_dir_flag=0
        if (bc(dir2,side).eq.EXT_DIR) then

         if (dir2.eq.velcomp) then

          if (side.eq.1) then
           if (fablo(dir2).le.domlo(dir2)) then
            ext_dir_flag=1
            borderhi(dir2)=domlo(dir2)
            inside_index=domlo(dir2)
           endif
          else if (side.eq.2) then
           if (fabhi(dir2).ge.domhi(dir2)) then
            ext_dir_flag=1
            borderlo(dir2)=domhi(dir2)
            inside_index=domhi(dir2)
           endif
          else
           print *,"side invalid"
           stop 
          endif

         else if (dir2.ne.velcomp) then

          if (side.eq.1) then
           if (fablo(dir2).lt.domlo(dir2)) then
            ext_dir_flag=1
            borderhi(dir2)=domlo(dir2)-1
            inside_index=domlo(dir2)
           endif
          else if (side.eq.2) then
           if (fabhi(dir2).gt.domhi(dir2)) then
            ext_dir_flag=1
            borderlo(dir2)=domhi(dir2)+1
            inside_index=domhi(dir2)
           endif
          else
           print *,"side invalid"
           stop
          endif

         else
          print *,"dir2 bust"
          stop
         endif

        endif  ! EXT_DIR ?
    
        if (ext_dir_flag.eq.1) then
         if (MARCO.eq.1) then
          print *,"Marco Arienti's code needs to be migrated"
          stop
         endif
         do i=borderlo(1),borderhi(1)
         do j=borderlo(2),borderhi(2)
         do k=borderlo(3),borderhi(3)

          call gridstenMAC(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf,velcomp)

          IWALL(1)=i
          IWALL(2)=j
          IWALL(3)=k
          IWALL(dir2)=inside_index

          call velbc_override(time,dir2,side,velcomp, &
           u(D_DECL(i,j,k)), &
           xsten,nhalf,dx,bfact)
         enddo
         enddo
         enddo
        endif 
       enddo ! side
       enddo ! dir2

       return
       end subroutine FORT_WMACFILL
#endif


       subroutine FORT_MOFFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module

       IMPLICIT NONE

       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u))
       INTEGER_T bc(SDIM,2)

       print *,"this routine should never be called"
       stop

       return
       end subroutine FORT_MOFFILL


       subroutine FORT_EXTMOFFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module
       use MOF_routines_module

       IMPLICIT NONE

       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u))
       INTEGER_T bc(SDIM,2)

       print *,"this routine should never be called"
       stop

       return
       end subroutine FORT_EXTMOFFILL

       subroutine FORT_GROUP_MOFFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module

       IMPLICIT NONE

       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u),ncomp)
       INTEGER_T bc(SDIM,2,ncomp)
       INTEGER_T i,j,k
       INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
       INTEGER_T fablo(SDIM)
       INTEGER_T fabhi(SDIM)
       INTEGER_T borderlo(3)
       INTEGER_T borderhi(3)
       INTEGER_T IWALL(3)
       INTEGER_T im,nmat
       REAL_T uwall(num_materials*ngeom_raw)
       REAL_T uboundary(num_materials*ngeom_raw)
       INTEGER_T nhalf
       REAL_T xsten(-3:3,SDIM)

       nhalf=3
       if ((level.lt.0).or.(level.gt.fort_finest_level)) then
        print *,"level invalid in fill 6"
        stop
       endif
       if (num_state_base.ne.2) then
        print *,"num_state_base invalid"
        stop
       endif
       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif

       fablo(1)=ARG_L1(u)
       fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
       fablo(SDIM)=ARG_L3(u)
#endif
       fabhi(1)=ARG_H1(u)
       fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
       fabhi(SDIM)=ARG_H3(u)
#endif
       nmat=num_materials

       if (nmat*ngeom_raw.ne.ncomp) then
        print *,"ncomp invalid mof group fill"
        stop
       endif
       if (scomp.ne.num_materials_vel*(SDIM+1)+ &
           nmat*num_state_material) then
        print *,"scomp invalid mof group fill"
        stop
       endif

       do im=1,nmat*ngeom_raw
        call filcc(bfact, &
         u(D_DECL(fablo(1),fablo(2),fablo(SDIM)),im), &
         DIMS(u), &
         domlo,domhi,bc(1,1,im))
       enddo

       do dir2=1,SDIM
        if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
         print *,"domlo not divisible by bfact"
         stop
        endif
        if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
         print *,"domhi+1 not divisible by bfact"
         stop
        endif
       enddo  ! dir2

       do dir2=1,SDIM
       do side=1,2

        borderlo(3)=0
        borderhi(3)=0
        do dir3=1,SDIM
         borderlo(dir3)=fablo(dir3)
         borderhi(dir3)=fabhi(dir3)
        enddo
        ext_dir_flag=0
        if (bc(dir2,side,1).eq.EXT_DIR) then
         if (side.eq.1) then
          if (fablo(dir2).lt.domlo(dir2)) then
           ext_dir_flag=1
           borderhi(dir2)=domlo(dir2)-1
           inside_index=domlo(dir2)
          endif
         else if (side.eq.2) then
          if (fabhi(dir2).gt.domhi(dir2)) then
           ext_dir_flag=1
           borderlo(dir2)=domhi(dir2)+1
           inside_index=domhi(dir2)
          endif
         else
          print *,"side invalid"
          stop
         endif
        endif

        if (ext_dir_flag.eq.1) then
         do i=borderlo(1),borderhi(1)
         do j=borderlo(2),borderhi(2)
         do k=borderlo(3),borderhi(3)

          call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)

          IWALL(1)=i
          IWALL(2)=j
          IWALL(3)=k
          IWALL(dir2)=inside_index

          do im=1,nmat*ngeom_raw
           uwall(im)=u(D_DECL(IWALL(1),IWALL(2),IWALL(3)),im)
          enddo
          call groupmofBC(time,dir2,side, &
           uboundary, &
           uwall, &
           xsten,nhalf,dx,bfact,nmat)
          do im=1,nmat*ngeom_raw
           u(D_DECL(i,j,k),im)=uboundary(im)
          enddo
         enddo
         enddo
         enddo
        endif            
       enddo ! side
       enddo ! dir2

       return
       end subroutine FORT_GROUP_MOFFILL


       subroutine FORT_GROUP_EXTMOFFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module
       use geometry_intersect_module
       use MOF_routines_module

       IMPLICIT NONE


       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u),ncomp)
       INTEGER_T bc(SDIM,2,ncomp)
       INTEGER_T i,j,k
       INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
       INTEGER_T isub
       INTEGER_T ibasesrc
       INTEGER_T ibasedst
       INTEGER_T use_ls_data,mof_verbose
       INTEGER_T continuous_mof
       REAL_T LS_stencil(D_DECL(-1:1,-1:1,-1:1),1)  ! not used
       REAL_T multi_centroidA(num_materials,SDIM)
       REAL_T mofdata(num_materials*ngeom_recon)
       INTEGER_T fablo(SDIM)
       INTEGER_T fabhi(SDIM)
       INTEGER_T borderlo(3)
       INTEGER_T borderhi(3)
       INTEGER_T IWALL(3)
       INTEGER_T im,nmat
       REAL_T uwall(num_materials*ngeom_raw)
       REAL_T uboundary(num_materials*ngeom_raw)
       INTEGER_T vofcomp
       REAL_T voffluid_wall,vofsolid_wall
       REAL_T voffluid_bound,vofsolid_bound
       REAL_T voftest_wall,voftest_bound

       INTEGER_T tessellate

       INTEGER_T nhalf
       REAL_T xsten(-3:3,SDIM)
       INTEGER_T tid,nmax
#ifdef _OPENMP
       INTEGER_T omp_get_thread_num
#endif

       nmax=POLYGON_LIST_MAX ! in: FORT_GROUP_EXTMOFFILL

       tid=0       
#ifdef _OPENMP
       tid=omp_get_thread_num()
#endif
       if ((tid.ge.geom_nthreads).or.(tid.lt.0)) then
        print *,"tid invalid"
        stop
       endif 
       if ((level.lt.0).or.(level.gt.fort_finest_level)) then
        print *,"level invalid in fill 7"
        stop
       endif

       tessellate=0

       nhalf=3
       if (num_state_base.ne.2) then
        print *,"num_state_base invalid"
        stop
       endif
       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif

       fablo(1)=ARG_L1(u)
       fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
       fablo(SDIM)=ARG_L3(u)
#endif
       fabhi(1)=ARG_H1(u)
       fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
       fabhi(SDIM)=ARG_H3(u)
#endif
       nmat=num_materials

       if (nmat*ngeom_recon.ne.ncomp) then
        print *,"ncomp invalid mof extended group fill"
        stop
       endif
       if (scomp.ne.1+SDIM) then
        print *,"scomp invalid in mof extended group fill"
        stop
       endif

       do im=1,nmat*ngeom_recon
        call filcc(bfact, &
         u(D_DECL(fablo(1),fablo(2),fablo(SDIM)),im), &
         DIMS(u), &
         domlo,domhi,bc(1,1,im))
       enddo

       do dir2=1,SDIM
        if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
         print *,"domlo not divisible by bfact"
         stop
        endif
        if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
         print *,"domhi+1 not divisible by bfact"
         stop
        endif
       enddo  ! dir2

       do dir2=1,SDIM
       do side=1,2

        borderlo(3)=0
        borderhi(3)=0
        do dir3=1,SDIM
         borderlo(dir3)=fablo(dir3)
         borderhi(dir3)=fabhi(dir3)
        enddo
        ext_dir_flag=0
        if (bc(dir2,side,1).eq.EXT_DIR) then
         if (side.eq.1) then
          if (fablo(dir2).lt.domlo(dir2)) then
           ext_dir_flag=1
           borderhi(dir2)=domlo(dir2)-1
           inside_index=domlo(dir2)
          endif
         else if (side.eq.2) then
          if (fabhi(dir2).gt.domhi(dir2)) then
           ext_dir_flag=1
           borderlo(dir2)=domhi(dir2)+1
           inside_index=domhi(dir2)
          endif
         else
          print *,"side invalid"
          stop
         endif
        endif

        if (ext_dir_flag.eq.1) then
         do i=borderlo(1),borderhi(1)
         do j=borderlo(2),borderhi(2)
         do k=borderlo(3),borderhi(3)

          call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)

          IWALL(1)=i
          IWALL(2)=j
          IWALL(3)=k
          IWALL(dir2)=inside_index

          do im=1,nmat
           ibasesrc=(im-1)*ngeom_recon
           ibasedst=(im-1)*ngeom_raw
           do isub=1,ngeom_raw
            uwall(ibasedst+isub)= &
              u(D_DECL(IWALL(1),IWALL(2),IWALL(3)),ibasesrc+isub)
           enddo 
          enddo ! im

          call groupmofBC(time,dir2,side, &
           uboundary, &
           uwall, &
           xsten,nhalf,dx,bfact,nmat)

          voffluid_wall=zero
          vofsolid_wall=zero
          voffluid_bound=zero
          vofsolid_bound=zero
          do im=1,nmat
           vofcomp=(im-1)*ngeom_raw+1
           voftest_wall=uwall(vofcomp)
           voftest_bound=uboundary(vofcomp)
           if (is_rigid(nmat,im).eq.0) then
            voffluid_wall=voffluid_wall+voftest_wall
            voffluid_bound=voffluid_bound+voftest_bound
           else if (is_rigid(nmat,im).eq.1) then
            vofsolid_wall=vofsolid_wall+voftest_wall
            vofsolid_bound=vofsolid_bound+voftest_bound
           else
            print *,"is_rigid invalid"
            stop
           endif
          enddo ! im=1..nmat

          if ((voffluid_wall.le.zero).or.(voffluid_bound.le.zero)) then
           print *,"fluid disappeared in GROUP_EXTMOFFILL"
           print *,"i,j,k ",i,j,k
           print *,"IWALL ",IWALL(1),IWALL(2),IWALL(3)
           print *,"voffluid_wall,vofsolid_wall ",voffluid_wall,vofsolid_wall
           print *,"voffluid_bound,vofsolid_bound ",voffluid_bound, &
             vofsolid_bound
           stop
          else if ((voffluid_wall.le.two).and.(voffluid_bound.le.two)) then
           ! do nothing
          else
           print *,"voffluid_wall or voffluid_bound invalid"
           stop
          endif

          use_ls_data=0
          mof_verbose=0
          continuous_mof=0

          do im=1,nmat

           ibasesrc=(im-1)*ngeom_raw+1
           ibasedst=(im-1)*ngeom_recon+1
           do dir3=0,SDIM
            mofdata(ibasedst+dir3)=uboundary(ibasesrc+dir3)
           enddo

            ! order=0
           mofdata(ibasedst+SDIM+1)=zero

          enddo  ! im

          call make_vfrac_sum_ok_base(tessellate,mofdata,nmat,SDIM,204)

          call multimaterial_MOF( &
           bfact,dx,xsten,nhalf, &
           mof_verbose, &
           use_ls_data, &
           LS_stencil, &
           geom_xtetlist(1,1,1,tid+1), &
           geom_xtetlist(1,1,1,tid+1), &
           nmax, &
           nmax, &
           mofdata, &
           multi_centroidA, &
           continuous_mof, &
           nmat,SDIM,4)

          do dir3=1,nmat*ngeom_recon
           u(D_DECL(i,j,k),dir3)=mofdata(dir3)
          enddo

         enddo
         enddo
         enddo
        endif            
       enddo ! side
       enddo ! dir2

       return
       end subroutine FORT_GROUP_EXTMOFFILL

       subroutine FORT_LS_HO_FILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use global_utility_module
       use probf90_module

       IMPLICIT NONE

       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u))
       INTEGER_T bc(SDIM,2)

       print *,"LS_HO_FILL should never be called"
       print *,"GROUP_LS_HO_FILL should be called instead"
       stop

       return
       end subroutine FORT_LS_HO_FILL


       subroutine FORT_GROUP_LS_HO_FILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module

       IMPLICIT NONE


       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u),ncomp)
       INTEGER_T bc(SDIM,2,ncomp)
       INTEGER_T i,j,k
       INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
       INTEGER_T fablo(SDIM) 
       INTEGER_T fabhi(SDIM)
       INTEGER_T borderlo(3)
       INTEGER_T borderhi(3)
       INTEGER_T IWALL(3)
       INTEGER_T nmat
       INTEGER_T imls
      
       REAL_T uwall(ncomp)
       REAL_T uboundary(ncomp)
       INTEGER_T nhalf
       REAL_T xsten(-3:3,SDIM)
       INTEGER_T ncomp_ho,icomp

       nhalf=3
       if ((level.lt.0).or.(level.gt.fort_finest_level)) then
        print *,"level invalid in fill 10"
        stop
       endif

       fablo(1)=ARG_L1(u)
       fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
       fablo(SDIM)=ARG_L3(u)
#endif
       fabhi(1)=ARG_H1(u)
       fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
       fabhi(SDIM)=ARG_H3(u)
#endif

       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif

       nmat=num_materials

       ncomp_ho=(SDIM+1)*nmat

       if (ncomp_ho.ne.ncomp) then
        print *,"ncomp invalid group ls ho fill"
        stop
       endif
       if ((scomp.ne.SDIM*nmat).and. &  ! called from ghost fill
           (scomp.ne.0)) then           ! called from main fill
        print *,"scomp invalid group ls ho fill"
        print *,"scomp= ",scomp
        stop
       endif
       if ((ls_homflag.ne.0).and.(ls_homflag.ne.1)) then
        print *,"ls_homflag invalid"
        stop
       endif

       do imls=1,ncomp_ho
        call filcc(bfact, &
         u(D_DECL(fablo(1),fablo(2),fablo(SDIM)),imls), &
         DIMS(u), &
         domlo,domhi, &
         bc(1,1,imls))
       enddo

       do dir2=1,SDIM
        if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
         print *,"domlo not divisible by bfact"
         stop
        endif
        if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
         print *,"domhi+1 not divisible by bfact"
         stop
        endif
       enddo  ! dir2

       do dir2=1,SDIM
       do side=1,2

         ! 1..nmat  level set functions
        borderlo(3)=0
        borderhi(3)=0
        do dir3=1,SDIM
         borderlo(dir3)=fablo(dir3)
         borderhi(dir3)=fabhi(dir3)
        enddo

        ext_dir_flag=0
        if (bc(dir2,side,1).eq.EXT_DIR) then
         if (side.eq.1) then
          if (fablo(dir2).lt.domlo(dir2)) then
           ext_dir_flag=1
           borderhi(dir2)=domlo(dir2)-1
           inside_index=domlo(dir2)
          endif
         else if (side.eq.2) then
          if (fabhi(dir2).gt.domhi(dir2)) then
           ext_dir_flag=1
           borderlo(dir2)=domhi(dir2)+1
           inside_index=domhi(dir2)
          endif
         else
          print *,"side invalid"
          stop
         endif
        endif

        if (ext_dir_flag.eq.1) then
         do i=borderlo(1),borderhi(1)
         do j=borderlo(2),borderhi(2)
         do k=borderlo(3),borderhi(3)

          call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)
          IWALL(1)=i
          IWALL(2)=j
          IWALL(3)=k
          IWALL(dir2)=inside_index
          do imls=1,nmat
           uwall(imls)=u(D_DECL(IWALL(1),IWALL(2),IWALL(3)),imls)
          enddo
          call grouplsBC(time,dir2,side, &
           uboundary, &
           uwall, &
           xsten,nhalf,dx,bfact,nmat)
          do imls=1,nmat
           u(D_DECL(i,j,k),imls)=uboundary(imls)
          enddo
         enddo
         enddo
         enddo
        else if (ext_dir_flag.eq.0) then
         ! do nothing
        else
         print *,"ext_dir_flag invalid"
         stop
        endif 

         ! nmat+1 ... ncomp_ho: levelset normals
        do icomp=nmat+1,ncomp_ho

         borderlo(3)=0
         borderhi(3)=0
         do dir3=1,SDIM
          borderlo(dir3)=fablo(dir3)
          borderhi(dir3)=fabhi(dir3)
         enddo
         ext_dir_flag=0
         if (bc(dir2,side,icomp).eq.EXT_DIR) then
          if (side.eq.1) then
           if (fablo(dir2).lt.domlo(dir2)) then
            ext_dir_flag=1
            borderhi(dir2)=domlo(dir2)-1
            inside_index=domlo(dir2)
           endif
          else if (side.eq.2) then
           if (fabhi(dir2).gt.domhi(dir2)) then
            ext_dir_flag=1
            borderlo(dir2)=domhi(dir2)+1
            inside_index=domhi(dir2)
           endif
          else
           print *,"side invalid"
           stop
          endif
         endif

         if (ext_dir_flag.eq.1) then
          do i=borderlo(1),borderhi(1)
          do j=borderlo(2),borderhi(2)
          do k=borderlo(3),borderhi(3)

           call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)
           IWALL(1)=i
           IWALL(2)=j
           IWALL(3)=k
           IWALL(dir2)=inside_index

           call extrapBC(time,dir2,side, &
             u(D_DECL(i,j,k),icomp), &
             u(D_DECL(IWALL(1),IWALL(2),IWALL(3)),icomp), &
             xsten,nhalf,dx,bfact)
          enddo
          enddo
          enddo
         else if (ext_dir_flag.eq.0) then
          ! do nothing
         else
          print *,"ext_dir_flag invalid"
          stop
         endif 

        enddo ! icomp=nmat+1 ... ncomp_ho

       enddo ! side
       enddo ! dir2

       return
       end subroutine FORT_GROUP_LS_HO_FILL


        ! this is for the "errorind" variable.
       subroutine FORT_SCALARFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module

       IMPLICIT NONE

       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u))
       INTEGER_T bc(SDIM,2)
       INTEGER_T i,j,k
       INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
       INTEGER_T fablo(SDIM)
       INTEGER_T fabhi(SDIM)
       INTEGER_T borderlo(3)
       INTEGER_T borderhi(3)
       INTEGER_T IWALL(3)
       INTEGER_T nc
       INTEGER_T nhalf
       REAL_T xsten(-3:3,SDIM)

       nhalf=3
       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif
       if ((level.lt.0).or.(level.gt.fort_finest_level)) then
        print *,"level invalid in fill 11"
        stop
       endif

       if (ncomp.ne.1) then
        print *,"ncomp invalid in scalar fill"
        stop
       endif
        ! "errorind" variable.
       nc=num_materials_vel*(SDIM+1)+ &
        num_materials*(num_state_material+ngeom_raw)
       if (scomp.ne.nc) then
        print *,"scomp invalid in scalar fill"
        stop
       endif

       call filcc(bfact, &
        u,DIMS(u), &
        domlo,domhi,bc)

       fablo(1)=ARG_L1(u)
       fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
       fablo(SDIM)=ARG_L3(u)
#endif
       fabhi(1)=ARG_H1(u)
       fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
       fabhi(SDIM)=ARG_H3(u)
#endif

       do dir2=1,SDIM
        if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
         print *,"domlo not divisible by bfact"
         stop
        endif
        if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
         print *,"domhi+1 not divisible by bfact"
         stop
        endif
       enddo  ! dir2

       do dir2=1,SDIM
       do side=1,2

        borderlo(3)=0
        borderhi(3)=0
        do dir3=1,SDIM
         borderlo(dir3)=fablo(dir3)
         borderhi(dir3)=fabhi(dir3)
        enddo
        ext_dir_flag=0
        if (bc(dir2,side).eq.EXT_DIR) then
         if (side.eq.1) then
          if (fablo(dir2).lt.domlo(dir2)) then
           ext_dir_flag=1
           borderhi(dir2)=domlo(dir2)-1
           inside_index=domlo(dir2)
          endif
         else if (side.eq.2) then
          if (fabhi(dir2).gt.domhi(dir2)) then
           ext_dir_flag=1
           borderlo(dir2)=domhi(dir2)+1
           inside_index=domhi(dir2)
          endif
         else
          print *,"side invalid"
          stop
         endif
        endif

        if (ext_dir_flag.eq.1) then
         do i=borderlo(1),borderhi(1)
         do j=borderlo(2),borderhi(2)
         do k=borderlo(3),borderhi(3)

          call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)
          IWALL(1)=i
          IWALL(2)=j
          IWALL(3)=k
          IWALL(dir2)=inside_index

          call scalarBC(time,dir2,side, &
            u(D_DECL(i,j,k)), &
            u(D_DECL(IWALL(1),IWALL(2),IWALL(3))), &
            xsten,nhalf,dx,bfact)
         enddo
         enddo
         enddo
        endif            
       enddo ! side
       enddo ! dir2

       return
       end subroutine FORT_SCALARFILL



       subroutine FORT_GROUP_EXTRAPFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module

       IMPLICIT NONE


       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u),ncomp)
       INTEGER_T bc(SDIM,2,ncomp)
       INTEGER_T i,j,k
       INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
       INTEGER_T fablo(SDIM)
       INTEGER_T fabhi(SDIM)
       INTEGER_T borderlo(3)
       INTEGER_T borderhi(3)
       INTEGER_T IWALL(3)
       INTEGER_T icomp
       INTEGER_T nhalf
       REAL_T xsten(-3:3,SDIM)
       INTEGER_T extrecon_scomp
       INTEGER_T mask_scomp
       INTEGER_T burnvel_scomp
       INTEGER_T tsat_scomp
       INTEGER_T nmat
       INTEGER_T nten
       INTEGER_T ncomp_per
       INTEGER_T ncomp_per_burning
       INTEGER_T ncomp_per_tsat

       nmat=num_materials
       nten=( (nmat-1)*(nmat-1)+nmat-1 )/2

       ncomp_per_burning=SDIM
       ncomp_per_tsat=2  ! interface temperature, mass fraction

        ! extrap, velx, vely, velz
       extrecon_scomp=SDIM+1
        ! extrap, velx, vely, velz, mof recon
       mask_scomp=extrecon_scomp+nmat*ngeom_recon
       burnvel_scomp=mask_scomp+1
       tsat_scomp=burnvel_scomp+nten*(ncomp_per_burning+1)

       nhalf=3
       if ((level.lt.0).or.(level.gt.fort_finest_level)) then
        print *,"level invalid in fill 12"
        stop
       endif

        ! c++ index
       if (scomp.eq.burnvel_scomp) then
        ncomp_per=ncomp_per_burning
       else if (scomp.eq.tsat_scomp) then
        ncomp_per=ncomp_per_tsat ! interface temperature, mass fraction
       else
        print *,"scomp invalid group extrapfill"
        print *,"scomp, ncomp, bfact, time ",scomp,ncomp,bfact,time
        print *,"nmat,extrecon_scomp,mask_scomp,burnvel_scomp ", &
         nmat,extrecon_scomp,mask_scomp,burnvel_scomp
        stop
       endif

       if (ncomp.eq.nten*(1+ncomp_per)) then
        ! do nothing
       else
        print *,"ncomp invalid14"
        stop
       endif
       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif

       fablo(1)=ARG_L1(u)
       fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
       fablo(SDIM)=ARG_L3(u)
#endif
       fabhi(1)=ARG_H1(u)
       fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
       fabhi(SDIM)=ARG_H3(u)
#endif

       do icomp=1,(ncomp_per+1)*nten
        call filcc(bfact, &
         u(D_DECL(fablo(1),fablo(2),fablo(SDIM)),icomp), &
         DIMS(u), &
         domlo,domhi,bc(1,1,icomp))
       enddo

       do dir2=1,SDIM
        if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
         print *,"domlo not divisible by bfact"
         stop
        endif
        if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
         print *,"domhi+1 not divisible by bfact"
         stop
        endif
       enddo  ! dir2

       do dir2=1,SDIM
       do side=1,2

       do icomp=1,(ncomp_per+1)*nten

        borderlo(3)=0
        borderhi(3)=0
        do dir3=1,SDIM
         borderlo(dir3)=fablo(dir3)
         borderhi(dir3)=fabhi(dir3)
        enddo
        ext_dir_flag=0
        if (bc(dir2,side,icomp).eq.EXT_DIR) then

         print *,"exterior dirichlet BC not allowed"
         stop

         if (side.eq.1) then
          if (fablo(dir2).lt.domlo(dir2)) then
           ext_dir_flag=1
           borderhi(dir2)=domlo(dir2)-1
           inside_index=domlo(dir2)
          endif
         else if (side.eq.2) then
          if (fabhi(dir2).gt.domhi(dir2)) then
           ext_dir_flag=1
           borderlo(dir2)=domhi(dir2)+1
           inside_index=domhi(dir2)
          endif
         else
          print *,"side invalid"
          stop
         endif
        endif

        if (ext_dir_flag.eq.1) then
         do i=borderlo(1),borderhi(1)
         do j=borderlo(2),borderhi(2)
         do k=borderlo(3),borderhi(3)

          call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)
          IWALL(1)=i
          IWALL(2)=j
          IWALL(3)=k
          IWALL(dir2)=inside_index

           ! low order extrap
          call extrapBC(time,dir2,side, &
            u(D_DECL(i,j,k),icomp), &
            u(D_DECL(IWALL(1),IWALL(2),IWALL(3)),icomp), &
            xsten,nhalf,dx,bfact)
         enddo
         enddo
         enddo
        endif            
       enddo ! icomp=1,(ncomp_per+1)*nten

       enddo ! side
       enddo ! dir2

       return
       end subroutine FORT_GROUP_EXTRAPFILL

       subroutine FORT_EXTRAPFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module

       IMPLICIT NONE

       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u))
       INTEGER_T bc(SDIM,2)
       INTEGER_T i,j,k
       INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
       INTEGER_T fablo(SDIM)
       INTEGER_T fabhi(SDIM)
       INTEGER_T borderlo(3)
       INTEGER_T borderhi(3)
       INTEGER_T IWALL(3)
       INTEGER_T nhalf
       REAL_T xsten(-3:3,SDIM)

       nhalf=3
       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif
       if ((level.lt.0).or.(level.gt.fort_finest_level)) then
        print *,"level invalid in fill 13"
        stop
       endif

       if (ncomp.lt.1) then
        print *,"ncomp invalid in extrap fill"
        stop
       endif

       call filcc(bfact, &
        u,DIMS(u), &
        domlo,domhi,bc)

       fablo(1)=ARG_L1(u)
       fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
       fablo(SDIM)=ARG_L3(u)
#endif
       fabhi(1)=ARG_H1(u)
       fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
       fabhi(SDIM)=ARG_H3(u)
#endif

       do dir2=1,SDIM
        if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
         print *,"domlo not divisible by bfact"
         stop
        endif
        if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
         print *,"domhi+1 not divisible by bfact"
         stop
        endif
       enddo  ! dir2

       do dir2=1,SDIM
       do side=1,2

        borderlo(3)=0
        borderhi(3)=0
        do dir3=1,SDIM
         borderlo(dir3)=fablo(dir3)
         borderhi(dir3)=fabhi(dir3)
        enddo
        ext_dir_flag=0
        if (bc(dir2,side).eq.EXT_DIR) then

         print *,"exterior dirichlet BC not allowed"
         stop

         if (side.eq.1) then
          if (fablo(dir2).lt.domlo(dir2)) then
           ext_dir_flag=1
           borderhi(dir2)=domlo(dir2)-1
           inside_index=domlo(dir2)
          endif
         else if (side.eq.2) then
          if (fabhi(dir2).gt.domhi(dir2)) then
           ext_dir_flag=1
           borderlo(dir2)=domhi(dir2)+1
           inside_index=domhi(dir2)
          endif
         else
          print *,"side invalid"
          stop
         endif
        endif

        if (ext_dir_flag.eq.1) then
         do i=borderlo(1),borderhi(1)
         do j=borderlo(2),borderhi(2)
         do k=borderlo(3),borderhi(3)

          call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)
          IWALL(1)=i
          IWALL(2)=j
          IWALL(3)=k
          IWALL(dir2)=inside_index

          call extrapBC(time,dir2,side, &
            u(D_DECL(i,j,k)), &
            u(D_DECL(IWALL(1),IWALL(2),IWALL(3))), &
            xsten,nhalf,dx,bfact)
         enddo
         enddo
         enddo
        endif            
       enddo ! side
       enddo ! dir2

       return
       end subroutine FORT_EXTRAPFILL


       subroutine FORT_STATEFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module

       IMPLICIT NONE

       INTEGER_T, intent(in) :: scomp,ncomp,bfact,level
       INTEGER_T, intent(in) :: DIMDEC(u)
       INTEGER_T, intent(in) :: domlo(SDIM),domhi(SDIM)
       REAL_T, intent(in) :: dx(SDIM), xlo(SDIM), time
       REAL_T, intent(inout) :: u(DIMV(u))
       INTEGER_T, intent(in) :: bc(SDIM,2)
       INTEGER_T i,j,k
       INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
       INTEGER_T fablo(SDIM)
       INTEGER_T fabhi(SDIM)
       INTEGER_T borderlo(3)
       INTEGER_T borderhi(3)
       INTEGER_T IWALL(3)
       INTEGER_T im,istate
       INTEGER_T icomplo,icomphi
       INTEGER_T scomp_spec,num_state_material_test
       INTEGER_T dencomp
       INTEGER_T nhalf
       REAL_T xsten(-3:3,SDIM)

       nhalf=3
       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif
       if ((level.lt.0).or.(level.gt.fort_finest_level)) then
        print *,"level invalid in fill 14"
        stop
       endif

       if (ncomp.ne.1) then
        print *,"ncomp invalid15"
        stop
       endif
        ! c++ index
       icomplo=num_materials_vel*(SDIM+1)
       icomphi=icomplo+num_materials*num_state_material
       if ((scomp.lt.icomplo).or.(scomp.ge.icomphi)) then
        print *,"scomp out of range in state fill"
        stop
       endif
       im=(scomp-icomplo)/num_state_material+1
       if ((im.lt.1).or.(im.gt.num_materials)) then
        print *,"im out of range"
        stop
       endif
        ! c++ convention
       dencomp=icomplo+(im-1)*num_state_material
  
        ! fortran convention
       istate=scomp-dencomp+1
       if ((istate.lt.1).or.(istate.gt.num_state_material)) then
        print *,"istate invalid"
        stop
       endif

         ! fortran convention
       scomp_spec=num_state_base+1
       num_state_material_test=scomp_spec+num_species_var-1

       if (num_state_base.ne.2) then
        print *,"num_state_base invalid"
        stop
       endif
   
       if (num_state_material_test.ne.num_state_material) then
        print *,"num_state_material invalid"
        stop
       endif

       call filcc(bfact, &
        u,DIMS(u), &
        domlo,domhi,bc)

       fablo(1)=ARG_L1(u)
       fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
       fablo(SDIM)=ARG_L3(u)
#endif
       fabhi(1)=ARG_H1(u)
       fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
       fabhi(SDIM)=ARG_H3(u)
#endif

       do dir2=1,SDIM
        if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
         print *,"domlo not divisible by bfact"
         stop
        endif
        if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
         print *,"domhi+1 not divisible by bfact"
         stop
        endif
       enddo  ! dir2

       do dir2=1,SDIM
       do side=1,2

        borderlo(3)=0
        borderhi(3)=0
        do dir3=1,SDIM
         borderlo(dir3)=fablo(dir3)
         borderhi(dir3)=fabhi(dir3)
        enddo
        ext_dir_flag=0
        if (bc(dir2,side).eq.EXT_DIR) then
         if (side.eq.1) then
          if (fablo(dir2).lt.domlo(dir2)) then
           ext_dir_flag=1
           borderhi(dir2)=domlo(dir2)-1
           inside_index=domlo(dir2)
          endif
         else if (side.eq.2) then
          if (fabhi(dir2).gt.domhi(dir2)) then
           ext_dir_flag=1
           borderlo(dir2)=domhi(dir2)+1
           inside_index=domhi(dir2)
          endif
         else
          print *,"side invalid"
          stop
         endif
        endif

        if (ext_dir_flag.eq.1) then
         do i=borderlo(1),borderhi(1)
         do j=borderlo(2),borderhi(2)
         do k=borderlo(3),borderhi(3)

          call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)
          IWALL(1)=i
          IWALL(2)=j
          IWALL(3)=k
          IWALL(dir2)=inside_index

          if ((istate.ge.1).and. &
              (istate.le.num_state_material)) then
           call denBC(time,dir2,side, &
            u(D_DECL(i,j,k)), &
            u(D_DECL(IWALL(1),IWALL(2),IWALL(3))), &
            xsten,nhalf,dx,bfact,istate,im)
          else
           print *,"istate not supported"
           stop
          endif
         enddo
         enddo
         enddo
        endif            
       enddo ! side
       enddo ! dir2

       return
       end subroutine FORT_STATEFILL


       subroutine FORT_TENSORFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module

       IMPLICIT NONE

       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u))
       INTEGER_T bc(SDIM,2)
       INTEGER_T i,j,k
       INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
       INTEGER_T fablo(SDIM)
       INTEGER_T fabhi(SDIM)
       INTEGER_T borderlo(3)
       INTEGER_T borderhi(3)
       INTEGER_T IWALL(3)
       INTEGER_T im,ipart
       INTEGER_T icomplo,icomphi
       INTEGER_T nhalf
       REAL_T xsten(-3:3,SDIM)

       nhalf=3
       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif
       if ((level.lt.0).or.(level.gt.fort_finest_level)) then
        print *,"level invalid in fill 14"
        stop
       endif


       if (ncomp.ne.1) then
        print *,"ncomp invalid16"
        stop
       endif
        ! c++ index
       icomplo=0
       icomphi=num_materials_viscoelastic*FORT_NUM_TENSOR_TYPE
       if ((scomp.lt.icomplo).or.(scomp.ge.icomphi)) then
        print *,"scomp out of range in tensor fill"
        stop
       endif

       ipart=(scomp-icomplo)/FORT_NUM_TENSOR_TYPE+1
       if ((ipart.lt.1).or. &
           (ipart.gt.num_materials_viscoelastic)) then
        print *,"ipart out of range"
        stop
       endif
       im=fort_im_elastic_map(ipart)+1
       if ((im.ge.1).and.(im.le.num_materials)) then

        call filcc(bfact, &
         u,DIMS(u), &
         domlo,domhi,bc)

        fablo(1)=ARG_L1(u)
        fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
        fablo(SDIM)=ARG_L3(u)
#endif
        fabhi(1)=ARG_H1(u)
        fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
        fabhi(SDIM)=ARG_H3(u)
#endif

        do dir2=1,SDIM
         if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
          print *,"domlo not divisible by bfact"
          stop
         endif
         if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
          print *,"domhi+1 not divisible by bfact"
          stop
         endif
        enddo  ! dir2

        do dir2=1,SDIM
        do side=1,2

         borderlo(3)=0
         borderhi(3)=0
         do dir3=1,SDIM
          borderlo(dir3)=fablo(dir3)
          borderhi(dir3)=fabhi(dir3)
         enddo
         ext_dir_flag=0
         if (bc(dir2,side).eq.EXT_DIR) then
          if (side.eq.1) then
           if (fablo(dir2).lt.domlo(dir2)) then
            ext_dir_flag=1
            borderhi(dir2)=domlo(dir2)-1
            inside_index=domlo(dir2)
           endif
          else if (side.eq.2) then
           if (fabhi(dir2).gt.domhi(dir2)) then
            ext_dir_flag=1
            borderlo(dir2)=domhi(dir2)+1
            inside_index=domhi(dir2)
           endif
          else
           print *,"side invalid"
           stop
          endif
         endif

         if (ext_dir_flag.eq.1) then
          do i=borderlo(1),borderhi(1)
          do j=borderlo(2),borderhi(2)
          do k=borderlo(3),borderhi(3)

           call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)
           IWALL(1)=i
           IWALL(2)=j
           IWALL(3)=k
           IWALL(dir2)=inside_index

           call tensorBC(time,dir2,side, &
            u(D_DECL(i,j,k)), &
            u(D_DECL(IWALL(1),IWALL(2),IWALL(3))), &
            xsten,nhalf,dx,bfact,ipart,im)
          enddo
          enddo
          enddo
         endif            
        enddo ! side
        enddo ! dir2
       else
        print *,"im invalid in TENSORFILL"
        stop
       endif

       return
       end subroutine FORT_TENSORFILL


       subroutine FORT_XDISPLACEFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module

       IMPLICIT NONE

       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u))
       INTEGER_T bc(SDIM,2)
       INTEGER_T i,j,k
       INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
       INTEGER_T fablo(SDIM)
       INTEGER_T fabhi(SDIM)
       INTEGER_T borderlo(3)
       INTEGER_T borderhi(3)
       INTEGER_T IWALL(3)
       INTEGER_T icomplo,icomphi
       INTEGER_T nhalf
       REAL_T xsten(-3:3,SDIM)
       INTEGER_T dir_xdisplace

       nhalf=3
       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif
       if ((level.lt.0).or.(level.gt.fort_finest_level)) then
        print *,"level invalid in fill 14"
        stop
       endif


       if (ncomp.ne.1) then
        print *,"ncomp invalid16"
        stop
       endif
        ! c++ index
       icomplo=num_materials_viscoelastic*FORT_NUM_TENSOR_TYPE
       icomphi=num_materials_viscoelastic*FORT_NUM_TENSOR_TYPE+SDIM
       if ((scomp.lt.icomplo).or.(scomp.ge.icomphi)) then
        print *,"scomp out of range in xdisplace fill"
        stop
       endif
       dir_xdisplace=scomp-icomplo+1

       call filcc(bfact, &
         u,DIMS(u), &
         domlo,domhi,bc)

       fablo(1)=ARG_L1(u)
       fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
       fablo(SDIM)=ARG_L3(u)
#endif
       fabhi(1)=ARG_H1(u)
       fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
       fabhi(SDIM)=ARG_H3(u)
#endif

       do dir2=1,SDIM
         if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
          print *,"domlo not divisible by bfact"
          stop
         endif
         if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
          print *,"domhi+1 not divisible by bfact"
          stop
         endif
       enddo  ! dir2

       do dir2=1,SDIM
       do side=1,2

         borderlo(3)=0
         borderhi(3)=0
         do dir3=1,SDIM
          borderlo(dir3)=fablo(dir3)
          borderhi(dir3)=fabhi(dir3)
         enddo
         ext_dir_flag=0
         if (bc(dir2,side).eq.EXT_DIR) then
          if (side.eq.1) then
           if (fablo(dir2).lt.domlo(dir2)) then
            ext_dir_flag=1
            borderhi(dir2)=domlo(dir2)-1
            inside_index=domlo(dir2)
           endif
          else if (side.eq.2) then
           if (fabhi(dir2).gt.domhi(dir2)) then
            ext_dir_flag=1
            borderlo(dir2)=domhi(dir2)+1
            inside_index=domhi(dir2)
           endif
          else
           print *,"side invalid"
           stop
          endif
         endif

         if (ext_dir_flag.eq.1) then
          do i=borderlo(1),borderhi(1)
          do j=borderlo(2),borderhi(2)
          do k=borderlo(3),borderhi(3)

           call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)
           IWALL(1)=i
           IWALL(2)=j
           IWALL(3)=k
           IWALL(dir2)=inside_index

           call xdisplaceBC(time,dir2,side, &
            u(D_DECL(i,j,k)), &
            u(D_DECL(IWALL(1),IWALL(2),IWALL(3))), &
            xsten,nhalf,dx,bfact,dir_xdisplace)
          enddo
          enddo
          enddo
         endif            
       enddo ! side
       enddo ! dir2

       return
       end subroutine FORT_XDISPLACEFILL

       subroutine FORT_PRESSUREFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module

       IMPLICIT NONE

       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u))
       INTEGER_T bc(SDIM,2)
       INTEGER_T i,j,k
       INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
       INTEGER_T fablo(SDIM)
       INTEGER_T fabhi(SDIM)
       INTEGER_T borderlo(3)
       INTEGER_T borderhi(3)
       INTEGER_T IWALL(3)
       INTEGER_T nhalf
       REAL_T xsten(-3:3,SDIM)

       nhalf=3
       if (ncomp.ne.1) then
        print *,"ncomp invalid17"
        stop
       endif
       if ((scomp.ne.num_materials_vel*SDIM).and.(scomp.ne.0)) then 
        print *,"scomp invalid pressure fill"
        stop
       endif
       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif
       if ((level.lt.0).or.(level.gt.fort_finest_level)) then
        print *,"level invalid in fill 15"
        stop
       endif

       call filcc(bfact, &
        u,DIMS(u), &
        domlo,domhi,bc)

       fablo(1)=ARG_L1(u)
       fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
       fablo(SDIM)=ARG_L3(u)
#endif
       fabhi(1)=ARG_H1(u)
       fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
       fabhi(SDIM)=ARG_H3(u)
#endif

       do dir2=1,SDIM
        if ((domlo(dir2)/bfact)*bfact.ne.domlo(dir2)) then
         print *,"domlo not divisible by bfact"
         stop
        endif
        if (((domhi(dir2)+1)/bfact)*bfact.ne.domhi(dir2)+1) then
         print *,"domhi+1 not divisible by bfact"
         stop
        endif
       enddo  ! dir2

       do dir2=1,SDIM
       do side=1,2
        borderlo(3)=0
        borderhi(3)=0
        do dir3=1,SDIM
         borderlo(dir3)=fablo(dir3)
         borderhi(dir3)=fabhi(dir3)
        enddo
        ext_dir_flag=0
        if (bc(dir2,side).eq.EXT_DIR) then
         if (side.eq.1) then
          if (fablo(dir2).lt.domlo(dir2)) then
           ext_dir_flag=1
           borderhi(dir2)=domlo(dir2)-1
           inside_index=domlo(dir2)
          endif
         else if (side.eq.2) then
          if (fabhi(dir2).gt.domhi(dir2)) then
           ext_dir_flag=1
           borderlo(dir2)=domhi(dir2)+1
           inside_index=domhi(dir2)
          endif
         else
          print *,"side invalid"
          stop
         endif
        endif

        if (ext_dir_flag.eq.1) then
         do i=borderlo(1),borderhi(1)
         do j=borderlo(2),borderhi(2)
         do k=borderlo(3),borderhi(3)

          call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)
          IWALL(1)=i
          IWALL(2)=j
          IWALL(3)=k
          IWALL(dir2)=inside_index

          call presBDRYCOND(time,dir2,side, &
            u(D_DECL(i,j,k)), &
            u(D_DECL(IWALL(1),IWALL(2),IWALL(3))), &
            xsten,nhalf,dx,bfact)
         enddo
         enddo
         enddo
        endif            
       enddo ! side
       enddo ! dir2

       return
       end subroutine FORT_PRESSUREFILL

       subroutine FORT_GROUP_STATEFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module

       IMPLICIT NONE

       INTEGER_T, intent(in) :: scomp,ncomp,bfact,level
       INTEGER_T, intent(in) :: DIMDEC(u)
       INTEGER_T, intent(in) :: domlo(SDIM),domhi(SDIM)
       REAL_T, intent(in) :: dx(SDIM), xlo(SDIM), time
       REAL_T, intent(inout) :: u(DIMV(u),ncomp)
       INTEGER_T, intent(in) :: bc(SDIM,2,ncomp)
       INTEGER_T i,j,k
       INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
       INTEGER_T fablo(SDIM)
       INTEGER_T fabhi(SDIM)
       INTEGER_T borderlo(3)
       INTEGER_T borderhi(3)
       INTEGER_T IWALL(3)
       INTEGER_T im,icomp,istate
       INTEGER_T scomp_spec,num_state_material_test
       INTEGER_T nhalf
       REAL_T xsten(-3:3,SDIM)

       nhalf=3

        ! c++ index
       if (scomp.ne.num_materials_vel*(SDIM+1)) then
        print *,"scomp invalid group statefill"
        stop
       endif
       if (ncomp.ne.num_state_material*num_materials) then
        print *,"ncomp invalid18"
        stop
       endif
       if (num_state_base.ne.2) then
        print *,"num_state_base invalid"
        stop
       endif
       if ((level.lt.0).or.(level.gt.fort_finest_level)) then
        print *,"level invalid in fill 16"
        stop
       endif
       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif

         ! fortran convention
       scomp_spec=num_state_base+1
       num_state_material_test=scomp_spec+num_species_var-1

       if (num_state_material_test.ne.num_state_material) then
        print *,"num_state_material invalid"
        stop
       endif
       

       fablo(1)=ARG_L1(u)
       fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
       fablo(SDIM)=ARG_L3(u)
#endif
       fabhi(1)=ARG_H1(u)
       fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
       fabhi(SDIM)=ARG_H3(u)
#endif

       do icomp=1,num_state_material*num_materials
        call filcc(bfact, &
         u(D_DECL(fablo(1),fablo(2),fablo(SDIM)),icomp), &
         DIMS(u), &
         domlo,domhi,bc(1,1,icomp))
       enddo

       do dir2=1,SDIM
       do side=1,2

       icomp=0 
       do im=1,num_materials
       do istate=1,num_state_material
        icomp=icomp+1

        borderlo(3)=0
        borderhi(3)=0
        do dir3=1,SDIM
         borderlo(dir3)=fablo(dir3)
         borderhi(dir3)=fabhi(dir3)
        enddo
        ext_dir_flag=0
        if (bc(dir2,side,icomp).eq.EXT_DIR) then
         if (side.eq.1) then
          if (fablo(dir2).lt.domlo(dir2)) then
           ext_dir_flag=1
           borderhi(dir2)=domlo(dir2)-1
           inside_index=domlo(dir2)
          endif
         else if (side.eq.2) then
          if (fabhi(dir2).gt.domhi(dir2)) then
           ext_dir_flag=1
           borderlo(dir2)=domhi(dir2)+1
           inside_index=domhi(dir2)
          endif
         else
          print *,"side invalid"
          stop
         endif
        endif

        if (ext_dir_flag.eq.1) then
         do i=borderlo(1),borderhi(1)
         do j=borderlo(2),borderhi(2)
         do k=borderlo(3),borderhi(3)

          call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)
          IWALL(1)=i
          IWALL(2)=j
          IWALL(3)=k
          IWALL(dir2)=inside_index

          if ((istate.ge.1).and. &
              (istate.le.num_state_material)) then
           call denBC(time,dir2,side, &
            u(D_DECL(i,j,k),icomp), &
            u(D_DECL(IWALL(1),IWALL(2),IWALL(3)),icomp), &
            xsten,nhalf,dx,bfact,istate,im)
          else
           print *,"istate not supported"
           stop
          endif
         enddo
         enddo
         enddo
        endif            
       enddo ! istate
       enddo ! im

       enddo ! side
       enddo ! dir2

       return
       end subroutine FORT_GROUP_STATEFILL


       subroutine FORT_GROUP_TENSORFILL ( &
        level, &
        u,DIMS(u), &
        domlo,domhi,dx, &
        xlo,time,bc,scomp,ncomp,bfact)

       use probf90_module
       use global_utility_module

       IMPLICIT NONE

       INTEGER_T scomp,ncomp,bfact,level
       INTEGER_T DIMDEC(u)
       INTEGER_T domlo(SDIM),domhi(SDIM)
       REAL_T  dx(SDIM), xlo(SDIM), time
       REAL_T  u(DIMV(u),ncomp)
       INTEGER_T bc(SDIM,2,ncomp)
       INTEGER_T i,j,k
       INTEGER_T dir2,dir3,side,ext_dir_flag,inside_index
       INTEGER_T fablo(SDIM)
       INTEGER_T fabhi(SDIM)
       INTEGER_T borderlo(3)
       INTEGER_T borderhi(3)
       INTEGER_T IWALL(3)
       INTEGER_T ipart,im,icomp,istate
       INTEGER_T nhalf
       REAL_T xsten(-3:3,SDIM)

       nhalf=3

        ! c++ index
       if ((scomp.eq.0).or. &
           (scomp.eq.num_materials_viscoelastic*FORT_NUM_TENSOR_TYPE)) then
        ! do nothing
       else
        print *,"scomp invalid group tensorfill"
        print *,"scomp=",scomp
        print *,"ncomp=",ncomp
        print *,"num_materials_viscoelastic=",num_materials_viscoelastic
        print *,"FORT_NUM_TENSOR_TYPE= ",FORT_NUM_TENSOR_TYPE
        print *,"level=",level
        print *,"fort_finest_level=",fort_finest_level
        stop
       endif
       if ((ncomp.eq.num_materials_viscoelastic*FORT_NUM_TENSOR_TYPE+ &
            SDIM).or. &
           (ncomp.eq.num_materials_viscoelastic*FORT_NUM_TENSOR_TYPE).or. &
           (ncomp.eq.SDIM)) then
        ! do nothing
       else
        print *,"ncomp invalid19 ncomp=",ncomp
        print *,"num_materials_viscoelastic=",num_materials_viscoelastic
        print *,"scomp=",scomp
        stop
       endif
       if (scomp+ncomp.le. &
           num_materials_viscoelastic*FORT_NUM_TENSOR_TYPE+SDIM) then
        ! do nothing
       else
        print *,"scomp+ncomp invalid19"
        stop
       endif

       if ((level.lt.0).or.(level.gt.fort_finest_level)) then
        print *,"level invalid in fill 16"
        stop
       endif
       if (bfact.lt.1) then
        print *,"bfact invalid200"
        stop
       endif

       fablo(1)=ARG_L1(u)
       fablo(2)=ARG_L2(u)
#if (AMREX_SPACEDIM==3)
       fablo(SDIM)=ARG_L3(u)
#endif
       fabhi(1)=ARG_H1(u)
       fabhi(2)=ARG_H2(u)
#if (AMREX_SPACEDIM==3)
       fabhi(SDIM)=ARG_H3(u)
#endif

       do icomp=scomp+1,scomp+ncomp
        call filcc(bfact, &
         u(D_DECL(fablo(1),fablo(2),fablo(SDIM)),icomp-scomp), &
         DIMS(u), &
         domlo,domhi,bc(1,1,icomp-scomp))
       enddo

       do dir2=1,SDIM
       do side=1,2

       icomp=0 
       do ipart=1,num_materials_viscoelastic
       do istate=1,FORT_NUM_TENSOR_TYPE

        icomp=icomp+1

        if ((icomp.ge.scomp+1).and. &
            (icomp.le.scomp+ncomp)) then

         im=fort_im_elastic_map(ipart)+1

         borderlo(3)=0
         borderhi(3)=0
         do dir3=1,SDIM
          borderlo(dir3)=fablo(dir3)
          borderhi(dir3)=fabhi(dir3)
         enddo
         ext_dir_flag=0
         if (bc(dir2,side,icomp-scomp).eq.EXT_DIR) then
          if (side.eq.1) then
           if (fablo(dir2).lt.domlo(dir2)) then
            ext_dir_flag=1
            borderhi(dir2)=domlo(dir2)-1
            inside_index=domlo(dir2)
           endif
          else if (side.eq.2) then
           if (fabhi(dir2).gt.domhi(dir2)) then
            ext_dir_flag=1
            borderlo(dir2)=domhi(dir2)+1
            inside_index=domhi(dir2)
           endif
          else
           print *,"side invalid"
           stop
          endif
         endif

         if (ext_dir_flag.eq.1) then
          do i=borderlo(1),borderhi(1)
          do j=borderlo(2),borderhi(2)
          do k=borderlo(3),borderhi(3)

           call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)
           IWALL(1)=i
           IWALL(2)=j
           IWALL(3)=k
           IWALL(dir2)=inside_index

           call tensorBC(time,dir2,side, &
            u(D_DECL(i,j,k),icomp-scomp), &
            u(D_DECL(IWALL(1),IWALL(2),IWALL(3)),icomp-scomp), &
            xsten,nhalf,dx,bfact,ipart,im)
          enddo
          enddo
          enddo
         else if (ext_dir_flag.eq.0) then
          ! do nothing
         else
          print *,"ext_dir_flag invalid"
          stop
         endif  
        else if ((icomp.ge.1).and. &
                 (icomp.le. &
                  num_materials_viscoelastic*FORT_NUM_TENSOR_TYPE)) then
         ! do nothing
        else
         print *,"icomp invalid"
         stop
        endif
       enddo ! istate
       enddo ! ipart

       if (icomp.eq.num_materials_viscoelastic*FORT_NUM_TENSOR_TYPE) then

        do istate=1,SDIM

         icomp=num_materials_viscoelastic*FORT_NUM_TENSOR_TYPE+istate

         if ((icomp.ge.scomp+1).and. &
             (icomp.le.scomp+ncomp)) then

          borderlo(3)=0
          borderhi(3)=0
          do dir3=1,SDIM
           borderlo(dir3)=fablo(dir3)
           borderhi(dir3)=fabhi(dir3)
          enddo
          ext_dir_flag=0
          if (bc(dir2,side,icomp-scomp).eq.EXT_DIR) then
           if (side.eq.1) then
            if (fablo(dir2).lt.domlo(dir2)) then
             ext_dir_flag=1
             borderhi(dir2)=domlo(dir2)-1
             inside_index=domlo(dir2)
            endif
           else if (side.eq.2) then
            if (fabhi(dir2).gt.domhi(dir2)) then
             ext_dir_flag=1
             borderlo(dir2)=domhi(dir2)+1
             inside_index=domhi(dir2)
            endif
           else
            print *,"side invalid"
            stop
           endif
          endif

          if (ext_dir_flag.eq.1) then
           do i=borderlo(1),borderhi(1)
           do j=borderlo(2),borderhi(2)
           do k=borderlo(3),borderhi(3)

            call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)
            IWALL(1)=i
            IWALL(2)=j
            IWALL(3)=k
            IWALL(dir2)=inside_index

            call xdisplaceBC(time,dir2,side, &
             u(D_DECL(i,j,k),icomp-scomp), &
             u(D_DECL(IWALL(1),IWALL(2),IWALL(3)),icomp-scomp), &
             xsten,nhalf,dx,bfact,istate)
           enddo
           enddo
           enddo
          else if (ext_dir_flag.eq.0) then
           ! do nothing
          else
           print *,"ext_dir_flag invalid"
           stop
          endif  
         else if ((icomp.ge. &
                   num_materials_viscoelastic*FORT_NUM_TENSOR_TYPE+1).and. &
                  (icomp.le. &
                   num_materials_viscoelastic*FORT_NUM_TENSOR_TYPE+SDIM)) then
          ! do nothing
         else
          print *,"icomp invalid"
          stop
         endif            

        enddo ! istate=1..sdim

       else
        print *,"icomp invalid"
        stop
       endif

       enddo ! side
       enddo ! dir2

       return
       end subroutine FORT_GROUP_TENSORFILL



       module initdata_module
       use supercooled_exact_sol
       use probf90_module
       use global_utility_module

       implicit none

       REAL_T lowerdiag(1000),upperdiag(1000),diag(1000),soln(1000)
       REAL_T rhs(1000)
       REAL_T xlodiss,xhidiss,dtdiss,posdiss,concentration
       REAL_T concen1,concen2,theta
       INTEGER_T ndiss,ispace

       contains

       subroutine init_initdata(nmat,nten,nc, &
         latent_heat, &
         freezing_model, &
         distribute_from_target, &
         saturation_temp, &
         dx)
       IMPLICIT NONE

       INTEGER_T nmat,nten,nc
       INTEGER_T nc_expect
       INTEGER_T nten_test
       REAL_T dx(SDIM)
       REAL_T latent_heat(2*nten)
       INTEGER_T freezing_model(2*nten)
       INTEGER_T distribute_from_target(2*nten)
       REAL_T saturation_temp(2*nten)
       REAL_T lmSt

       INTEGER_T ireverse,im,im_opp,iten,local_freezing_model
       INTEGER_T im_source,im_dest
       REAL_T LL,TSAT
       REAL_T cp_source,k_source,TDIFF,rho_source,rho_dest
       REAL_T T_extreme
       REAL_T den_ratio
       INTEGER_T im_solid_initdata

       im_solid_initdata=im_solid_primary()

       if (nmat.ne.num_materials) then
        print *,"nmat invalid"
        stop
       endif
       nten_test=( (nmat-1)*(nmat-1)+nmat-1 )/2
       if (nten_test.ne.nten) then
        print *,"nten invalid initdata nten nten test", &
          nten,nten_test
        stop
       endif
       nc_expect=num_materials_vel*(SDIM+1)+ &
        nmat*num_state_material+nmat*ngeom_raw+1
       if (nc.ne.nc_expect) then
        print *,"fort: nc invalid"
        stop
       endif

       if (probtype.eq.802) then ! dissolution
        xlodiss=zero
        xhidiss=radblob
        ndiss=NINT(radblob/dx(SDIM))-1
        if (ndiss.ge.1000) then
         print *,"ndiss too big"
         stop
        endif
        xhidiss=ndiss*dx(SDIM)
        dtdiss=one

        do ispace=1,ndiss-1 
         lowerdiag(ispace)=denfact/(dx(SDIM)**2)
         upperdiag(ispace)=denfact/(dx(SDIM)**2)
         diag(ispace)=-lowerdiag(ispace)-upperdiag(ispace)-1.0/dtdiss
         rhs(ispace)=zero
         if (ispace.eq.1) then
          rhs(ispace)=rhs(ispace)-lowerdiag(ispace)
         endif
        enddo
         ! in: GLOBALUTIL.F90
        call tridiag_solve(lowerdiag,upperdiag,diag,ndiss-1,rhs,soln)
       endif  ! probtype=802

       do ireverse=0,1
       do im=1,nmat-1
       do im_opp=im+1,nmat
        if ((im.gt.nmat).or.(im_opp.gt.nmat)) then
         print *,"im or im_opp bust 8"
         stop
        endif
        call get_iten(im,im_opp,iten,nmat)
        LL=latent_heat(iten+ireverse*nten)
        local_freezing_model=freezing_model(iten+ireverse*nten)
        TSAT=saturation_temp(iten+ireverse*nten)
        if ((local_freezing_model.eq.2).and. &
            (num_species_var.ne.1)) then
         print *,"must define species var if hydrate model"
         stop
        endif

        fort_alpha(iten+ireverse*nten)=zero
        fort_beta(iten+ireverse*nten)=zero
        fort_expansion_factor(iten+ireverse*nten)=zero
        fort_stefan_number(iten+ireverse*nten)=zero
        fort_jacob_number(iten+ireverse*nten)=zero
        fort_time_radblob(iten+ireverse*nten)=zero

        if ((is_rigid(nmat,im).eq.1).or. &
            (is_rigid(nmat,im_opp).eq.1)) then
         ! do nothing
        else if (LL.ne.zero) then

         if (ireverse.eq.0) then
          im_source=im
          im_dest=im_opp
         else if (ireverse.eq.1) then
          im_source=im_opp
          im_dest=im
         else
          print *,"ireverse invalid"
          stop
         endif
          ! we find the rate for the "sucking" problem which
          ! has a thin thermal layer (interface moves towards the source).
         cp_source=get_user_stiffCP(im_source) ! J/Kelvin
         k_source=get_user_heatviscconst(im_source) ! W/(m Kelvin)

          ! in: init_initdata
         if ((im_source.ge.1).and.(im_source.le.nmat).and. &
             (im_dest.ge.1).and.(im_dest.le.nmat)) then
          T_extreme=fort_tempconst(im_source)
          if (fort_tempconst(im_dest).gt.T_extreme) then
           T_extreme=fort_tempconst(im_dest)
          endif
          if ((im_solid_initdata.ge.1).and. &
              (im_solid_initdata.le.nmat)) then
           if (fort_tempconst(im_solid_initdata).gt.T_extreme) then
            T_extreme=fort_tempconst(im_solid_initdata)
           endif
          else if (im_solid_initdata.eq.0) then
           ! do nothing
          else
           print *,"im_solid_initdata invalid"
           stop
          endif
         else
          print *,"im_source or im_dest invalid"
          stop
         endif
 
         TDIFF=abs(T_extreme-TSAT)

         rho_source=fort_denconst(im_source) ! kg/m^3 
         rho_dest=fort_denconst(im_dest) ! kg/m^3 
         den_ratio=max(rho_dest,rho_source)/min(rho_dest,rho_source)
         if ((den_ratio.gt.1.0D+5).or.(den_ratio.lt.one)) then
          print *,"den_ratio invalid"
          stop
         endif

         if (distribute_from_target(iten+ireverse*nten).eq.0) then
          fort_expansion_factor(iten+ireverse*nten)=one-rho_dest/rho_source
         else if (distribute_from_target(iten+ireverse*nten).eq.1) then
          fort_expansion_factor(iten+ireverse*nten)=one-rho_source/rho_dest
         else
          print *,"distribute_from_target invalid"
          stop
         endif


         ! (W/(m Kelvin))/((kg/m^3)(J/(kg Kelvin)))
         ! (J/(s m Kelvin))/((1/m^3)(J/Kelvin))
         ! (1/(s m))/(1/m^3)
         ! (1/(s))/(1/m^2)=m^2/s
         fort_alpha(iten+ireverse*nten)=k_source/(rho_source*cp_source) 

         ! (J/(kg Kelvin)) Kelvin/(J/kg)=1
         fort_stefan_number(iten+ireverse*nten)=cp_source*TDIFF/abs(LL)
        
         fort_jacob_number(iten+ireverse*nten)=(rho_source/rho_dest)* &
            fort_stefan_number(iten+ireverse*nten)

         ! solidification
         ! circular freeze.
         if (den_ratio.lt.10.0) then
          call find_lambda(lmSt,fort_stefan_number(iten+ireverse*nten))

         ! spherical boiling
         else if (den_ratio.ge.10.0) then

          call find_beta(lmSt,den_ratio,fort_jacob_number(iten+ireverse*nten))

         else
          print *,"den_ratio bust"
          stop
         endif

         fort_beta(iten+ireverse*nten)=lmSt

          ! sqrt(alpha time_radblob)*two*lmSt=radblob 
         call solidification_front_time(lmSt, &
          fort_alpha(iten+ireverse*nten), &
          fort_time_radblob(iten+ireverse*nten), &
          radblob)

         print *,"iten,ireverse ",iten,ireverse
         print *,"im_source,im_dest ",im_source,im_dest 
         print *,"fort_expansion_factor= ", &
          fort_expansion_factor(iten+ireverse*nten)
         print *,"distribute_from_target= ", &
          distribute_from_target(iten+ireverse*nten)
         print *,"den_ratio= ",den_ratio
         print *,"Stefan_number= ",fort_stefan_number(iten+ireverse*nten)
         print *,"Jacob_number= ",fort_jacob_number(iten+ireverse*nten)
         print *,"lmSt= ",lmSt
         print *,"alpha= ",fort_alpha(iten+ireverse*nten)
         print *,"beta= ",fort_beta(iten+ireverse*nten)
         print *,"time_radblob is the time for the front to grow from"
         print *,"r=0 to r=radblob"
         print *,"time_radblob=",fort_time_radblob(iten+ireverse*nten)
         print *,"radius doubling time=4 * time_radblob - time_radblob=", &
          three*fort_time_radblob(iten+ireverse*nten)
         print *,"front location: 2 beta sqrt(alpha t) "
        else if (LL.eq.zero) then
         ! do nothing
        else
         print *,"LL invalid"
         stop
        endif
       enddo ! im_opp
       enddo ! im
       enddo ! ireverse

       return
       end subroutine init_initdata


       end module initdata_module

       subroutine FORT_INITGRIDMAP( &
        max_level, &
        bfact_space_level, & 
        bfact_grid_level, & 
        domlo,domhi, &
        dx, &
        problo,probhi)
       use probf90_module
       use global_utility_module

       IMPLICIT NONE

       INTEGER_T max_level
       INTEGER_T bfact_space_level(0:max_level)
       INTEGER_T bfact_grid_level(0:max_level)
       INTEGER_T domlo(SDIM)
       INTEGER_T domhi(SDIM)
       REAL_T dx(SDIM)
       REAL_T problo(SDIM)
       REAL_T probhi(SDIM)
       REAL_T xsten(-1:1)
       INTEGER_T nhalf
       INTEGER_T bfactmax
       INTEGER_T ilev,max_ncell,dir,inode,i
       INTEGER_T ncell(SDIM)
       REAL_T dxlevel(SDIM)
       INTEGER_T domlo_level(SDIM)
       INTEGER_T domhi_level(SDIM)

       nhalf=1

       if (max_level.lt.0) then
        print *,"max_level invalid"
        stop
       endif

       bfactmax=0
       do ilev=0,max_level
        if ((bfact_space_level(ilev).lt.1).or. &
            (bfact_grid_level(ilev).lt.2)) then
         print *,"bfact invalid200 in initgridmap"
         stop
        endif
        if (bfact_space_level(ilev).gt.bfactmax) then
         bfactmax=bfact_space_level(ilev)
        endif
        if (bfact_grid_level(ilev).gt.bfactmax) then
         bfactmax=bfact_grid_level(ilev)
        endif
       enddo ! ilev

       max_ncell=0
       do dir=1,SDIM
        if (domlo(dir).ne.0) then
         print *,"domlo invalid"
         stop
        endif
        ncell(dir)=domhi(dir)-domlo(dir)+1
        if (ncell(dir).lt.2) then
         print *,"ncell invalid"
         stop
        endif
        if (ncell(dir).gt.max_ncell) then
         max_ncell=ncell(dir)
        endif
       enddo ! dir

       if (max_ncell.lt.2) then
        print *,"max_ncell invalid"
        stop
       endif

       do ilev=1,max_level
        max_ncell=max_ncell*2
       enddo

       if (bfactmax.lt.8) then
        bfactmax=8
       endif

       if (grid_cache_allocated.eq.0) then

        cache_index_low=-4*bfactmax
        cache_index_high=2*max_ncell+4*bfactmax
        cache_max_level=max_level

        print *,"allocate grid_cache"
        do dir=1,SDIM
         print *,"dir,domlo,domhi ",dir,domlo(dir),domhi(dir)
         print *,"dir,problo,probhi ",dir,problo(dir),probhi(dir)
         print *,"dir,dx ",dir,dx(dir)
        enddo
        print *,"cache_index_low ",cache_index_low
        print *,"cache_index_high ",cache_index_high
        print *,"bfactmax,max_ncell ",bfactmax,max_ncell

        allocate(grid_cache(0:cache_max_level, &
         cache_index_low:cache_index_high,SDIM))

        do dir=1,SDIM
         dxlevel(dir)=dx(dir)
         domlo_level(dir)=domlo(dir)
         domhi_level(dir)=domhi(dir)
        enddo

        do ilev=0,cache_max_level
         do dir=1,SDIM
          if (domlo_level(dir).ne.0) then
           print *,"domlo_level invalid"
           stop
          endif
          do i=domlo_level(dir)-2*bfactmax,domhi_level(dir)+2*bfactmax
           inode=2*i
           if ((inode.lt.cache_index_low).or. &
               (inode+1.gt.cache_index_high)) then
            print *,"icell outside of cache range"
            stop
           endif
           call gridsten1D(xsten,problo,i,domlo, &
            bfact_space_level(ilev),dxlevel,dir,nhalf) 
           grid_cache(ilev,inode,dir)=xsten(0)
           grid_cache(ilev,inode+1,dir)=xsten(1)
           if (1.eq.0) then
            print *,"lev,inode,dir,x,xnxt ",ilev,inode,dir,xsten(0),xsten(1)
           endif
          enddo ! i
         enddo ! dir
         do dir=1,SDIM
          dxlevel(dir)=half*dxlevel(dir)
          domlo_level(dir)=2*domlo_level(dir)
          domhi_level(dir)=2*(domhi_level(dir)+1)-1
         enddo
        enddo !ilev

       else if (grid_cache_allocated.eq.1) then
        ! do nothing
       else
        print *,"grid_cache_allocated invalid"
        stop
       endif

       grid_cache_allocated=1

       return
       end subroutine FORT_INITGRIDMAP

       subroutine FORT_INITDATA_ALLOC( &
        nmat,nten,nc, &
        latent_heat, &
        freezing_model, &
        distribute_from_target, &
        saturation_temp, &
        dx)
       use initdata_module
       IMPLICIT NONE

       INTEGER_T nmat,nten,nc
       REAL_T dx(SDIM)
       REAL_T latent_heat(2*nten)
       INTEGER_T freezing_model(2*nten)
       INTEGER_T distribute_from_target(2*nten)
       REAL_T saturation_temp(2*nten)

       call init_initdata(nmat,nten,nc, &
        latent_heat, &
        freezing_model, &
        distribute_from_target, &
        saturation_temp, &
        dx)

       return
       end subroutine FORT_INITDATA_ALLOC

       subroutine FORT_INITDATA( &
        tid, &
        adapt_quad_depth, &
        level,max_level, &
        time, &
        tilelo,tilehi, &
        fablo,fabhi, &
        bfact, &
        nc, &
        nmat, &
        nten, &
        latent_heat, &
        saturation_temp, &
        radius_cutoff, &
        scal,DIMS(scal), &
        LS,DIMS(LS), &
        dx,xlo,xhi)
       use MOF_routines_module
       use geometry_intersect_module
       use hydrateReactor_module
       use unimaterialChannel_module
       use initdata_module
       use probf90_module
       use global_utility_module
       use global_distance_module
       use shockdrop
       use marangoni
       use CISL_SANITY_MODULE
       use USERDEF_module
       use CAV3D_module
       use HELIX_module
       use TSPRAY_module
       use CAV2Dstep_module
       use ZEYU_droplet_impact_module
       use CONE3D_module
       use WAVY_Channel_module
       use rigid_FSI_module
       use sinking_particle_module
       use stackvolume_module

       IMPLICIT NONE

       INTEGER_T nmat
       INTEGER_T radius_cutoff(nmat)
       INTEGER_T adapt_quad_depth,tid
       INTEGER_T tilelo(SDIM),tilehi(SDIM)
       INTEGER_T fablo(SDIM),fabhi(SDIM)
       INTEGER_T growlo(3),growhi(3)
       INTEGER_T bfact
       INTEGER_T level,max_level
       INTEGER_T nc
       INTEGER_T nten
       INTEGER_T imls
       INTEGER_T impres
       REAL_T latent_heat(2*nten)
       REAL_T saturation_temp(2*nten)
       REAL_T time
       INTEGER_T DIMDEC(scal)
       INTEGER_T DIMDEC(LS)
       REAL_T scal(DIMV(scal),nc)
       REAL_T LS(DIMV(LS),nmat*(1+SDIM))
       REAL_T dx(SDIM)
       REAL_T xlo(SDIM), xhi(SDIM)
       INTEGER_T idenbase,imofbase
       INTEGER_T ierr
       INTEGER_T ibase
       INTEGER_T ic,jc,kc,n,im
       INTEGER_T dir
       REAL_T, dimension(:,:), allocatable :: comparestate
       REAL_T vfracsum_test

       REAL_T fluiddata(nmat,2*SDIM+2)
       REAL_T mofdata(nmat*ngeom_recon)
       REAL_T distbatch(nmat)
       REAL_T LS_stencil(D_DECL(-1:1,-1:1,-1:1),nmat)
       REAL_T err
       REAL_T vofdark(nmat)
       REAL_T voflight(nmat)
       REAL_T cendark(nmat,SDIM)
       REAL_T cenlight(nmat,SDIM)

       INTEGER_T nhalf,nhalf2,nmax
       REAL_T xsten(-3:3,SDIM)
       REAL_T xsten2(-1:1,SDIM)

       INTEGER_T i1,j1,k1,k1lo,k1hi
       REAL_T xpos(SDIM)
       REAL_T scalc(nc)
       REAL_T LSc(nmat*(1+SDIM))
       REAL_T x,y,z,rr
       REAL_T volcell
       REAL_T cencell(SDIM)
       INTEGER_T ipresbase
       
       REAL_T debug_vfrac_sum
       REAL_T vel(SDIM)
       REAL_T temp,dens,ccnt,test_gamma,test_pres
       REAL_T distsolid
       INTEGER_T nten_test

       REAL_T den_jwl_left,den_jwl_right
       REAL_T temp_jwl_left,temp_jwl_right
       REAL_T e_jwl_left,e_jwl_right
       REAL_T p_jwl_left,p_jwl_right
       REAL_T u_jwl_left,u_jwl_right
       REAL_T xshock
       REAL_T den_jwl,denroom,e_jwl,e_room,eps_benard
       REAL_T gamma_jwl
       REAL_T p_hyd,p_jwl,p_room,preshydro,rhohydro
       REAL_T temp_jwl,temp_slope,temproom,u_jwl
       REAL_T water_temp
       INTEGER_T imattype,isten
       INTEGER_T max_levelstack
       INTEGER_T vofcomp_raw
       INTEGER_T vofcomp_recon
       REAL_T jumpval
       REAL_T voflist(nmat)

       INTEGER_T im_source,im_dest,ireverse,iten
       REAL_T L_ice_melt,TSAT,T_EXTREME,cp_melt,k_melt,rstefan
       REAL_T T_FIELD
       REAL_T den_ratio
       REAL_T dxmaxLS
       INTEGER_T stencil_valid
       INTEGER_T im_solid_initdata
       REAL_T lsnormal(nmat,SDIM)
       INTEGER_T lsnormal_valid(nmat)
       REAL_T ls_intercept(nmat)
       INTEGER_T doubly_flag
       REAL_T local_state(nmat*num_state_material)
       REAL_T massfrac_parm(num_species_var+1)
       INTEGER_T local_ibase
       INTEGER_T tessellate
       INTEGER_T bcflag
       INTEGER_T from_boundary_hydrostatic

       from_boundary_hydrostatic=0

       tessellate=0

       bcflag=0

       if ((tid.lt.0).or.(tid.ge.geom_nthreads)) then
        print *,"tid invalid"
        stop
       endif

       if (num_materials_vel.ne.1) then
        print *,"num_materials_vel invalid"
        stop
       endif

       if ((time.ge.zero).and.(time.le.1.0D+20)) then
        ! do nothing
       else if (time.ge.1.0D+20) then
        print *,"WARNING time.ge.1.0D+20 in initdata"
       else if (time.lt.zero) then
        print *,"time invalid in initdata"
        stop
       else
        print *,"time bust in initdata"
        stop
       endif

       call get_dxmaxLS(dx,bfact,dxmaxLS)

       im_solid_initdata=im_solid_primary()

       nmax=POLYGON_LIST_MAX ! in: FORT_INITDATA
       nhalf=3
       nhalf2=1

       if (bfact.lt.1) then
        print *,"bfact too small"
        stop
       endif
       if ((adapt_quad_depth.lt.1).or.(adapt_quad_depth.gt.10)) then
        print *,"adapt_quad_depth invalid"
        stop
       endif
       max_levelstack=adapt_quad_depth

       ipresbase=num_materials_vel*SDIM
       impres=1
       idenbase=num_materials_vel*(SDIM+1)
       imofbase=idenbase+nmat*num_state_material
       ierr=imofbase+nmat*ngeom_raw+1
       if (nc.ne.ierr) then
        print *,"nc invalid"
        stop
       endif
       nten_test=( (nmat-1)*(nmat-1)+nmat-1 )/2
       if (nten_test.ne.nten) then
        print *,"nten invalid initdata nten nten test", &
          nten,nten_test
        stop
       endif
       if (nmat.ne.num_materials) then
        print *,"nmat invalid"
        stop
       endif
       if (nc.ne.ierr) then
        print *,"scal invalid"
        stop
       endif
      
       if (num_state_base.ne.2) then
        print *,"num_state_base invalid"
        stop
       endif

       call checkbound(fablo,fabhi,DIMS(scal),1,-1,1304)
       call checkbound(fablo,fabhi,DIMS(LS),1,-1,1305)

       call growntilebox(tilelo,tilehi,fablo,fabhi,growlo,growhi,0) 

       if (SDIM.eq.2) then
        k1lo=0
        k1hi=0
       else if (SDIM.eq.3) then
        k1lo=-1
        k1hi=1
       else
        print *,"dimension bust"
        stop
       endif

       do ic=growlo(1),growhi(1)
       do jc=growlo(2),growhi(2)
       do kc=growlo(3),growhi(3)
        
        do n=1,nc
         scalc(n)=zero
        enddo
        do imls=1,nmat*(1+SDIM)
         LSc(imls)=zero
        enddo
        volcell=zero
        do dir=1,SDIM
         cencell(dir)=zero
        enddo

        call gridsten(xsten,xlo,ic,jc,kc,fablo,bfact,dx,nhalf)

        x=xsten(0,1)
        y=xsten(0,2)
        z=xsten(0,SDIM)

        do dir=1,SDIM
         xpos(dir)=xsten(0,dir)
        enddo

        call Box_volumeFAST(bfact,dx,xsten,nhalf,volcell,cencell,SDIM)

        do im=1,num_materials_vel
         scalc(ipresbase+im)=zero
        enddo

        if (is_in_probtype_list().eq.1) then

         call SUB_LS(xpos,time,distbatch,num_materials)
             ! bcflag=0 (calling from FORT_INITDATA)
         call SUB_STATE(xpos,time,distbatch,local_state, &
                 bcflag,num_materials,num_state_material)
         do im=1,nmat
          ibase=idenbase+(im-1)*num_state_material
          local_ibase=(im-1)*num_state_material
          scalc(ibase+1)=local_state(local_ibase+1) ! density
          scalc(ibase+2)=local_state(local_ibase+2) ! temperature
          ! species
          do n=1,num_species_var
           scalc(ibase+num_state_base+n)= &
            local_state(local_ibase+num_state_base+n)
          enddo

          if (scalc(ibase+1).gt.zero) then
           ! do nothing
          else
           print *,"density invalid probtype==421 "
           print *,"im,ibase,nmat ",im,ibase,nmat
           print *,"density=",scalc(ibase+1)
           stop
          endif

          if (scalc(ibase+2).gt.zero) then
           ! do nothing
          else
           print *,"temperature invalid probtype==421 "
           print *,"im,ibase,nmat ",im,ibase,nmat
           print *,"temperature=",scalc(ibase+1)
           stop
          endif

         enddo ! im=1..nmat
         call SUB_PRES(xpos,time,distbatch,p_hyd,num_materials)
         scalc(ipresbase+impres)=p_hyd

         if (p_hyd.ge.zero) then
          ! do nothing
         else
          print *,"p_hyd invalid"
          print *,"probtype=",probtype
          print *,"p_hyd=",p_hyd
          stop
         endif

        else if (probtype.eq.411) then

         call CAV3D_LS(xpos,time,distbatch)
         call CAV3D_STATE(xpos,time,distbatch,local_state)
         do im=1,nmat
          ibase=idenbase+(im-1)*num_state_material
          local_ibase=(im-1)*num_state_material
          scalc(ibase+1)=local_state(local_ibase+1) ! density
          scalc(ibase+2)=local_state(local_ibase+2) ! temperature
           ! species
          do n=1,num_species_var
           scalc(ibase+num_state_base+n)= &
            local_state(local_ibase+num_state_base+n)
          enddo
         enddo ! im=1..nmat
         call CAV3D_PRES(xpos,time,distbatch,p_hyd)
         scalc(ipresbase+impres)=p_hyd

        else if (probtype.eq.401) then

         call HELIX_LS(xpos,time,distbatch)
         call HELIX_STATE(xpos,time,distbatch,local_state)
         do im=1,nmat
          ibase=idenbase+(im-1)*num_state_material
          local_ibase=(im-1)*num_state_material
          scalc(ibase+1)=local_state(local_ibase+1) ! density
          scalc(ibase+2)=local_state(local_ibase+2) ! temperature
           ! species
          do n=1,num_species_var
           scalc(ibase+num_state_base+n)= &
            local_state(local_ibase+num_state_base+n)
          enddo
         enddo ! im=1..nmat
         call HELIX_PRES(xpos,time,distbatch,p_hyd)
         scalc(ipresbase+impres)=p_hyd

        else if (probtype.eq.402) then

         call TSPRAY_LS(xpos,time,distbatch)
         call TSPRAY_STATE(xpos,time,distbatch,local_state)
         do im=1,nmat
          ibase=idenbase+(im-1)*num_state_material
          local_ibase=(im-1)*num_state_material
          scalc(ibase+1)=local_state(local_ibase+1) ! density
          scalc(ibase+2)=local_state(local_ibase+2) ! temperature
           ! species
          do n=1,num_species_var
           scalc(ibase+num_state_base+n)= &
            local_state(local_ibase+num_state_base+n)
          enddo
         enddo ! im=1..nmat
         call TSPRAY_PRES(xpos,time,distbatch,p_hyd)
         scalc(ipresbase+impres)=p_hyd

        else if (probtype.eq.412) then ! step

         call CAV2Dstep_LS(xpos,time,distbatch)
         call CAV2Dstep_STATE(xpos,time,distbatch,local_state)
         do im=1,nmat
          ibase=idenbase+(im-1)*num_state_material
          local_ibase=(im-1)*num_state_material
          scalc(ibase+1)=local_state(local_ibase+1) ! density
          scalc(ibase+2)=local_state(local_ibase+2) ! temperature
          ! species
          do n=1,num_species_var
           scalc(ibase+num_state_base+n)= &
            local_state(local_ibase+num_state_base+n)
          enddo
         enddo ! im=1..nmat
         call CAV2Dstep_PRES(xpos,time,distbatch,p_hyd)
         scalc(ipresbase+impres)=p_hyd

        else if (probtype.eq.413) then ! zeyu

         call ZEYU_droplet_impact_LS(xpos,time,distbatch)
         call ZEYU_droplet_impact_STATE(xpos,time,distbatch,local_state)
         do im=1,nmat
          ibase=idenbase+(im-1)*num_state_material
          local_ibase=(im-1)*num_state_material
          scalc(ibase+1)=local_state(local_ibase+1) ! density
          scalc(ibase+2)=local_state(local_ibase+2) ! temperature
          ! species
          do n=1,num_species_var
           scalc(ibase+num_state_base+n)= &
            local_state(local_ibase+num_state_base+n)
          enddo
         enddo ! im=1..nmat
         call ZEYU_droplet_impact_PRES(xpos,time,distbatch,p_hyd)
         scalc(ipresbase+impres)=p_hyd

        else if (probtype.eq.533) then

         call rigid_FSI_LS(xpos,time,distbatch)
         call rigid_FSI_STATE(xpos,time,distbatch,local_state)
         do im=1,nmat
          ibase=idenbase+(im-1)*num_state_material
          local_ibase=(im-1)*num_state_material
          scalc(ibase+1)=local_state(local_ibase+1) ! density
          scalc(ibase+2)=local_state(local_ibase+2) ! temperature
           ! species
          do n=1,num_species_var
           scalc(ibase+num_state_base+n)= &
            local_state(local_ibase+num_state_base+n)
          enddo
         enddo ! im=1..nmat
         call rigid_FSI_PRES(xpos,time,distbatch,p_hyd)
         scalc(ipresbase+impres)=p_hyd

        else if (probtype.eq.534) then

         call sinking_FSI_LS(xpos,time,distbatch)
         call sinking_FSI_STATE(xpos,time,distbatch,local_state)
         do im=1,nmat
          ibase=idenbase+(im-1)*num_state_material
          local_ibase=(im-1)*num_state_material
          scalc(ibase+1)=local_state(local_ibase+1) ! density
          scalc(ibase+2)=local_state(local_ibase+2) ! temperature
           ! species
          do n=1,num_species_var
           scalc(ibase+num_state_base+n)= &
            local_state(local_ibase+num_state_base+n)
          enddo
         enddo ! im=1..nmat
         call sinking_FSI_PRES(xpos,time,distbatch,p_hyd)
         scalc(ipresbase+impres)=p_hyd

        else if (probtype.eq.311) then ! user defined

         call USERDEF_LS(xpos,time,distbatch)
         call USERDEF_STATE(xpos,time,distbatch,local_state)
         do im=1,nmat
          ibase=idenbase+(im-1)*num_state_material
          local_ibase=(im-1)*num_state_material
          scalc(ibase+1)=local_state(local_ibase+1) ! density
          scalc(ibase+2)=local_state(local_ibase+2) ! temperature
           ! species
          do n=1,num_species_var
           scalc(ibase+num_state_base+n)= &
            local_state(local_ibase+num_state_base+n)
          enddo
         enddo ! im=1..nmat
         call USERDEF_PRES(xpos,time,distbatch,p_hyd)
         scalc(ipresbase+impres)=p_hyd

        else if (probtype.eq.222) then ! cone user defined in INITDATA

         call CONE3D_LS(xpos,time,distbatch)
         call CONE3D_STATE(xpos,time,distbatch,local_state)
         do im=1,nmat
          ibase=idenbase+(im-1)*num_state_material
          local_ibase=(im-1)*num_state_material
          scalc(ibase+1)=local_state(local_ibase+1) ! density
          scalc(ibase+2)=local_state(local_ibase+2) ! temperature
          ! species
          do n=1,num_species_var
           scalc(ibase+num_state_base+n)= &
            local_state(local_ibase+num_state_base+n)
          enddo
         enddo ! im=1..nmat
         call CONE3D_PRES(xpos,time,distbatch,p_hyd)
         scalc(ipresbase+impres)=p_hyd

        else if (probtype.eq.915) then ! wavy channel

         call WAVY_INIT_LS(xpos,time,distbatch)
         call WAVY_INIT_STATE(xpos,time,distbatch,local_state)
         do im=1,nmat
          ibase=idenbase+(im-1)*num_state_material
          local_ibase=(im-1)*num_state_material
          scalc(ibase+1)=local_state(local_ibase+1) ! density
          scalc(ibase+2)=local_state(local_ibase+2) ! temperature
          ! species
          do n=1,num_species_var
           scalc(ibase+num_state_base+n)= &
            local_state(local_ibase+num_state_base+n)
          enddo
         enddo ! im=1..nmat
         call WAVY_INIT_PRES(xpos,time,distbatch,p_hyd)
         scalc(ipresbase+impres)=p_hyd

        else

         do im=1,nmat

          ibase=idenbase+(im-1)*num_state_material

          scalc(ibase+1)=fort_denconst(im)  ! den
          scalc(ibase+2)=fort_initial_temperature(im)  ! temperature
     
          do n=1,num_species_var
           scalc(ibase+num_state_base+n)= &
            fort_speciesconst((n-1)*nmat+im)
          enddo

          if (probtype.eq.82) then ! annulus
           ! fort_tempconst(1) is the inner wall temperature
           ! twall is the outer wall temperature
           ! see: subroutine thermal_offset
           scalc(ibase+2)=fort_initial_temperature(1)
          endif

           ! in: INITDATA
          if (probtype.eq.26) then ! swirl

           if (axis_dir.eq.10) then ! BCG test
            scalc(ibase+2)=fort_initial_temperature(1)
           else if (axis_dir.eq.11) then ! BCG periodic test
            scalc(ibase+2)=fort_initial_temperature(1)
           else if ((axis_dir.ge.0).and.(axis_dir.le.5)) then
            doubly_flag=1
            if (SDIM.eq.2) then
             if ((axis_dir.eq.0).or.(axis_dir.eq.1)) then
              rr=y
             else if ((axis_dir.eq.2).or.(axis_dir.eq.3)) then
              rr=sqrt((x-xblob)**2+(y-yblob)**2)-radblob
              doubly_flag=0
             else
              print *,"axis_dir invalid"
              stop
             endif
            else if (SDIM.eq.3) then
             if ((axis_dir.ge.0).and.(axis_dir.le.3)) then
              if (adv_dir.eq.3) then
               rr=y
              else if (adv_dir.eq.2) then
               rr=z
              else if (adv_dir.eq.1) then
               rr=z
              else
               print *,"adv_dir invalid probtype==26 (11)"
               stop
              endif
             else if ((axis_dir.eq.4).or.(axis_dir.eq.5)) then
              rr=sqrt((x-xblob)**2+(y-yblob)**2+(z-zblob)**2)-radblob
              doubly_flag=0
             else
              print *,"axis_dir invalid"
              stop
             endif
            else
             print *,"dimension bust"
             stop
            endif
            if (doubly_flag.eq.1) then
             if (rr.le.half) then
              jumpval=tanh( (rr-one/four)*30.0 )
             else
              jumpval=tanh( (three/four-rr)*30.0 )
             endif
            else if (doubly_flag.eq.0) then
             jumpval=tanh(30.0*rr)
            else
             print *,"doubly_flag invalid"
             stop
            endif

            jumpval=(jumpval+one)/two
            scalc(ibase+2)=jumpval*fort_initial_temperature(1)+ &
             (one-jumpval)*fort_initial_temperature(2)
  
           else
            print *,"axis_dir invalid"
            stop
           endif

          endif ! probtype==26

            ! 2B from Wardlaws list
          if ((probtype.eq.36).and.(axis_dir.eq.2).and. &
              (SDIM.eq.2)) then
           if (im.eq.1) then
            call tait_hydrostatic_pressure_density(xpos, &
             rhohydro,preshydro,from_boundary_hydrostatic)
            scalc(ibase+1)=rhohydro
           else if (im.eq.2) then
            e_jwl=4.2814D+10
            den_jwl=1.63D0
            call init_massfrac_parm(den_jwl,massfrac_parm,im)
            call TEMPERATURE_material(den_jwl,massfrac_parm, &
             temp_jwl,e_jwl, &
             fort_material_type(im),im)
            scalc(ibase+1)=den_jwl
            scalc(ibase+2)=temp_jwl
           endif
          endif  ! probtype=36
           ! initial temperature for boiling cavity problem
          if (probtype.eq.710) then
           ! water phase
           if (im.eq.1) then
             ! bcflag=0 (calling from FORT_INITDATA)
            call outside_temperature(time,x,y,z,water_temp,im,0)
            scalc(ibase+2)=water_temp  
           endif ! im=1
          endif

           ! initial temperature for melting ice block on a substrate.
          if (probtype.eq.59) then

           if (nmat.lt.4) then
            print *,"nmat too small for melting ice on substrate"
            stop
           endif
           ! substrate (initial temperature)
           if (im.eq.4) then
            ! bcflag=0 (calling from FORT_INITDATA)
            call outside_temperature(time,x,y,z,water_temp,im,0)
            scalc(ibase+2)=water_temp
           endif

          endif ! probtype.eq.59

           ! Benard instability problem initdata
           ! density above is a filler; density will be
           ! replaced by rho(T,z) after "nonlinear_advection"
           ! (correct_density)
          if (probtype.eq.603) then
           if (z.gt.yblob) then
            water_temp=fort_initial_temperature(1) 
           else if (z.gt.zero) then 
            temp_slope=-radblob2/yblob
            if (SDIM.eq.2) then
             eps_benard=radblob*cos(two*Pi*x/xblob)*four*y*(yblob-y)/(yblob**2) 
            else if (SDIM.eq.3) then
             eps_benard=cos(two*Pi*(x-problox)/xblob)* &
                cos(two*Pi*(y-probloy)/xblob)* &
                radblob*four*z*(yblob-z)/(yblob**2)
            else
             print *,"dimension bust"
             stop
            endif

            water_temp=radblob2+fort_initial_temperature(1)+ &
              temp_slope*(z+eps_benard)
           else
            water_temp=radblob2+fort_initial_temperature(1)
           endif
           scalc(ibase+2)=water_temp  ! temperature
          endif  ! probtype=603

          if ((probtype.eq.1).and. &
              ((axis_dir.eq.150).or. &
               (axis_dir.eq.151))) then
    
           if (im.eq.2) then ! air
            call shockdrop_pressure(x,y,z,p_jwl, &
             xblob,yblob,zblob,radblob,zblob2,axis_dir)
            call shockdrop_gas_density(x,y,z,den_jwl, &
             xblob,yblob,zblob,radblob,zblob2,axis_dir)
            call shockdrop_velocity(x,y,z,vel, &
             xblob,yblob,zblob,radblob,zblob2,axis_dir)
            u_jwl=vel(SDIM)
            test_gamma=one+R_AIR_PARMS/CV_AIR_PARMS
            if (abs(test_gamma-shockdrop_gamma).gt.1.0E-8) then
             print *,"shockdrop_gamma inconsistent with mattype=5 parms"
             print *,"test_gamma=",test_gamma
             print *,"shockdrop_gamma=",shockdrop_gamma
             stop
            endif 
            call general_hydrostatic_pressure(test_pres)
            if (abs(test_pres-shockdrop_P)/test_pres.gt.1.0E-8) then
             print *,"shockdrop_P inconsistent w/ general_hydrostatic_pressure"
             stop
            endif
            if (fort_material_type(2).ne.5) then
             print *,"only material_type=5 supported for gas for this problem"
             stop
            endif
            e_jwl=p_jwl/((shockdrop_gamma-one)*den_jwl)
            call init_massfrac_parm(den_jwl,massfrac_parm,im)
            call TEMPERATURE_material(den_jwl,massfrac_parm, &
             temp_jwl,e_jwl, &
             fort_material_type(im),im)
            scalc(ibase+1)=den_jwl
            scalc(ibase+2)=temp_jwl
           else if (im.eq.1) then ! water
            ! do nothing (use fort_denconst and fort_initial_temperature)
           else
            print *,"im invalid83"
            stop
           endif

          endif  ! shockdrop

           ! shock tube problems
           ! do not use material_type=5 (EOS_air),
           ! use material_type=18 instead.
           ! (results should be similar though)
          if ((probtype.eq.92).or.(probtype.eq.93)) then
           gamma_jwl=1.4

           if (axis_dir.eq.0) then  ! Sod shock tube
            den_jwl_left=one
            den_jwl_right=0.125
            p_jwl_left=one
            p_jwl_right=0.1
            u_jwl_left=zero
            u_jwl_right=zero
            xshock=half
           else if (axis_dir.eq.1) then ! strong shock tube
            den_jwl_left=one
            den_jwl_right=0.125
            p_jwl_left=1.0D+10
            p_jwl_right=0.1
            u_jwl_left=zero
            u_jwl_right=zero
            xshock=half
           else if (axis_dir.eq.2) then ! shock turbulence interaction
            den_jwl_left=3.857148
            den_jwl_right=one+0.2d0*sin(five*x-five)
            p_jwl_left=10.333333
            p_jwl_right=one
            u_jwl_left=2.629369
            u_jwl_right=zero
            xshock=one
           else if (axis_dir.eq.3) then ! mach>4
            den_jwl_left=10.0
            den_jwl_right=1.0
            p_jwl_left=10.0*(1.4-1.0)
            p_jwl_right=(1.4-1.0)
            u_jwl_left=5.0
            u_jwl_right=zero
            xshock=one
            ! Kadioglu, Sussman, Osher, Wright, Kang (smooth test problem)
           else if (axis_dir.eq.4) then 
            u_jwl_left=zero
            u_jwl_right=zero
            if (adv_dir.eq.1) then
             rr=x
            else if (adv_dir.eq.2) then
             rr=y
            else if ((adv_dir.eq.3).and.(SDIM.eq.3)) then
             rr=z
            else
             print *,"adv_dir invalid probtype==92,93 (12)"
             stop
            endif
            p_jwl_left=(1.0D+6)+60.0*cos(two*Pi*rr)+100.0*sin(four*Pi*rr)
            p_jwl_right=p_jwl_left
            den_jwl_left=fort_denconst(2)*((p_jwl/1.0D+6)**(one/gamma_jwl))
            den_jwl_right=den_jwl_left
            xshock=one
           else 
            print *,"axis_dir invalid probtype=92 or 93"
            stop
           endif
           if ((axis_dir.eq.0).or. &
               (axis_dir.eq.1).or. &
               (axis_dir.eq.2).or. &
               (axis_dir.eq.3)) then
            e_jwl_left=p_jwl_left/((gamma_jwl-one)*den_jwl_left)
            e_jwl_right=p_jwl_right/((gamma_jwl-one)*den_jwl_right)
            call init_massfrac_parm(den_jwl_left,massfrac_parm,im)
            call TEMPERATURE_material(den_jwl_left,massfrac_parm, &
             temp_jwl_left,e_jwl_left, &
             fort_material_type(im),im)
            call init_massfrac_parm(den_jwl_right,massfrac_parm,im)
            call TEMPERATURE_material(den_jwl_right,massfrac_parm, &
             temp_jwl_right, &
             e_jwl_right,fort_material_type(im),im)
           else if (axis_dir.eq.4) then
            temp_jwl_left=fort_initial_temperature(1)
            temp_jwl_right=temp_jwl_left
           else
            print *,"axis_dir invalid"
            stop
           endif
           if (probtype.eq.92) then
            if (x.le.xshock) then
             den_jwl=den_jwl_left 
             temp_jwl=temp_jwl_left 
            else if (x.gt.xshock) then
             den_jwl=den_jwl_right
             temp_jwl=temp_jwl_right
            else
             print *,"x invalid"
             stop
            endif
           else if (probtype.eq.93) then
            if (xblob.lt.xshock) then
             if (im.eq.1) then
              den_jwl=den_jwl_left
              temp_jwl=temp_jwl_left 
             else if (im.eq.2) then
              if (x.le.xshock) then
               den_jwl=den_jwl_left
               temp_jwl=temp_jwl_left 
              else if (x.gt.xshock) then
               den_jwl=den_jwl_right
               temp_jwl=temp_jwl_right
              else
               print *,"x invalid"
               stop
              endif
             else
              print *,"im invalid84"
              stop
             endif
            else if (xblob.gt.xshock) then
             if (im.eq.1) then
              if (x.le.xshock) then
               den_jwl=den_jwl_left
               temp_jwl=temp_jwl_left 
              else if (x.gt.xshock) then
               den_jwl=den_jwl_right
               temp_jwl=temp_jwl_right
              else
               print *,"x invalid"
               stop
              endif
             else if (im.eq.2) then
              den_jwl=den_jwl_right
              temp_jwl=temp_jwl_right
             else
              print *,"im invalid85"
              stop
             endif
            else if (xblob.eq.xshock) then 
             if (im.eq.1) then
              den_jwl=den_jwl_left
             else if (im.eq.2) then
              den_jwl=den_jwl_right
             else
              print *,"im invalid86"
              stop
             endif
             if (x.le.xshock) then
              temp_jwl=temp_jwl_left 
             else if (x.gt.xshock) then
              temp_jwl=temp_jwl_right
             else
              print *,"x invalid"
              stop
             endif
            else
             print *,"xblob or xshock invalid"
             stop
            endif
           else 
            print *,"probtype invalid"
            stop
           endif

           scalc(ibase+1)=den_jwl
           scalc(ibase+2)=temp_jwl

          endif ! probtype=92 or 93 (shock tube test problems)

           ! in: FORT_INITDATA
           ! material=1 is TAIT EOS
          if (fort_material_type(1).eq.13) then
           if (im.eq.1) then

            call tait_hydrostatic_pressure_density(xpos, &
             rhohydro,preshydro,from_boundary_hydrostatic)
            scalc(ibase+1)=rhohydro

           endif  ! im=1
          endif ! material_type(1)=13

           ! 2E from Wardlaw's list (bubble jetting) 
           ! in: initdata
          if ((probtype.eq.42).and.(axis_dir.eq.1)) then
           if (im.eq.1) then

            call tait_hydrostatic_pressure_density(xpos,rhohydro,preshydro, &
                    from_boundary_hydrostatic)
            scalc(ibase+1)=rhohydro
   
           else if (im.eq.2) then
            e_jwl=4.2945D+10
            den_jwl=1.63D0
            call init_massfrac_parm(den_jwl,massfrac_parm,im)
            call TEMPERATURE_material(den_jwl,massfrac_parm, &
             temp_jwl,e_jwl, &
             fort_material_type(im),im)

            scalc(ibase+1)=den_jwl     ! density
            scalc(ibase+2)=temp_jwl
           endif
          endif  ! probtype=42 axis_dir=1 (bubble jetting)

          ! Marangoni (heat pipe) test problem
          ! flag=0 
          if ((probtype.eq.36).and.(axis_dir.eq.10)) then
           call position_Temp(0,radblob,radblob2,x,y,z,temp_jwl)
           scalc(ibase+2)=temp_jwl
          endif

           ! in: initdata
          if (probtype.eq.46) then ! cavitation

           if ((axis_dir.ge.0).and.(axis_dir.lt.10)) then
            if (im.eq.1) then ! water

             call tait_hydrostatic_pressure_density(xpos,rhohydro,preshydro, &
                     from_boundary_hydrostatic)
             scalc(ibase+1)=rhohydro

            else if (im.eq.2) then ! jwl
             e_jwl=4.2945D+10
             den_jwl=1.63D0
             call init_massfrac_parm(den_jwl,massfrac_parm,im)
             call TEMPERATURE_material(den_jwl,massfrac_parm, &
              temp_jwl,e_jwl, &
              fort_material_type(im),im)

             scalc(ibase+1)=den_jwl     ! density
             scalc(ibase+2)=temp_jwl
            else if (im.eq.3) then  ! air
             call general_hydrostatic_pressure(p_hyd)
             den_jwl=fort_denconst(im)
             temp_jwl=fort_initial_temperature(im)
             call init_massfrac_parm(den_jwl,massfrac_parm,im)
             call INTERNAL_material(den_jwl,massfrac_parm, &
              temp_jwl,e_jwl, &
              fort_material_type(im),im)
             call EOS_material(den_jwl,massfrac_parm, &
              e_jwl,p_jwl, &
              fort_material_type(im),im)
             temp_jwl=temp_jwl*p_hyd/p_jwl
        
             scalc(ibase+1)=den_jwl
             scalc(ibase+2)=temp_jwl

            endif
           else if (axis_dir.eq.10) then
            if (im.eq.1) then ! water
             call tait_hydrostatic_pressure_density(xpos,rhohydro,preshydro, &
                     from_boundary_hydrostatic)
             scalc(ibase+1)=rhohydro
            endif
           else if (axis_dir.eq.20) then
            !do nothing (CODY ESTEBE created test problem,fort_denconst(im) ok)
           else
            print *,"axis_dir invalid"
            stop
           endif
          endif  ! probtype=46 (cavitation)


           ! (initdata) shock injection with nozzle and pressure BC
          if ((probtype.eq.53).and.(axis_dir.eq.2)) then

           denroom=fort_denconst(im)
           temproom=fort_initial_temperature(im)  ! room temp

           if (im.eq.1) then  ! liquid
            scalc(ibase+1)=denroom
           else if (im.eq.2) then  ! gas
            scalc(ibase+1)=denroom
            imattype=fort_material_type(im)

            if (imattype.eq.0) then
             ! do nothing
            else if (imattype.gt.0) then

             call init_massfrac_parm(denroom,massfrac_parm,im)
             call INTERNAL_material(denroom,massfrac_parm, &
              temproom,e_room, &
              imattype,im)
             call EOS_material(denroom,massfrac_parm, &
               e_room,p_room,imattype,im)
             call general_hydrostatic_pressure(p_hyd)
             temproom=temproom*p_hyd/p_room
             e_room=e_room*p_hyd/p_room
             scalc(ibase+2)=temproom  ! temperature
            else 
             print *,"imattype invalid fort_initdata"
             stop
            endif

           endif

           ! shock injection JICF with compressible gas.
          else if ((probtype.eq.53).and.(fort_material_type(2).gt.0)) then

           call general_hydrostatic_pressure(p_hyd)
           scalc(ipresbase+impres)=p_hyd

          else if ((probtype.eq.530).and. &
                   (axis_dir.eq.1).and. &
                   (fort_material_type(2).gt.0).and. &
                   (SDIM.eq.3)) then
           call general_hydrostatic_pressure(p_hyd)
           scalc(ipresbase+impres)=p_hyd
          endif

          ! circular freezing disk
          ! or spherical boiling
          if ((probtype.eq.801).and.(axis_dir.eq.3)) then 
   
           im_source=1
           im_dest=2
           ireverse=0
           call get_iten(im_source,im_dest,iten,nmat)
           L_ice_melt=abs(latent_heat(iten+ireverse*nten))
           TSAT=saturation_temp(iten+ireverse*nten)
           T_EXTREME=fort_initial_temperature(im_source)
           cp_melt=get_user_stiffCP(im_source) ! J/Kelvin
           k_melt=get_user_heatviscconst(im_source) ! W/(m Kelvin)
  
           if (SDIM.eq.2) then
            rstefan=sqrt((x-xblob)**2+(y-yblob)**2)
           else
            rstefan=sqrt((x-xblob)**2+(y-yblob)**2+(z-zblob)**2)
           endif
           if (rstefan.le.radblob) then
            T_FIELD=TSAT
           else
            den_ratio=max(fort_denconst(im_dest),fort_denconst(im_source))/ &
                      min(fort_denconst(im_dest),fort_denconst(im_source))

            if (den_ratio.lt.10.0d0) then 
             call liquid_temperature( &
              fort_beta(iten+ireverse*nten), & ! lmSt
              T_EXTREME, &
              L_ice_melt, &
              cp_melt, &
              fort_stefan_number(iten+ireverse*nten), &
              rstefan, &
              fort_time_radblob(iten+ireverse*nten), &
              k_melt, &
              T_FIELD)
            else if (den_ratio.ge.10.0) then
             call superheat_temperature( &
              fort_alpha(iten+ireverse*nten), &
              fort_beta(iten+ireverse*nten), &
              den_ratio, &
              T_EXTREME, &
              fort_jacob_number(iten+ireverse*nten), &
              TSAT, &
              rstefan, &
              fort_time_radblob(iten+ireverse*nten), &
              T_FIELD)
            else
             print *,"for_expansion_factor invalid"
             stop
            endif
           endif
           scalc(ibase+2)=T_FIELD

          endif ! (probtype.eq.801).and.(axis_dir.eq.3)

          if (probtype.eq.802) then ! dissolution
           scalc(ibase+2)=two   ! T (concentration)
           call vapordist(xsten,nhalf,dx,bfact,posdiss)
           if (posdiss.le.zero) then
            concentration=two
           else if (posdiss.ge.xhidiss-two*dx(SDIM)) then
            concentration=one
           else
            ispace=NINT(posdiss/dx(SDIM)-half)
            if (ispace.eq.0) then
             concen1=two
             concen2=soln(ispace+1)+one
            else if (ispace.ge.ndiss-2) then
             concen1=soln(ispace)+one
             concen2=one
            else
             concen1=soln(ispace)+one
             concen2=soln(ispace+1)+one
            endif
            theta=(posdiss-ispace*dx(SDIM))/dx(SDIM)
            concentration=(one-theta)*concen1+theta*concen2
           endif
           scalc(ibase+2)=concentration   ! T (concentration)
          endif ! 802 (dissolution)

           ! in: subroutine FORT_INITDATA
           ! hydrates
          if (probtype.eq.199) then
           if (nmat.ne.3) then
            print *,"3 materials for hydrate reactor"
            stop
           endif
           if (num_species_var.ne.1) then
            print *,"num_species_var should be 1"
            stop
           endif
           if (im.eq.1) then
            call INIT_STATE_WATER(x,y,z,time,vel,temp,dens,ccnt) 
           else if (im.eq.2) then
            call INIT_STATE_GAS(x,y,z,time,vel,temp,dens,ccnt) 
           else if (im.eq.3) then
            call INIT_STATE_HYDRATE(x,y,z,time,vel,temp,dens,ccnt) 
           else
            print *,"im invalid87"
            stop
           endif

            ! density comes from the inputs file.
           scalc(ibase+2)=temp
           scalc(ibase+3)=ccnt

           ! in: subroutine FORT_INITDATA
          else if (probtype.eq.220) then
           ! do nothing, density and tempearture are set from the input file
           ! in the beginning of the loop on im. NO INIT_STATE_*** is called

           ! in: subroutine FORT_INITDATA
          else if ((probtype.eq.299).or. &
                   (probtype.eq.301)) then !melting (initial temperature field)

           temp=fort_initial_temperature(im)
           scalc(ibase+2)=temp

          endif  

         enddo  ! im=1..nmat

        endif ! if (probtype.eq.user_def_probtype) then ... else ... endif

        call materialdist_batch(xsten,nhalf,dx,bfact,distbatch,nmat)
        do im=1,nmat
         if (is_rigid(nmat,im).eq.1) then
          if ((FSI_flag(im).eq.2).or. & ! prescribed solid (CAD)
              (FSI_flag(im).eq.4)) then ! CTML FSI
           distbatch(im)=LS(D_DECL(ic,jc,kc),im)
          else if (FSI_flag(im).eq.1) then ! prescribed solid (EUL)
           ! do nothing
          else
           print *,"FSI_flag(im) invalid"
           stop
          endif
         else if (is_rigid(nmat,im).eq.0) then
          ! do nothing
         else
          print *,"is_rigid(nmat,im) invalid"
          stop
         endif
        enddo ! im=1..nmat

         ! in: FORT_INITDATA
        call stackvolume_batch(xsten,nhalf,dx,bfact,fluiddata,nmat, &
         0,max_levelstack,materialdist_batch)
        call extract_vof_cen_batch(fluiddata,vofdark,voflight, &
         cendark,cenlight,nmat)

         ! Rayleigh-Taylor, checkerboard test
        if (probtype.eq.602) then
         if ((xblob.ge.1.0D+5).and.(radblob.le.0.001*dx(1))) then
          if (nmat.ne.2) then
           print *,"nmat invalid"
           stop
          endif
          dir=2
          im=1
          cendark(im,dir)=0.25*dx(2)
          im=2
          cendark(im,dir)=-0.25*dx(2)
          dir=1
          im=1
          cendark(im,dir)=0.1*dx(1)
          im=2
          cendark(im,dir)=-0.1*dx(2)
         endif
        endif ! Rayleigh-Taylor checkerboard test

        debug_vfrac_sum=zero

        do imls=1,nmat
         LSc(imls)=distbatch(imls)
        enddo

        do im=1,nmat

         vofcomp_raw=imofbase+(im-1)*ngeom_raw+1

         scalc(vofcomp_raw)=vofdark(im)
          ! centroid relative to centroid of cell; not cell center.
         do dir=1,SDIM
          scalc(vofcomp_raw+dir)=cendark(im,dir)
         enddo

         if (is_rigid(nmat,im).eq.0) then
          debug_vfrac_sum=debug_vfrac_sum+vofdark(im)
         else if (is_rigid(nmat,im).eq.1) then
          if ((FSI_flag(im).eq.2).or. & ! prescribed solid (CAD)
              (FSI_flag(im).eq.4)) then ! CTML FSI (EUL)
           scalc(vofcomp_raw)=scal(D_DECL(ic,jc,kc),vofcomp_raw)
           do dir=1,SDIM 
            scalc(vofcomp_raw+dir)=scal(D_DECL(ic,jc,kc),vofcomp_raw+dir)
           enddo
          else if (FSI_flag(im).eq.1) then ! prescribed solid (EUL)
           ! do nothing
          else
           print *,"FSI_flag invalid"
           stop
          endif
         else
          print *,"is_rigid(nmat,im) invalid"
          stop
         endif

        enddo  ! im=1..nmat
        
        if (debug_vfrac_sum.le.half) then
         print *,"WARNING in 'process_initdata'"
         print *,"debug_vfrac_sum= ",debug_vfrac_sum
         print *,"ic,jc,kc,x,y,z ",ic,jc,kc,x,y,z
         print *,"time=",time
         do im=1,nmat
          print *,"im,vofdark ",im,vofdark(im)
          print *,"im,distbatch ",im,distbatch(im)
         enddo
         call materialdistsolid(x,y,z,distsolid,time,im_solid_initdata)
         if ((FSI_flag(im_solid_initdata).eq.2).or. & ! prescribed solid (CAD)
             (FSI_flag(im_solid_initdata).eq.4)) then ! CTML FSI
          distsolid=LS(D_DECL(ic,jc,kc),im_solid_initdata)
         endif
         print *,"result of materialdistsolid: distsolid=",distsolid

         print *,"adjusting the volume fraction of the 1st material"
         im=1
         if (is_rigid(nmat,im).ne.0) then
          print *,"is_rigid(nmat,im).ne.0"
          stop
         endif
         vofdark(im)=vofdark(im)+one-debug_vfrac_sum
         vofcomp_raw=imofbase+(im-1)*ngeom_raw+1
         scalc(vofcomp_raw)=vofdark(im)
        endif

        do i1=-1,1
        do j1=-1,1
        do k1=k1lo,k1hi

         do isten=-nhalf2,nhalf2
          dir=1
          xsten2(isten,dir)=xsten(isten+2*i1,dir)
          dir=2
          xsten2(isten,dir)=xsten(isten+2*j1,dir)
          if (SDIM.eq.3) then
           dir=SDIM
           xsten2(isten,dir)=xsten(isten+2*k1,dir)
          endif
         enddo ! isten
         call materialdist_batch(xsten2,nhalf2,dx,bfact,distbatch,nmat)
         do im=1,nmat
          if (is_rigid(nmat,im).eq.1) then
           if ((FSI_flag(im).eq.2).or. & ! prescribed solid CAD
               (FSI_flag(im).eq.4)) then ! CTML FSI
            distbatch(im)=LS(D_DECL(ic+i1,jc+j1,kc+k1),im)
           else if (FSI_flag(im).eq.1) then ! prescribed solid EUL
            ! do nothing
           else
            print *,"FSI_Flag(im) invalid"
            stop
           endif
          else if (is_rigid(nmat,im).eq.0) then
           ! do nothing
          else
           print *,"is_rigid invalid"
           stop
          endif 
          LS_stencil(D_DECL(i1,j1,k1),im)=distbatch(im)
         enddo

        enddo
        enddo
        enddo ! i1,j1,k1 = -1..1

        stencil_valid=1
 
        do im=1,nmat
         vofcomp_recon=(im-1)*ngeom_recon+1
         vofcomp_raw=imofbase+(im-1)*ngeom_raw+1
         mofdata(vofcomp_recon)=scalc(vofcomp_raw)
         mofdata(vofcomp_recon+SDIM+1)=zero ! order
         mofdata(vofcomp_recon+2*SDIM+2)=zero ! intercept
         do dir=1,SDIM
          mofdata(vofcomp_recon+dir)=scalc(vofcomp_raw+dir) ! centroid
          mofdata(vofcomp_recon+SDIM+dir+1)=zero ! slope
         enddo
        enddo  ! im=1..nmat

        ! sum F_fluid=1  sum F_solid <= 1
        call make_vfrac_sum_ok_base(tessellate,mofdata,nmat,SDIM,201)
        do im=1,nmat
         vofcomp_recon=(im-1)*ngeom_recon+1
         voflist(im)=mofdata(vofcomp_recon)
        enddo

        call calc_error_indicator( &
         stencil_valid, &
         level,max_level, &
         xsten,nhalf,dx,bfact, &
         voflist, &
         LS_stencil, &
         nmat,nten, &
         latent_heat, &
         radius_cutoff, &
         err,time)

        scalc(nc)=err

        if (volcell.le.zero) then
         print *,"volcell invalid in INITDATA: ",volcell
         stop
        endif 

        vfracsum_test=zero
        do im=1,nmat
         vofcomp_raw=imofbase+(im-1)*ngeom_raw+1
         if (is_rigid(nmat,im).eq.0) then
          vfracsum_test=vfracsum_test+scalc(vofcomp_raw)
         else if (is_rigid(nmat,im).eq.1) then
          ! do nothing
         else
          print *,"is_rigid(nmat,im) invalid"
          stop
         endif
        enddo !im=1..nmat

        if ((vfracsum_test.le.half).or.(vfracsum_test.gt.1.5)) then
         print *,"FAILED: vfracsum_test= ",vfracsum_test
         do im=1,nmat
          vofcomp_raw=imofbase+(im-1)*ngeom_raw+1
          print *,"im,vfrac ",im,scalc(vofcomp_raw)
          print *,"im,LS ",im,LSc(im)
         enddo
         print *,"level,max_level ",level,max_level
         print *,"x,y,z= ",x,y,z
         print *,"dx,dy,dz= ",dx(1),dx(2),dx(SDIM)
         print *,"ic,jc,kc= ",ic,jc,kc
         print *,"radblob,radblob2,radblob3,radblob4 ", &
           radblob,radblob2,radblob3,radblob4
         print *,"xblob,yblob,zblob ",xblob,yblob,zblob
         print *,"probtype ",probtype
         stop
        endif

        do imls=1,nmat 
         call find_cut_geom_slope_CLSVOF( &
          LS_stencil, &
          lsnormal, &
          lsnormal_valid, &
          ls_intercept, &
          bfact,dx,xsten,nhalf, &
          imls, &
          dxmaxLS, &
          nmat,SDIM)

         if (lsnormal_valid(imls).eq.1) then
          do dir=1,SDIM
           LSc(nmat+SDIM*(imls-1)+dir)=lsnormal(imls,dir)
          enddo
         else if (lsnormal_valid(imls).eq.0) then
          ! do nothing
         else
          print *,"lsnormal_valid invalid"
          stop
         endif
        enddo !imls=1..nmat 

        do im=1,nmat
         vofcomp_raw=imofbase+(im-1)*ngeom_raw+1
         scalc(vofcomp_raw)=voflist(im)
        enddo ! im=1..nmat

        do n=1,nc
         scal(D_DECL(ic,jc,kc),n)=scalc(n)
        enddo
        do imls=1,nmat*(1+SDIM)
         LS(D_DECL(ic,jc,kc),imls)=LSc(imls)
        enddo

       enddo
       enddo
       enddo ! ic,jc,kc

       if (DO_SANITY_CHECK.eq.1) then
        call init_sanity(fablo(1),fabhi(1))
        allocate(comparestate(fablo(1)-1:fabhi(1)+1,5))
        jc=1
        kc=0
        do ic=fablo(1),fabhi(1)
         comparestate(ic,2)=scal(D_DECL(ic,jc,kc),idenbase+1)
         comparestate(ic,3)=scal(D_DECL(ic,jc,kc),idenbase+2)
        enddo
        call compare_sanity(comparestate,2,2,1)
        deallocate(comparestate)
       endif

       return
       end subroutine FORT_INITDATA

       subroutine FORT_ADDNOISE( &
        dir, &
        angular_velocity, &
        perturbation_mode, &
        perturbation_eps_temp, &
        perturbation_eps_vel, &
        nstate, &
        nmat, &
        xlo,dx,  &
        Snew,DIMS(Snew), &
        LSnew,DIMS(LSnew), &
        MAC,DIMS(MAC), &
        tilelo,tilehi, &
        fablo,fabhi, &
        bfact, &
        level, &
        finest_level)
       use probf90_module
       use global_utility_module

       IMPLICIT NONE

      INTEGER_T dir
      REAL_T angular_velocity
      INTEGER_T perturbation_mode
      REAL_T perturbation_eps_temp
      REAL_T perturbation_eps_vel
      INTEGER_T nstate
      INTEGER_T nmat
      INTEGER_T level
      INTEGER_T finest_level
      REAL_T xlo(SDIM),dx(SDIM)
      INTEGER_T DIMDEC(Snew)
      INTEGER_T DIMDEC(LSnew)
      INTEGER_T DIMDEC(MAC)
      INTEGER_T tilelo(SDIM),tilehi(SDIM)
      INTEGER_T fablo(SDIM),fabhi(SDIM)
      INTEGER_T growlo(3),growhi(3)
      INTEGER_T bfact
      REAL_T Snew(DIMV(Snew),nstate)
      REAL_T LSnew(DIMV(LSnew),nmat)
      REAL_T MAC(DIMV(MAC),num_materials_vel)
      REAL_T xsten(-3:3,SDIM)
      INTEGER_T nhalf
      INTEGER_T i,j,k,ii,jj,kk,dir2,im,velcomp,tcomp
      REAL_T problo_arr(SDIM)
      REAL_T probhi_arr(SDIM)
      REAL_T sinprod

      nhalf=3

      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif
      if (num_state_base.ne.2) then
       print *,"num_state_base invalid"
       stop
      endif
      if (nmat.ne.num_materials) then
       print *,"nmat invalid"
       stop
      endif
      if (nstate.ne.num_materials_vel*(SDIM+1)+ &
          nmat*(num_state_material+ngeom_raw)+1) then
       print *,"nstate invalid"
       stop
      endif
      if ((level.lt.0).or.(level.gt.finest_level)) then
       print *,"level invalid add noise"
       stop
      endif

      problo_arr(1)=problox
      problo_arr(2)=probloy
      probhi_arr(1)=probhix
      probhi_arr(2)=probhiy
      if (SDIM.eq.3) then
       problo_arr(SDIM)=probloz
       probhi_arr(SDIM)=probhiz
      endif

      ii=0
      jj=0
      kk=0
      if (dir.eq.0) then
       ii=1
      else if (dir.eq.1) then
       jj=1
      else if ((dir.eq.2).and.(SDIM.eq.3)) then
       kk=1
      else
       print *,"dir invalid in addnoise "
       stop
      endif

      call checkbound(fablo,fabhi,DIMS(Snew),1,-1,7)
      call checkbound(fablo,fabhi,DIMS(LSnew),1,-1,7)
      call checkbound(fablo,fabhi,DIMS(MAC),0,dir,7)

      if (perturbation_mode.le.0) then
       print *,"perturbation_mode invalid"
       stop
      endif 
      if (perturbation_mode.gt.1024) then
       print *,"perturbation_mode too large"
       stop
      endif 
      if (perturbation_eps_temp.lt.zero) then
       print *,"perturbation_eps_temp invalid"
       stop
      endif 
      if (perturbation_eps_vel.lt.zero) then
       print *,"perturbation_eps_vel invalid"
       stop
      endif 
      if ((num_materials_vel.ne.1).and. &
          (num_materials_vel.ne.nmat)) then
       print *,"num_materials_vel invalid"
       stop
      endif

      call growntilebox(tilelo,tilehi,fablo,fabhi,growlo,growhi,0) 

      do i=growlo(1),growhi(1)
      do j=growlo(2),growhi(2)
      do k=growlo(3),growhi(3)
       call gridsten_level(xsten,i,j,k,level,nhalf)

       sinprod=one
       do dir2=1,SDIM
        if (probhi_arr(dir2).le.problo_arr(dir2)) then
         print *,"probhi_arr invalid"
         stop
        endif
        sinprod=sinprod*sin(two*Pi*perturbation_mode* &
          (xsten(0,dir2)-problo_arr(dir2))/ &
          (probhi_arr(dir2)-problo_arr(dir2)))
       enddo ! dir2

       if (probtype.eq.82) then ! annulus

        if (SDIM.ne.3) then
         print *,"annulus is a 3d problem"
         stop
        endif

        if ((levelrz.eq.0).or.(levelrz.eq.3)) then

         do im=1,nmat
         
          if (im.le.num_materials_vel) then
           velcomp=(im-1)*SDIM+dir+1
           Snew(D_DECL(i,j,k),velcomp)= &
            Snew(D_DECL(i,j,k),velcomp)+ &
            perturbation_eps_vel*probhi_arr(1)*angular_velocity*sinprod
          endif

          if (dir.eq.0) then
           tcomp=(SDIM+1)*num_materials_vel+ &
            (im-1)*num_state_material+2
           Snew(D_DECL(i,j,k),tcomp)= &
            Snew(D_DECL(i,j,k),tcomp)+ &
            perturbation_eps_temp*(twall-fort_tempconst(1))*sinprod
          else if ((dir.eq.1).or.(dir.eq.SDIM-1)) then
           ! do nothing
          else
           print *,"dir invalid add noise"
           stop
          endif
     
         enddo ! im 

        else
         print *,"levelrz invalid probtype==82"
         stop
        endif 

       else
        print *,"probtype invalid"
        stop
       endif
         
      enddo
      enddo
      enddo ! i,j,k

      call growntileboxMAC(tilelo,tilehi,fablo,fabhi,growlo,growhi,0,dir) 

      do i=growlo(1),growhi(1)
      do j=growlo(2),growhi(2)
      do k=growlo(3),growhi(3)
       call gridstenMAC_level(xsten,i,j,k,level,nhalf,dir+1)

       sinprod=one
       do dir2=1,SDIM
        if (probhi_arr(dir2).le.problo_arr(dir2)) then
         print *,"probhi_arr invalid"
         stop
        endif
        sinprod=sinprod*sin(two*Pi*perturbation_mode* &
          (xsten(0,dir2)-problo_arr(dir2))/ &
          (probhi_arr(dir2)-problo_arr(dir2)))
       enddo

       if (probtype.eq.82) then ! annulus

        if (SDIM.ne.3) then
         print *,"annulus is a 3d problem"
         stop
        endif

        if ((levelrz.eq.0).or.(levelrz.eq.3)) then

         do im=1,num_materials_vel
         
          MAC(D_DECL(i,j,k),im)=MAC(D_DECL(i,j,k),im)+ &
           perturbation_eps_vel*probhi_arr(1)*angular_velocity*sinprod

         enddo ! im
 
        else
         print *,"levelrz invalid probtype==82"
         stop
        endif 

       else
        print *,"probtype invalid"
        stop
       endif

      enddo
      enddo
      enddo ! i,j,k

      return
      end subroutine FORT_ADDNOISE


      subroutine FORT_INITVELOCITY( &
        level,time, &
        tilelo,tilehi, &
        fablo,fabhi,bfact, &
        vel,DIMS(vel), &
        dx,xlo,xhi, &
        Re,We,RGASRWATER,use_lsa)
      use probf90_module
      use global_distance_module
      use global_utility_module
      use hydrateReactor_module
      use unimaterialChannel_module
      use River
      use shockdrop
      use USERDEF_module
      use CAV3D_module
      use HELIX_module
      use TSPRAY_module
      use CAV2Dstep_module
      use ZEYU_droplet_impact_module
      use CONE3D_module
      use WAVY_Channel_module
      use rigid_FSI_module
      use sinking_particle_module

      IMPLICIT NONE


      INTEGER_T use_lsa
      REAL_T density_ratio,viscosity_ratio
      REAL_T liquid_density,liquid_viscosity
      REAL_T dxmin,Uscale,Lscale,surface_tension_factor
      REAL_T old_speed,wave_speed
      REAL_T Re,We,RGASRWATER
      REAL_T kterm,velperturb
      REAL_T ktermx,velperturbx

      INTEGER_T    level
      INTEGER_T    tilelo(SDIM),tilehi(SDIM)
      INTEGER_T    fablo(SDIM),fabhi(SDIM)
      INTEGER_T    growlo(3),growhi(3)
      INTEGER_T    bfact
      INTEGER_T    DIMDEC(vel)
      REAL_T     time, dx(SDIM)
      REAL_T     xlo(SDIM), xhi(SDIM)
      REAL_T     vel(DIMV(vel),SDIM)

!     ::::: local variables
      INTEGER_T i,j,k
      REAL_T x,y,z
      REAL_T x_vel,y_vel,z_vel,dist
      REAL_T xx_vel,yy_vel,zz_vel
      REAL_T xtemp,ytemp,ztemp
      REAL_T ytop,radcross,rtest
      REAL_T outer_rad,areacross,radshrink
      REAL_T velcell(SDIM)
      REAL_T cenbc(num_materials,SDIM)
      REAL_T vfracbatch(num_materials)
      INTEGER_T nmat,nten
      REAL_T drat
      REAL_T temp,dens,ccnt
      REAL_T xsten(-3:3,SDIM)
      REAL_T xvec(SDIM)
      INTEGER_T dir
      INTEGER_T nhalf
      REAL_T jumpval,alpha

      logical  alive 
      integer N1parm,N2parm,nn
      complex*16, allocatable, dimension(:) :: vel_lr,vel_lz
      complex*16, allocatable, dimension(:) :: vel_gr,vel_gz
      real*8, allocatable, dimension(:) :: r1,r2
      real*8, allocatable, dimension(:) :: W1bar,W2bar
      REAL_T, allocatable, dimension(:) :: distbatch
      INTEGER_T velsolid_flag
 
      nhalf=3
 
      if (bfact.lt.1) then
       print *,"bfact too small"
       stop
      endif 
      if ((use_lsa.ne.0).and.(use_lsa.ne.1)) then
       print *,"use_lsa invalid"
       stop
      endif

      velsolid_flag=0

      if ((1.eq.0).and.(use_lsa.eq.1)) then
       dxmin=5.8832/32
       Lscale=dxmin
       liquid_viscosity=0.01
       liquid_density=1.0
       Uscale=liquid_viscosity/(Lscale*liquid_density)
       density_ratio=one
       viscosity_ratio=one
       Re=(liquid_density*Lscale*Uscale)/liquid_viscosity
       We=(Uscale**2)*Lscale/5660.0
       RGASRWATER=two
        ! Brackbill Zemach and Kothe might have a different
        ! proportionality constant.
        ! c_2 depends on  how the curvature is discretized according to
        ! Galusinski et al
        ! Sussman and Ohta use 1/sqrt(8 pi^3)
        ! Sussman (2011) uses 1/sqrt(8 pi)
        ! dispersion relation for capillary waves: (Batchelor, ...)
        ! omega^2=k^3 * sigma/(rho1+rho2)  k=2 pi/lambda
        ! T=2 pi/omega  lambda=2 pi/k
        ! speed is lambda/T=omega/k=
        ! k^(3/2) sqrt(sigma/(rho1+rho2)) /k=
        ! sqrt(sigma k/(rho1+rho2))  if rho1=rho2=rho
        ! sqrt(sigma pi/(lambda rho))
       surface_tension_factor=one/sqrt(Pi)
       old_speed=(one/sqrt(dxmin*liquid_density/5660.0))/ &
        surface_tension_factor

       call get_surface_tension_wave_speed(dxmin,Uscale, &
         Lscale,Re,We,RGASRWATER,wave_speed,density_ratio, &
         viscosity_ratio,old_speed)

       print *,"old_speed, new_speed ",old_speed,wave_speed

       stop
      endif

      call checkbound(fablo,fabhi,DIMS(vel),1,-1,1308)

      nmat=num_materials
      nten=( (num_materials-1)*(num_materials-1)+ &
          num_materials-1 )/2

      allocate(distbatch(nmat))

      if (time.ne.zero) then
       print *,"time should be zero in initvelocity"
       stop
      endif

      call default_rampvel(time,xx_vel,yy_vel,zz_vel)

      if (adv_vel.ne.zero) then
        print *,"adv_dir,adv_vel ",adv_dir,adv_vel
      endif

      if (SDIM.eq.2) then

! shear (initvelocity)
      if (probtype.eq.1) then
        if (axis_dir.eq.0) then
         print *,"newtonian liquid"
        else if ((axis_dir.gt.0).and.(axis_dir.le.7)) then
         print *,"shear thinning liquid"
        else if (axis_dir.eq.11) then
         print *,"viscoelastic outer fluid"
        else if (axis_dir.eq.12) then
         print *,"viscoelastic drop"
        else if (axis_dir.eq.140) then
         print *,"droplets head on problem vinletgas=initial velocity"
        else if (axis_dir.eq.141) then
         print *,"diff. droplets head on problem vinletgas=initial velocity"
        else if (axis_dir.eq.13) then
         print *,"middle earth flow"
        else if (axis_dir.eq.14) then
         print *,"droplet collision problem vinletgas=initial velocity"
        else if (axis_dir.eq.15) then
         print *,"test problem from Zuzio et al"
        else if (axis_dir.eq.150) then
         print *,"shock drop interaction problem"
        else if (axis_dir.eq.151) then
         print *,"shock column interaction problem"
        else
         print *,"axis_dir invalid probtype=1"
         stop
        endif
! bubble
      else if (probtype.eq.2) then
       if ((axis_dir.lt.0).or.(axis_dir.gt.7)) then
        print *,"axis_dir out of range in initbubble"
        stop
       else if (axis_dir.eq.0) then
        print *,"Newtonian liquid being computed...."
       else
        print *,"non-newtonian generalized cross carreau model liquid"
        print *,"axis_dir=",axis_dir
       endif
! capillary
      else if ((probtype.eq.3).or. &
               (probtype.eq.41)) then
       print *,"2D pipe problem or rayleigh capillary break up test problem"
      else if (probtype.eq.4) then
       print *,"wavenumber is xblob : ",xblob
       print *,"y=radblob*cos(xblob*pi*x), xblob=2 for rt"
       print *,"xx_vel,yy_vel ",xx_vel,yy_vel
! gas burst
      else if (probtype.eq.8) then
       print *,"INITIALIZING RZ (axisym) GAS BURST PROBLEM "
      else if (probtype.eq.14) then
       print *,"this probtype obsolete"
       stop
! jetting 
      else if (probtype.eq.22) then
       print *,"jetting obselete"
! standing wave problem
      else if (probtype.eq.23) then
       print *,"standing wave problem (NOT r-z)"
       print *,"wavelen is xblob : ",xblob
       print *,"perturbation is radblob ",radblob
       print *,"base amplitude is yblob ",yblob
       print *,"y=yblob+radblob*cos(2pi x/xblob)"
       print *,"levelset < 0 in gas, levelset >0 in liquid"
       print *,"vfrac = 0 in gas, vfrac =1 in liquid"
! hanging
      else if (probtype.eq.25) then
       print *,"hanging drop problem or bubble column problem"
       print *,"axis_dir=1..11 if bubble column, axis_dir: ",axis_dir
       print *,"radius of orifice is radblob: ",radblob
       print *,"if axis_dir>0, zblob = height of column=",zblob
       print *,"if axis_dir=0 zblob = radius preejected fluid=",zblob
       print *,"do not set zblob<0"
       print *,"advbot = rate water poured in =",advbot
       print *,"xblob should be 0, xblob=",xblob
       if (xblob.ne.0.0) then
        stop
       endif
       print *,"yblob=y value of inflow, yblob=",yblob
    
       if ((axis_dir.gt.11).or.(axis_dir.lt.0)) then
        print *,"axis_dir out of range for probtype=25"
       endif
       if ((axis_dir.gt.0).and.(zblob.le.zero)) then
        print *,"zblob should be positive for bubble column problem"
        stop
       endif 
! shed
      else if ((probtype.eq.30).or.(probtype.eq.32).or. &
               (probtype.eq.33).or.(probtype.eq.34) ) then
       print *,"probtype=30 means half circle, probtype=32 means full"
       print *,"probtype=33 means drop on a slope"
       print *,"probtype=34 means capillary tube"
       print *,"probtype=",probtype
! meniscus
      else if (probtype.eq.35) then
       print *,"radblob is NID/2 radblob= ",radblob
       print *,"yblob is NPT  yblob= ",yblob
       print *,"in 3d, xblob is domain base size xblob= ",xblob
      else if (probtype.eq.39) then
       print *,"standing wave problem (NOT r-z)"
       print *,"wavelen is xblob : ",xblob
       print *,"perturbation is radblob ",radblob
       print *,"base amplitude is yblob ",yblob
       print *,"y=yblob+radblob*cos(2pi x/xblob)"
       print *,"levelset < 0 in gas, levelset >0 in liquid"
       print *,"vfrac = 0 in gas, vfrac =1 in liquid"
      else if (probtype.eq.40) then
       if (adv_dir .eq. 1) then
         print *,"translation in x-direction with adv_vel=",adv_vel
       else if (adv_dir .eq. 2) then
         print *,"translation in y-direction with adv_vel=",adv_vel
       else if (adv_dir.eq.3) then
         print *,"translation in x and y-direction with adv_vel=",adv_vel
       else if (adv_dir.eq.4) then
         print *,"solid body rotation with adv_vel=",adv_vel
       else if (adv_dir.eq.5) then
         print *,"stretching with adv_vel=",adv_vel
       else
         write(6,*) "error: initvortpatch: adv_dir = ",adv_dir
         stop
       endif
! overturn
      else if (probtype.eq.45) then
       ytop=0.5
       print *,"using ytop=.5"
      endif


      else if (SDIM.eq.3) then

! shear (initvelocity)
      if (probtype.eq.1) then
        if (axis_dir.eq.0) then
         print *,"newtonian liquid"
        else if ((axis_dir.gt.0).and.(axis_dir.le.7)) then
         print *,"shear thinning liquid"
        else if (axis_dir.eq.11) then
         print *,"LS<0 inside of drop (gas) and LS>0 outside drop (liquid)" 
        else if (axis_dir.eq.12) then
         print *,"viscoelastic drop (LS>0 inside, LS<0 outside)"
        else if (axis_dir.eq.13) then
         print *,"middle earth flow"
        else if (axis_dir.eq.14) then
         print *,"droplet collision problem vinletgas=initial velocity"
        else if (axis_dir.eq.15) then
         print *,"Zuzio test problem"
        else if (axis_dir.eq.150) then
         print *,"shock drop interaction problem"
        else if (axis_dir.eq.151) then
         print *,"shock column interaction problem"
        else
         print *,"axis_dir invalid shear probtype axis_dir ", &
          probtype,axis_dir
         stop
        endif
! bubble
      else if (probtype.eq.2) then
       if ((axis_dir.lt.0).or.(axis_dir.gt.7)) then
        print *,"axis_dir out of range in initbubble"
        stop
       else if (axis_dir.eq.0) then
        print *,"Newtonian liquid being computed...."
       else
        print *,"non-newtonian generalized cross carreau model liquid"
        print *,"axis_dir=",axis_dir
       endif
! pipe
      else if (probtype.eq.41) then

       if (axis_dir.eq.5) then
        ! do nothing
       else
        print *,"pipe problem setup should be modified in 3d"
        stop
       endif

      else if (probtype.eq.4) then
       print *,"wavenumber is xblob : ",xblob
       print *,"y=radblob*cos(xblob*pi*x), xblob=2 for rt"
       print *,"xx_vel,yy_vel ",xx_vel,yy_vel
! splash
      else if (probtype.eq.7) then
       print *,"this probtype obsolete"
       stop
! gas burst
      else if (probtype.eq.18) then
       print *,"not a 3d problem"
       stop
! jetting 
      else if (probtype.eq.22) then
       print *,"jetting obselete"
! standing wave problem
      else if (probtype.eq.23) then
       print *,"standing wave problem (NOT r-z)"
       print *,"wavelen is xblob : ",xblob
       print *,"perturbation is radblob ",radblob
       print *,"base amplitude is yblob ",yblob
       print *,"y=yblob+radblob*cos(2pi x/xblob)"
       print *,"levelset < 0 in gas, levelset >0 in liquid"
       print *,"vfrac = 0 in gas, vfrac =1 in liquid"
! hanging
      else if (probtype.eq.25) then
       print *,"hanging drop problem or bubble column problem"
       print *,"axis_dir=1..11 if bubble column, axis_dir: ",axis_dir
       print *,"radius of orifice is radblob: ",radblob
       print *,"is axis_dir>0, zblob = height of column=",zblob
       print *,"otherwise zblob = radius preejected fluid=",zblob
       print *,"do not set zblob<0"
       print *,"advbot = rate water poured in =",advbot
       print *,"xblob should be 0, xblob=",xblob
       if (xblob.ne.0.0) then
        stop
       endif
       print *,"yblob=y value of inflow, yblob=",yblob
    
       if ((axis_dir.gt.11).or.(axis_dir.lt.0)) then
        print *,"axis_dir out of range in inithanging"
       endif
       if ((axis_dir.gt.0).and.(zblob.lt.zero)) then
        print *,"zblob should be non-negative for bubble column problem"
        stop
       endif 
! shed
      else if ((probtype.eq.30).or.(probtype.eq.32).or. &
               (probtype.eq.33).or.(probtype.eq.34) ) then
       print *,"probtype=30 means half circle, probtype=32 means full"
       print *,"probtype=33 means drop on a slope"
       print *,"probtype=34 means capillary tube"
       print *,"probtype=",probtype
! meniscus
      else if (probtype.eq.35) then
       print *,"radblob is NID/2 radblob= ",radblob
       print *,"yblob is NPT  yblob= ",yblob
       print *,"in 3d, xblob is domain base size xblob= ",xblob
      else if (probtype.eq.39) then
       print *,"standing wave problem (NOT r-z)"
       print *,"wavelen is xblob : ",xblob
       print *,"perturbation is radblob ",radblob
       print *,"base amplitude is yblob ",yblob
       print *,"y=yblob+radblob*cos(2pi x/xblob)"
       print *,"levelset < 0 in gas, levelset >0 in liquid"
       print *,"vfrac = 0 in gas, vfrac =1 in liquid"
! overturn
      else if (probtype.eq.45) then
       ytop=0.5
       print *,"using ytop=.5"
      endif

      else
       print *,"dimension bust"
       stop
      endif


      if((probtype.eq.41).and.(axis_dir.eq.4).and. &
         (use_lsa.eq.1).and.(SDIM.eq.2)) then
       print *,"NOTICE: use_lsa is 1 initializing base velocity"
       N1parm=20
       N2parm=90
       nn=0
       allocate(r1(0:N1parm))
       allocate(W1bar(0:N1parm))
       allocate(vel_lr(0:N1parm))
       allocate(vel_lz(0:N1parm))
       allocate(r2(0:N2parm))
       allocate(W2bar(0:N2parm))
       allocate(vel_gr(0:N2parm))
       allocate(vel_gz(0:N2parm))
       print *,"calling initialvel N1,N2 ",N1parm,N2parm
       call initialvel(N1parm,N2parm,vel_lr,     &
        vel_lz,vel_gr, vel_gz, r1, r2,W1bar,W2bar,Re,We,RGASRWATER)
       print *,"initialvel done"

       inquire(file='initialvel.dat',exist=alive)
       if (alive.eqv..false.) then
         open(20, file='initialvel.dat')
         do i=0, N1parm
          write(20,*) real(vel_lr(i)), aimag(vel_lr(i)),   &
               real(vel_lz(i)), aimag(vel_lz(i))
         enddo
         do i=0, N2parm
          write(20,*) real(vel_gr(i)), aimag(vel_gr(i)),   &
               real(vel_gz(i)), aimag(vel_gz(i))
         enddo
         close(20)
       endif
!       inquire(file='velfield.dat',exist=alive)
!       if (alive.eqv..false.) then
!         open(30, file='velfield.dat')
!       endif

      endif

      if (1.eq.0) then
       print *,"xx_vel= ",xx_vel 
       print *,"yy_vel= ",yy_vel 
       print *,"zz_vel= ",zz_vel 
      endif

      call growntilebox(tilelo,tilehi,fablo,fabhi,growlo,growhi,0) 

      do i=growlo(1),growhi(1)
      do j=growlo(2),growhi(2)
      do k=growlo(3),growhi(3)

        x_vel=xx_vel
        y_vel=yy_vel
        z_vel=zz_vel

        call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)

        x=xsten(0,1)
        y=xsten(0,2)
        z=xsten(0,SDIM)
        do dir=1,SDIM
         xvec(dir)=xsten(0,dir)
        enddo

        if (is_in_probtype_list().eq.1) then

         call SUB_LS(xvec,time,distbatch,num_materials)
          ! pass dx
         call SUB_VEL(xvec,time,distbatch,velcell, &
          velsolid_flag,dx,num_materials)
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)

        else if (probtype.eq.411) then
         call CAV3D_LS(xvec,time,distbatch)
         call CAV3D_VEL(xvec,time,distbatch,velcell,velsolid_flag)
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)

        else if (probtype.eq.401) then
         call HELIX_LS(xvec,time,distbatch)
         call HELIX_VEL(xvec,time,distbatch,velcell,velsolid_flag)
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)

        else if (probtype.eq.402) then
         call TSPRAY_LS(xvec,time,distbatch)
         call TSPRAY_VEL(xvec,time,distbatch,velcell,velsolid_flag)
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)

        else if (probtype.eq.412) then ! step
         call CAV2Dstep_LS(xvec,time,distbatch)
         call CAV2Dstep_VEL(xvec,time,distbatch,velcell,velsolid_flag)
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)

        else if (probtype.eq.413) then ! ZEYU droplet impact
         call ZEYU_droplet_impact_LS(xvec,time,distbatch)
          ! pass dx
         call ZEYU_droplet_impact_LS_VEL(xvec,time,distbatch,velcell, &
          velsolid_flag,dx)
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)

        else if (probtype.eq.533) then
         call rigid_FSI_LS(xvec,time,distbatch)
         call rigid_FSI_VEL(xvec,time,distbatch,velcell,velsolid_flag)
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)
        else if (probtype.eq.534) then
         call sinking_FSI_LS(xvec,time,distbatch)
         call sinking_FSI_VEL(xvec,time,distbatch,velcell,velsolid_flag)
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)

        else if (probtype.eq.311) then ! user defined example
         call USERDEF_LS(xvec,time,distbatch)
         call USERDEF_VEL(xvec,time,distbatch,velcell,velsolid_flag)
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)

        else if (probtype.eq.222) then ! cone3d in INITVELOCITY
         call CONE3D_LS(xvec,time,distbatch)
         call CONE3D_VEL(xvec,time,distbatch,velcell,velsolid_flag)
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)

        else if (probtype.eq.915) then ! wavy channel
         call WAVY_INIT_LS(xvec,time,distbatch)
         call WAVY_INIT_VEL(xvec,time,distbatch,velcell,velsolid_flag)
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)

        else if (probtype.eq.82) then ! annulus (2D or 3D) (in initvelocity)
         x_vel=zero
         y_vel=zero
         z_vel=zero

         ! HYDRATE  (in initvelocity)
        else if (probtype.eq.199) then
         call materialdist_batch(xsten,nhalf,dx,bfact,distbatch,nmat)
         if (distbatch(1).ge.zero) then
          call INIT_STATE_WATER(x,y,z,time,velcell,temp,dens,ccnt)
         else if (distbatch(2).ge.zero) then
          call INIT_STATE_GAS(x,y,z,time,velcell,temp,dens,ccnt)
         else
          call INIT_STATE_HYDRATE(x,y,z,time,velcell,temp,dens,ccnt)
         endif
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)

         ! in: FORT_INITVELOCITY
        else if (probtype.eq.220) then
         call UNIMAT_INIT_VEL(x,y,z,velcell)
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)

        else if ((probtype.eq.299).or. &
                 (probtype.eq.301)) then ! melting, initial velocity

         x_vel=zero
         y_vel=zero
         z_vel=zero

        else if (probtype.eq.209) then  ! river

         call RiverVelocity(x,y,z,velcell,axis_dir,probloz,probhiz)
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)

          ! Zuzio, initvelocity
        else if ((probtype.eq.1).and.(axis_dir.eq.15)) then 
         x_vel=zero
         y_vel=zero
         z_vel=zero
        else if ((probtype.eq.1).and. &
                 ((axis_dir.eq.150).or. &
                  (axis_dir.eq.151))) then
         call shockdrop_velocity(x,y,z,velcell, &
          xblob,yblob,zblob,radblob,zblob2,axis_dir)
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)
        else if (probtype.eq.31) then  ! translating circle or sphere
         call circleuu(velcell(1),x,y,z)
         call circlevv(velcell(2),x,y,z)
         if (SDIM.eq.3) then
          call circleww(velcell(SDIM),x,y,z)
         endif
         x_vel=velcell(1)
         y_vel=velcell(2)
         z_vel=velcell(SDIM)

         ! Marioff injector
        else if (probtype.eq.537) then
          call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
          x_vel=velcell(1)
          y_vel=velcell(2)
          z_vel=velcell(SDIM)

        else if (probtype.eq.710) then
           x_vel=zero
           y_vel=zero
           z_vel=zero

          ! in "initvelocity":
          ! melting ice block on substrate.
        else if (probtype.eq.59) then
          x_vel=zero
          y_vel=zero
          z_vel=zero

        else if (probtype.eq.201) then ! stratified bubble (initvelocity)

         if (advbot.eq.zero) then
          ! do nothing
         else
          x_vel=zero
          y_vel=zero
          z_vel=zero
          call get_initial_vfrac(xsten,nhalf,dx,bfact,vfracbatch,cenbc,nmat)
          if (vfracbatch(2).gt.zero) then
           if (SDIM.eq.2) then
            y_vel=-abs(advbot)
           else if (SDIM.eq.3) then
            z_vel=-abs(advbot)
           else
            print *,"dimension bust"
            stop
           endif
          endif
         endif ! advbot <> 0

         ! shock tube problems (initvelocity)
        else if ((probtype.eq.92).or.(probtype.eq.93)) then 
         x_vel=zero
         y_vel=zero
         z_vel=zero
         if (axis_dir.eq.0) then ! Sod shock tube
          if (x.le.half) then
           x_vel=zero
          else
           x_vel=zero
          endif
         else if (axis_dir.eq.1) then ! strong shock tube
          if (x.le.half) then
           x_vel=zero
          else
           x_vel=zero
          endif
         else if (axis_dir.eq.2) then ! shock-turbulence
          if (x.le.one) then
           x_vel=2.629369
          else
           x_vel=zero
          endif
         else if (axis_dir.eq.3) then ! mach>4
          if (x.le.one) then
           x_vel=5.0
          else
           x_vel=zero
          endif
         else if (axis_dir.eq.4)  then ! smooth problem
          x_vel=zero
          y_vel=zero
          z_vel=zero
         else
          print *,"axis_dir invalid probtype=92"
          stop
         endif

        else if (SDIM.eq.2) then


         if (probtype.eq.801.and.axis_dir.eq.3) then ! convective evaporation
          if(sqrt( (x-xblob)**2+(y-yblob)**2 ).lt.radblob) then
            x_vel=zero
          endif

           ! dissolution initial velocity
         else if (probtype.eq.802) then
          x_vel=zero
          y_vel=zero
          call vapordist(xsten,nhalf,dx,bfact,dist)
          if (dist.gt.radblob) then
           dist=radblob
          endif
          if (dist.ge.half*dx(SDIM)) then
           kterm=two*Pi*yblob2*y/(two*radblob)
           velperturb=one+radblob2*cos(kterm)
           ktermx=two*Pi*yblob2*x/(two*radblob)
           velperturbx=one+radblob2*cos(ktermx)
           if (1.eq.0) then
            x_vel=1.5*adv_vel*velperturb*velperturbx* &
               (one-(dist/radblob)**2)
           else
            x_vel=adv_vel*velperturb*velperturbx  ! plug flow
           endif
           y_vel=adv_vel*radblob2*cos(kterm)*cos(ktermx)
          endif
         else if (probtype.eq.602) then  ! Rayleigh Taylor
          x_vel=zero
          y_vel=zero
         else if ((probtype.eq.1).and.(axis_dir.lt.150)) then
          if (axis_dir.eq.11) then
           x_vel=vinletgas*(y/yblob-one)
          else if (axis_dir.eq.14) then
           dist=radblob-sqrt((x-xblob)**2+(y-yblob)**2)
           if (dist.ge.zero) then
             x_vel=zero
             y_vel=vinletgas
           endif
          else if ((axis_dir.eq.140).or.(axis_dir.eq.141)) then
           dist=max(-sqrt( (x-xblob)**2 + (y-yblob)**2 )+radblob, &
                    -sqrt( (x-xblob)**2 + (y-yblob2)**2 )+radblob)

           if (dist.ge.zero) then
             x_vel=zero
             if( y > half*(yblob+yblob2))then
              y_vel=-abs(vinletgas)
             else
              y_vel=abs(vinletgas)
             endif
           endif
          else if ((axis_dir.eq.12).and.(adv_dir.eq.1).and. &
                   (vinletgas.eq.zero)) then
           x_vel=zero  ! no velocity in the droplet at t=0
          endif
         else if (probtype.eq.531) then ! falling sphere - INIT_VELOCITY
          x_vel=zero
          y_vel=zero
! Reiber problem
         else if (probtype.eq.540) then
          call get_Rieber_velocity(xsten,nhalf,bfact,dx,velcell)
          y_vel=velcell(SDIM)
         else if (probtype.eq.17) then  ! drop collide of diesel and water
! vb-vt=1
! vb db + vt dt=0
! -vt dt/db - vt = 1
! vt=-1/(dt/db + 1)
! vb=1+vt=dt/db / (1+dt/db)
          call get_initial_vfrac(xsten,nhalf,dx,bfact,vfracbatch,cenbc,nmat)
          drat=fort_denconst(3)/fort_denconst(1)  ! dt/db
          if (vfracbatch(1).gt.zero) then  ! diesel on bottom
           y_vel=drat/(one+drat)
          else if (vfracbatch(3).gt.zero) then  ! water on top
           y_vel=-one/(one+drat)
          else
           y_vel=zero
          endif  
         else if (probtype.eq.18) then  ! drop collide same material
          call get_initial_vfrac(xsten,nhalf,dx,bfact,vfracbatch,cenbc,nmat)
          if (vfracbatch(1).gt.zero) then
           if (y.gt.zero) then
            y_vel=-half
           else
            y_vel=half
           endif
          else
           y_vel=zero
          endif
         else if (probtype.eq.51) then ! oscillating column
          call get_initial_vfrac(xsten,nhalf,dx,bfact,vfracbatch,cenbc,nmat)
          if (vfracbatch(1).gt.zero) then
           x_vel=adv_vel
          else
           x_vel=zero
          endif
         else if (probtype.eq.102) then ! nozzle
          if (yblob3.le.zero) then
           print *,"yblob3 invalid"
           stop
          endif
          x_vel=zero
          y_vel=zero 
           ! liquid nozzle: 0<y<yblob+yblob2
          if (y.le.yblob+yblob2) then
           outer_rad=radblob3-y*(radblob3-radblob4)/yblob3 
           areacross=Pi*(outer_rad**2-radblob5**2)
           if ((x.ge.radblob5).and.(x.le.outer_rad)) then
            y_vel=advbot*1000.0/areacross
           endif 
           ! gas nozzle: 0<y<yblob3
          else if (y.le.yblob3) then
           outer_rad=radblob3-y*(radblob3-radblob4)/yblob3
           areacross=Pi*outer_rad**2
           if (x.le.outer_rad) then
            y_vel=advbot*1000.0/areacross
           endif
          else  ! expansion region
           radshrink=radblob7**2-radblob5**2
           if (radshrink.le.zero) then
            print *,"radshrink invalid"
            stop
           endif
           radshrink=sqrt(radshrink)
           outer_rad=radblob4+ &
             (y-yblob3)*(radshrink-radblob4)/(probhiy-yblob3)
           areacross=Pi*outer_rad**2
           if (x.le.outer_rad) then
            y_vel=advbot*1000.0/areacross
           endif
          endif 
! microfluidics problem initial velocity at t=0
         else if (probtype.eq.5700) then
          x_vel=zero
          y_vel=zero
!         z_vel=zero

           ! in: INITVELOCITY (2D)
         else if ((probtype.eq.3).or. &
                  (probtype.eq.41)) then

          if ((axis_dir.eq.0).or. &
              (axis_dir.eq.1).or. &
              (axis_dir.eq.2).or. &
              (axis_dir.eq.3)) then
           call get_pipe_velocity(xsten,nhalf,dx,bfact,velcell,zero)
           x_vel=velcell(1)
           y_vel=velcell(2)

           ! in: INITVELOCITY (2D)
          else if (axis_dir.eq.5) then
           call get_pipe_velocity(xsten,nhalf,dx,bfact,velcell,zero)
           x_vel=velcell(1)
           y_vel=velcell(2)
!          z_vel=zero
          else if (axis_dir.eq.4) then

           if (1.eq.0) then
            call get_pipe_vfrac(xsten,nhalf,dx,bfact,vfracbatch,cenbc,nmat) 
            if (vfracbatch(1).gt.zero) then
             dist=half
            else
             dist=-half
            endif
           else
            call inletpipedist(x,y,z,nmat,distbatch)   
            dist=distbatch(1)
           endif
  
           call get_pipe_velocity(xsten,nhalf,dx,bfact,velcell,zero)  ! time=0
           y_vel=velcell(2)
           x_vel=zero

           if (use_lsa.eq.1) then
            call velinterpolation(N1parm,N2parm, r1, r2, vel_lr,vel_lz, &
                 vel_gr, vel_gz, x, y, dist, x_vel, y_vel,W1bar,W2bar)
!           if (alive.eqv..false.) then
!              write(30,*) x, y, x_vel, y_vel
!           endif
           endif
          else
           print *,"axis_dir invalid initvel axis_dir=",axis_dir
           stop
          endif

! rotate
         else if (probtype.eq.5) then
          print *,"this problem obsolete"
          stop
! oilexpel
         else if (probtype.eq.16) then
          if ((y.gt.yblob).and.(x.le.xblob+radblob)) then
           y_vel = -abs(advbot)
          endif
         else if (probtype.eq.23) then
          call vapordist(xsten,nhalf,dx,bfact,dist)
          if (dist.ge.zero) then
           x_vel=zero
           y_vel=zero
          endif
! validate
         else if (probtype.eq.24) then
          x_vel=-sin(Pi*x)*sin(Pi*x)*sin(two*Pi*y)
          y_vel=sin(Pi*y)*sin(Pi*y)*sin(two*Pi*x)
         else if (probtype.eq.25) then  ! in initvelocity
          if (axis_dir.eq.0) then
           if ((y.gt.yblob).and.(x.le.xblob+radblob)) then
            y_vel = -abs(advbot)
           endif
          endif
! swirl 2D, in: INITVELOCITY
         else if (probtype.eq.26) then

          if ((axis_dir.eq.0).or.(axis_dir.eq.1)) then

           if (y.le.half) then
            x_vel=tanh( (y-one/four)*30.0 )
           else
            x_vel=tanh( (three/four-y)*30.0 )
           endif
           y_vel=0.05*sin(two*Pi*x)

          else if ((axis_dir.eq.2).or.(axis_dir.eq.3)) then

           dist=sqrt((x-xblob)**2+(y-yblob)**2)-radblob
           jumpval=tanh(30.0*dist)
           jumpval=(jumpval+one)/two
           alpha=(one-jumpval)*vinletgas
           x_vel=alpha*(y-yblob)
           y_vel=-alpha*(x-xblob)
           if ((adv_dir.eq.1).or.(adv_dir.eq.3)) then
            x_vel=x_vel+adv_vel
           endif
           if ((adv_dir.eq.2).or.(adv_dir.eq.3)) then
            y_vel=y_vel+adv_vel
           endif
          else if (axis_dir.eq.10) then
           x_vel=-(sin(Pi*x)**2)*sin(two*Pi*y)
           y_vel=sin(two*Pi*x)*(sin(Pi*y)**2)
          else if (axis_dir.eq.11) then  ! 2D BCG periodic
           x_vel=-sin(two*Pi*x)*cos(two*Pi*y)
           y_vel=cos(two*Pi*x)*sin(two*Pi*y)
           if ((adv_dir.eq.1).or.(adv_dir.eq.3)) then
            x_vel=x_vel+adv_vel
           endif
           if ((adv_dir.eq.2).or.(adv_dir.eq.3)) then
            y_vel=y_vel+adv_vel
           endif
          else
           print *,"axix_dir invalid"
           stop
          endif
             
         else if (probtype.eq.28) then ! 2D prescribed motion
          call zalesakuu(x_vel,x,y,z,zero,dx)
          call zalesakvv(y_vel,x,y,z,zero,dx)
         else if (probtype.eq.29) then
          call deformuu(x_vel,x,y,zero,dx)
          call deformvv(y_vel,x,y,zero,dx)
         else if (probtype.eq.202) then  ! liquid lens
          ! do nothing (adv_vel used above if prescribed)
         else if (probtype.eq.36) then ! bubble 2D
          if ((axis_dir.eq.2).or.(axis_dir.eq.4)) then
           x_vel=zero
           y_vel=zero
          endif
          if ((xblob10.gt.zero).and. &
              (yblob10.ne.zero)) then
           y_vel=x*yblob10/xblob10
          endif
         else if (probtype.eq.37) then
          ! do nothing
         else if (probtype.eq.11) then
          print *,"cavitation with outflow top is deleted"
          stop

          ! in: FORT_INITVELOCITY (2D section)
         else if (probtype.eq.42) then
          ! do nothing - bubble jetting 2D
         else if (probtype.eq.46) then
          if ((axis_dir.ge.0).and.(axis_dir.lt.10)) then
           ! do nothing cavitation 2D, jwl
          else if (axis_dir.eq.10) then
           if (1.eq.0) then
            call get_initial_vfrac(xsten,nhalf,dx,bfact,vfracbatch,cenbc,nmat)
            if (vfracbatch(nmat).gt.zero) then ! sphere
             y_vel=advbot
            else
             y_vel=zero
            endif
           endif
          else if (axis_dir.eq.20) then
           x_vel=adv_vel
           y_vel=zero
          else
           print *,"axis_dir invalid"
           stop
          endif
! kh
         else if (probtype.eq.38) then
          call vapordist(xsten,nhalf,dx,bfact,dist)
          if (dist.lt.zero) then
           y_vel=-x_vel*radblob*two*Pi*sin(two*Pi*x/xblob)/xblob
          else
           x_vel=zero
           y_vel=zero
          endif
! vstanding
         else if (probtype.eq.39) then
          if (axis_dir.eq.0) then
           x_vel=zero
           y_vel=zero
          else
           print *,"this problem obsolete"
           stop
          endif
! vortpatch
         else if (probtype.eq.40) then
          x_vel=zero
          y_vel=zero
! overturn
         else if (probtype.eq.45) then
          print *,"this probtype obsolete"
          stop
! paddle
         else if (probtype.eq.50) then
          if (y.lt.zblob) then
           x_vel=zero
          endif
         else if (probtype.eq.58) then
          x_vel=zero
! jetbend
         else if (probtype.eq.53) then
          call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
          x_vel=velcell(1)
          y_vel=velcell(2)
! 2d diesel injector w/needle
         else if ((probtype.eq.538).or.(probtype.eq.541)) then
          call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
          x_vel=velcell(1)
          y_vel=velcell(2)
! supersonic nozzle: FORT_INITVELOCITY
         else if (probtype.eq.539) then
          call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
          x_vel=velcell(1)
          y_vel=velcell(2)
         else if (probtype.eq.532) then ! imp jets from sides (initvelocity)
          call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
          x_vel=velcell(1)
          y_vel=velcell(2)

! 3D jet coaxial
         else if (probtype.eq.72) then
          call vapordist(xsten,nhalf,dx,bfact,dist)
          if (dist.ge.zero) then
           x_vel=advbot
          else
           x_vel=adv_vel
          endif
! milkdrop
         else if (probtype.eq.61) then
          if (sqrt( (x-xblob)**2+(y-yblob)**2 ).le.radblob) then
           if (axis_dir.eq.1) then
            y_vel=-one
           endif
          endif
! nozzle
         else if ((probtype.eq.63).or.(probtype.eq.64)) then
          call nozzlerad(z,radcross,zero)
          if (x.gt.radcross) then
           y_vel=zero
          else
           y_vel=y_vel*(xblob10**2/radcross**2)
          endif
! pulse
         else if (probtype.eq.66) then
          xtemp=sqrt(three*radblob/(four*zblob*zblob*zblob))
          x_vel=sqrt(9.8*zblob)*(radblob/zblob)/(cosh(xtemp*x)**2)
          y_vel=sqrt(three*9.8*zblob)*((radblob/zblob)**(1.5))* &
            (y/zblob)*tanh(xtemp*x)/(cosh(xtemp*x)**2)
         else if (probtype.eq.110) then
          call get_bump_velocity(xsten,nhalf,dx,bfact,x_vel,time)
          y_vel=zero
         else if (probtype.eq.701) then
          ! flapping wing, init_velocity, do nothing: x_vel=adv_vel
         endif

        else if (SDIM.eq.3) then

         if ((probtype.eq.1).and.(axis_dir.lt.150)) then
          if ((axis_dir.eq.11).or.(axis_dir.eq.12)) then
           if (zblob.gt.zero) then
            x_vel=vinletgas*(z/zblob-one)
           else if (zblob.eq.zero) then
            if (probhiz.le.zero) then
             print *,"probhiz invalid"
             stop
            endif
            x_vel=vinletgas*z/probhiz
           else
            print *,"parameters invalid for shear problem"
            stop
           endif

           if (xblob10.eq.one) then
            if (zblob.gt.zero) then
             x_vel=radblob10+(vinletgas-radblob10)*z/(two*zblob)
            else
             if (radblob10.ne.zero) then
              print *,"zero velocity at axis of symmetry"
             endif
             if (zblob10.eq.zero) then
              print *,"zblob10 should be domain height"
              stop
             endif
             x_vel=vinletgas*z/zblob10
            endif
           endif
          else if (axis_dir.eq.14) then
           dist=radblob-sqrt((x-xblob)**2+(y-yblob)**2)
           if (dist.ge.zero) then
            x_vel=zero
            y_vel=vinletgas
           endif
          endif

! pipe setup at t=0
! in: INITVELOCITY, 3D
         else if (probtype.eq.41) then
          if (axis_dir.eq.5) then
           call get_pipe_velocity(xsten,nhalf,dx,bfact,velcell,zero)
           x_vel=velcell(1)
           y_vel=velcell(2)
           z_vel=velcell(SDIM)
          else
           print *,"this problem not ready for 3d yet"
           stop
          endif

! wave
         else if (probtype.eq.13) then
          print *,"option obsolete"
          stop
         else if (probtype.eq.14) then
          print *,"option obsolete"
          stop
         else if (probtype.eq.16) then
          if ((y.gt.yblob).and.(x.le.xblob+radblob)) then
           y_vel = -abs(advbot)
          endif
         else if (probtype.eq.23) then
          print *,"this option called in error"
          stop
! validate
         else if (probtype.eq.24) then
          x_vel=-sin(Pi*x)*sin(Pi*x)*sin(two*Pi*y)
          y_vel=sin(Pi*y)*sin(Pi*y)*sin(two*Pi*x)
         else if (probtype.eq.25) then
          if (axis_dir.eq.0) then
           if ((y.gt.yblob).and.(x.le.xblob+radblob)) then
            y_vel = -abs(advbot)
           endif
          endif
! swirl 3D
         else if (probtype.eq.26) then 

          if ((axis_dir.eq.0).or.(axis_dir.eq.1)) then
           ! x-y
           if (adv_dir.eq.3) then
            if (y.le.half) then
             x_vel=tanh( (y-one/four)*30.0 )
            else
             x_vel=tanh( (three/four-y)*30.0 )
            endif
            y_vel=0.05*sin(two*Pi*x)
            z_vel=zero
           ! x-z
           else if (adv_dir.eq.2) then
            if (z.le.half) then
             x_vel=tanh( (z-one/four)*30.0 )
            else
             x_vel=tanh( (three/four-z)*30.0 )
            endif
            z_vel=0.05*sin(two*Pi*x)
            y_vel=zero
           ! y-z
           else if (adv_dir.eq.1) then
            if (z.le.half) then
             y_vel=tanh( (z-one/four)*30.0 )
            else
             y_vel=tanh( (three/four-z)*30.0 )
            endif
            z_vel=0.05*sin(two*Pi*y)
            x_vel=zero
           else
            print *,"adv_dir invalid probtype==26 (13)"
            stop
           endif

          else if ((axis_dir.eq.2).or.(axis_dir.eq.3)) then

           dist=sqrt((x-xblob)**2+(y-yblob)**2+(z-zblob)**2)-radblob
           jumpval=tanh(30.0*dist)
           jumpval=(jumpval+one)/two
           alpha=(one-jumpval)*vinletgas
           x_vel=alpha*(y-yblob)
           y_vel=-alpha*(x-xblob)
           if ((adv_dir.eq.1).or.(adv_dir.eq.4)) then
            x_vel=x_vel+adv_vel
           endif
           if ((adv_dir.eq.2).or.(adv_dir.eq.4)) then
            y_vel=y_vel+adv_vel
           endif
           if ((adv_dir.eq.3).or.(adv_dir.eq.4)) then
            z_vel=z_vel+adv_vel
           endif

          else if (axis_dir.eq.11) then ! 3D BCG periodic

           if ((probhix.eq.one).and. &
               (probhiy.eq.one).and. &
               (probhiz.eq.half)) then
            x_vel=-sin(two*Pi*x)*cos(two*Pi*y)
            y_vel=cos(two*Pi*x)*sin(two*Pi*y)
            z_vel=zero
           else if ((probhix.eq.one).and. &
                    (probhiy.eq.half).and. &
                    (probhiz.eq.one)) then
            x_vel=-sin(two*Pi*x)*cos(two*Pi*z)
            z_vel=cos(two*Pi*x)*sin(two*Pi*z)
            y_vel=zero
           else if ((probhix.eq.half).and. &
                    (probhiy.eq.one).and. &
                    (probhiz.eq.one)) then
            y_vel=-sin(two*Pi*y)*cos(two*Pi*z)
            z_vel=cos(two*Pi*y)*sin(two*Pi*z)
            x_vel=zero
           else
            print *,"probhi x,y, or z invalid"
            stop
           endif

           if ((adv_dir.eq.1).or.(adv_dir.eq.4).or. &
               (adv_dir.eq.5).or.(adv_dir.eq.7)) then
            x_vel=x_vel+adv_vel
           endif
           if ((adv_dir.eq.2).or.(adv_dir.eq.4).or. &
               (adv_dir.eq.6).or.(adv_dir.eq.7)) then
            y_vel=y_vel+adv_vel
           endif
           if ((adv_dir.eq.3).or.(adv_dir.eq.5).or. &
               (adv_dir.eq.6).or.(adv_dir.eq.7)) then
            z_vel=z_vel+adv_vel
           endif

          else
           print *,"axix_dir invalid"
           stop
          endif

         else if (probtype.eq.28) then
          call zalesakuu(x_vel,x,y,z,zero,dx)
          call zalesakvv(y_vel,x,y,z,zero,dx)
          call zalesakww(z_vel,x,y,z,zero,dx)
         else if (probtype.eq.29) then
          call deform3duu(x_vel,x,y,z,zero,dx)
          call deform3dvv(y_vel,x,y,z,zero,dx)
          call deform3dww(z_vel,x,y,z,zero,dx)
! vbubble - this routine is initvelocity
         else if (probtype.eq.36) then ! bubble 3D
          if ((axis_dir.eq.2).or.(axis_dir.eq.4)) then
           x_vel=zero
           y_vel=zero
           z_vel=zero
          endif

          if ((xblob10.gt.zero).and. &
              ((yblob9.ne.zero).or.(yblob10.ne.zero))) then
           if (probhix-problox.le.zero) then
            print *,"probhix or problox invalid"
            stop
           endif
           z_vel=yblob9+(x-problox)*(yblob10-yblob9)/(probhix-problox)
          endif
         else if (probtype.eq.37) then
          ! do nothing

          ! in: FORT_INITVELOCITY (3D section)
         else if (probtype.eq.42) then
          ! do nothing: bubble jetting 3D
         else if (probtype.eq.46) then
          ! do nothing: cavitation 3D
! kh
         else if (probtype.eq.38) then
          call vapordist(xsten,nhalf,dx,bfact,dist)
          if (dist.lt.zero) then
           y_vel=-x_vel*radblob*two*Pi*sin(two*Pi*x/xblob)/xblob
          else
           x_vel=zero
           y_vel=zero
          endif
! vstanding
         else if (probtype.eq.39) then
          print *,"this problem obsolete"
          stop
! vortpatch
         else if (probtype.eq.40) then
          x_vel=zero
          y_vel=zero
! overturn
         else if (probtype.eq.45) then
          print *,"this problem obsolete" 
          stop
! paddle
         else if (probtype.eq.50) then
          if ((z.lt.zblob-radblob).or.(z.gt.zblob+radblob).or. &
              (y.lt.yblob-radblob).or.(y.gt.yblob+radblob)) then
           x_vel=zero
          endif
! bering
         else if (probtype.eq.51) then
          x_vel=zero
         else if (probtype.eq.58) then
          x_vel=zero
         else if (probtype.eq.5501) then ! drop hitting rough surface
          if (axis_dir.ne.0) then
           print *,"axis_dir invalid"
           stop
          endif
          x_vel=zero
          y_vel=zero
          z_vel=zero
           ! initialize velocity of droplet only
          call get_initial_vfrac(xsten,nhalf,dx,bfact,vfracbatch,cenbc,nmat)
          if (vfracbatch(1).gt.zero) then
           z_vel=-abs(advbot)
          endif
! microfluidics problem initial velocity at t=0
         else if (probtype.eq.5700) then
          x_vel=zero
          y_vel=zero
          z_vel=zero
! airblast with coaxial air flow  at t=0
         else if (probtype.eq.529) then
          x_vel=zero
          y_vel=zero
          z_vel=zero
! jetbend at t=0
         else if (probtype.eq.53) then
          call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
          x_vel=velcell(1)
          y_vel=velcell(2)
          z_vel=velcell(SDIM)
! impinging jets - AIAA 2008-4847
         else if (probtype.eq.530) then
          call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
          x_vel=velcell(1)
          y_vel=velcell(2)
          z_vel=velcell(SDIM)
         else if (probtype.eq.532) then ! imp jets from sides (initvelocity)
          call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
          x_vel=velcell(1)
          y_vel=velcell(2)
          z_vel=velcell(SDIM)
         else if (probtype.eq.536) then
          call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
          x_vel=velcell(1)
          y_vel=velcell(2)
          z_vel=velcell(SDIM)

          ! initvelocity
          ! 3D diesel injector w/needle
         else if ((probtype.eq.538).or.(probtype.eq.541)) then
          call get_jetbend_velocity(xsten,nhalf,dx,bfact,velcell)
          x_vel=velcell(1)
          y_vel=velcell(2)
          z_vel=velcell(SDIM)

! Reiber problem
         else if (probtype.eq.540) then
          call get_Rieber_velocity(xsten,nhalf,bfact,dx,velcell)
          z_vel=velcell(SDIM)

! ysl 05/12/14
         else if (probtype.eq.17) then  ! drop collide of diesel and water
          call get_initial_vfrac(xsten,nhalf,dx,bfact,vfracbatch,cenbc,nmat)
          drat=fort_denconst(3)/fort_denconst(1)  ! dt/db
          if (vfracbatch(1).gt.zero) then  ! diesel on bottom
           y_vel=drat/(one+drat)
          else if (vfracbatch(3).gt.zero) then  ! water on top
           y_vel=-one/(one+drat)
          else
           y_vel=zero
          endif
         else if (probtype.eq.18) then  ! drop collide same material
          call get_initial_vfrac(xsten,nhalf,dx,bfact,vfracbatch,cenbc,nmat)
          if (vfracbatch(1).gt.zero) then
           if (y.gt.zero) then
            y_vel=-half
           else
            y_vel=half
           endif
          else
           y_vel=zero
          endif

! milkdrop (initvelocity)
         else if ((probtype.eq.61).or.(probtype.eq.64)) then
          dist=sqrt( (x-xblob)**2+(y-yblob)**2+(z-zblob)**2 )-radblob
          if (dist.le.half*dx(SDIM)) then
           if (axis_dir.eq.1) then
            z_vel=-one
           else if (axis_dir.eq.2) then
            z_vel=vinletgas
           else
            print *,"axis_dir invalid"
            stop
           endif
          endif
! nozzle
         else if (probtype.eq.63) then
          call nozzlerad(z,radcross,zero)
          rtest=sqrt(x**2+y**2)
          if (rtest.gt.radcross) then
           z_vel=zero
          else
           z_vel = z_vel*(xblob10**2/radcross**2)
          endif
! coffee
         else if (probtype.eq.65) then
! center of whirlpool is (xtemp,ytemp) = (5,5); strength = radblob5
          xtemp = (xlo(1)+xhi(1))/2.0
          ytemp = (xlo(2)+xhi(2))/2.0
          ztemp = (ytemp-y)*(ytemp-y)+(x-xtemp)*(x-xtemp)+one
          x_vel = radblob5*(ytemp-y)/ztemp
          y_vel = radblob5*(x-xtemp)/ztemp
          if (z.gt.zblob3) then
           x_vel = zero
           y_vel = zero
          endif

! pulse
         else if (probtype.eq.66) then
          xtemp=sqrt(three*radblob/(four*zblob*zblob*zblob))
          x_vel=sqrt(9.8*zblob)*(radblob/zblob)/(cosh(xtemp*x)**2)
          y_vel=zero
          z_vel=sqrt(three*9.8*zblob)*((radblob/zblob)**(1.5))* &
            (z/zblob)*tanh(xtemp*x)/(cosh(xtemp*x)**2)
! gear
         else if (probtype.eq.563) then
          if (levelrz.eq.0) then
           if (radblob.gt.zero) then
            call cylinderdist(y,z,x,yblob,zblob,radblob,xblob-radblob, &
              xblob+radblob,dist)
            dist=-dist
            if (dist.ge.zero) then
             x_vel=advbot
            endif
           endif
          else 
           print *,"levelrz invalid probtype = 563"
           stop
          endif
         else if (probtype.eq.701) then
          ! flapping wing, init_velocity, do nothing: x_vel=adv_vel
         endif

        else
         print *,"dimension bust"
         stop
        endif

        vel(D_DECL(i,j,k),1) = x_vel
        vel(D_DECL(i,j,k),2) = y_vel
        if (SDIM.eq.3) then
         vel(D_DECL(i,j,k),SDIM) = z_vel
        endif

      enddo
      enddo
      enddo

      if((probtype.eq.41).and. &
         (axis_dir.eq.4).and. &
         (use_lsa.eq.1).and.(SDIM.eq.2)) then
       deallocate(r1)
       deallocate(W1bar)
       deallocate(vel_lr)
       deallocate(vel_lz)
       deallocate(r2)
       deallocate(W2bar)
       deallocate(vel_gr)
       deallocate(vel_gz)
      endif

      deallocate(distbatch)

      return
      end subroutine FORT_INITVELOCITY

       ! before this routine:
       ! calc_error_indicator
       ! EOS_error_ind
      subroutine FORT_VFRACERROR (  &
       tag,DIMS(tag), &
       set,clear, &
       vfrac,DIMS(vfrac), &
       tilelo,tilehi, &
       fablo,fabhi,bfact, &
       nvar, &
       domlo,domhi, &
       dx,xlo,problo, &
       time, &
       level, &
       max_level, &
       max_level_two_materials, &
       nblocks, &
       xblocks,yblocks,zblocks, &
       rxblocks,ryblocks,rzblocks,ncoarseblocks, &
       xcoarseblocks,ycoarseblocks,zcoarseblocks, &
       rxcoarseblocks,rycoarseblocks,rzcoarseblocks)

      use probf90_module
      use global_utility_module
      use probcommon_module

      IMPLICIT NONE

      INTEGER_T nblocks,ncoarseblocks
      REAL_T xblocks(10),yblocks(10),zblocks(10)
      REAL_T rxblocks(10),ryblocks(10),rzblocks(10)
      REAL_T xcoarseblocks(10),ycoarseblocks(10),zcoarseblocks(10)
      REAL_T rxcoarseblocks(10),rycoarseblocks(10),rzcoarseblocks(10)

      INTEGER_T   DIMDEC(tag)
      INTEGER_T   DIMDEC(vfrac)
      INTEGER_T   nvar, set, clear
      INTEGER_T   level
      INTEGER_T   max_level
      INTEGER_T   max_level_two_materials
      INTEGER_T   tilelo(SDIM), tilehi(SDIM)
      INTEGER_T   fablo(SDIM), fabhi(SDIM)
      INTEGER_T   growlo(3), growhi(3)
      INTEGER_T   bfact
      INTEGER_T   domlo(SDIM), domhi(SDIM)
      REAL_T    dx(SDIM), xlo(SDIM), problo(SDIM), time
      INTEGER_T   tag(DIMV(tag))
      REAL_T    vfrac(DIMV(vfrac),nvar)
      REAL_T    x, y, z, rflag
      INTEGER_T   i, j,k,np
      INTEGER_T   tagflag
      REAL_T xsten(-1:1,SDIM)
      INTEGER_T nhalf

      nhalf=1

      if (bfact.lt.1) then
       print *,"bfact invalid200"
       stop
      endif

      if (level.lt.0) then
       print *,"level invalid vfrac error"
       stop
      endif
      if (max_level.le.level) then
       print *,"max_level invalid"
       stop
      endif
      if ((max_level_two_materials.lt.0).or. &
          (max_level_two_materials.gt.max_level)) then
       print *,"max_level_two_materials invalid"
       stop
      endif
      if ((nblocks.lt.0).or.(ncoarseblocks.lt.0).or. &
          (nblocks.ge.10).or.(ncoarseblocks.ge.10)) then
       print *,"nblocks or ncoarseblocks out of range"
       stop
      endif

      call checkbound(fablo,fabhi,DIMS(tag),0,-1,1400)
      call checkbound(fablo,fabhi,DIMS(vfrac),0,-1,1400)

      call growntilebox(tilelo,tilehi,fablo,fabhi,growlo,growhi,0) 
      do i=growlo(1),growhi(1)
      do j=growlo(2),growhi(2)
      do k=growlo(3),growhi(3)
       call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)
       x=xsten(0,1)
       y=xsten(0,2)
       z=xsten(0,SDIM)

        ! comes from calc_error_indicator and EOS_error_ind
       rflag=vfrac(D_DECL(i,j,k),1)
       tagflag=0

       call override_tagflag(xsten,nhalf,time,rflag,tagflag)

       if (rflag.ge.one) then
        tagflag=1
       endif
       if ((rflag.gt.zero).and.(level.lt.max_level_two_materials)) then
        tagflag=1
       endif

       if ((probtype.eq.66).and.(SDIM.eq.2)) then
        if (xblob2.lt.xblob3) then
         if ((x.lt.xblob2).or.(x.gt.xblob3)) then
          tagflag=0
         endif
        endif
       endif
      
       if (ractivex.gt.zero) then
        if ((abs(x-xactive).gt.ractivex).or. &
#if (AMREX_SPACEDIM==3)
            (abs(z-zactive).gt.ractivez).or. &
#endif
            (abs(y-yactive).gt.ractivey)) then
         tagflag=0
        endif
       endif

       if (nblocks.gt.0) then
        do np=1,nblocks
         if ((abs(x-xblocks(np)).le.rxblocks(np)).and. &
#if (AMREX_SPACEDIM==3)
             (abs(z-zblocks(np)).le.rzblocks(np)).and. &
#endif
             (abs(y-yblocks(np)).le.ryblocks(np))) then
          tagflag=1
         endif
        enddo
       endif

       if (ncoarseblocks.gt.0) then
        if (((probtype.eq.541).and.(level.gt.3)).or.(probtype.ne.541)) then
         do np=1,ncoarseblocks
          if ((abs(x-xcoarseblocks(np)).ge.rxcoarseblocks(np)).or. &
#if (AMREX_SPACEDIM==3)
              (abs(z-zcoarseblocks(np)).ge.rzcoarseblocks(np)).or. &
#endif
              (abs(y-ycoarseblocks(np)).ge.rycoarseblocks(np))) then
           tagflag=0
          endif
         enddo
        endif
       endif ! ncoarseblocks>0

       if (tagflag.eq.1) then
        tag(D_DECL(i,j,k))=set
       endif

      enddo
      enddo
      enddo

      return
      end subroutine FORT_VFRACERROR

      subroutine FORT_FORCEVELOCITY( &
        nsolveMM_FACE, &
        problo,probhi, &
        vel,DIMS(vel), &
        velmac,DIMS(velmac), &
        dir, &
        xlo,dx, &
        tilelo,tilehi, &
        fablo,fabhi, &
        bfact, &
        time, &
        presbc_array, &
        outflow_velocity_buffer_size) !(1,1),(2,1),(3,1),(1,2),(2,2),(3,2)

      use probf90_module
      use global_utility_module

      IMPLICIT NONE
      INTEGER_T, intent(in) :: nsolveMM_FACE
      INTEGER_T nsolveMM_FACE_test
      INTEGER_T, intent(in) :: bfact
      INTEGER_T, intent(in) :: tilelo(SDIM),tilehi(SDIM)
      INTEGER_T, intent(in) :: fablo(SDIM),fabhi(SDIM)
      INTEGER_T :: growlo(3),growhi(3)
      INTEGER_T, intent(in) :: DIMDEC(vel)
      INTEGER_T, intent(in) :: DIMDEC(velmac)
      INTEGER_T, intent(in) :: dir
      REAL_T, intent(in) :: xlo(SDIM)
      REAL_T, intent(in) :: dx(SDIM)
      REAL_T, intent(in) :: time
      REAL_T, intent(in) :: problo(SDIM),probhi(SDIM)
      REAL_T, intent(inout) :: vel(DIMV(vel),SDIM*num_materials_vel)
      REAL_T, intent(inout) :: velmac(DIMV(velmac),nsolveMM_FACE)
      INTEGER_T, intent(in) :: presbc_array(SDIM,2,num_materials_vel)
      REAL_T, intent(in) :: outflow_velocity_buffer_size(2*SDIM)
      REAL_T vel_in

      INTEGER_T i,j,k,ii,jj,kk
      INTEGER_T dirloc
      REAL_T xsten(-1:1,SDIM)
      REAL_T xsten_cell(SDIM)
      INTEGER_T nhalf
      INTEGER_T nmat
      INTEGER_T velcomp

      nhalf=1

      nmat=num_materials

      if ((dir.lt.0).or.(dir.ge.SDIM)) then
       print *,"dir invalid forcevelocity"
       stop
      endif
      if (bfact.lt.1) then
       print *,"fact invalid"
       stop
      endif
 
      if (num_materials_vel.ne.1) then
       print *,"num_materials_vel invalid"
       stop
      endif

      nsolveMM_FACE_test=num_materials_vel
      if (nsolveMM_FACE.ne.nsolveMM_FACE_test) then
       print *,"nsolveMM_FACE invalid"
       stop
      endif

      ii=0
      jj=0
      kk=0
      if (dir.eq.0) then
       ii=1
      else if (dir.eq.1) then
       jj=1
      else if ((dir.eq.2).and.(SDIM.eq.3)) then
       kk=1
      else
       print *,"dir invalid forcevelocity 2"
       stop
      endif

      call checkbound(fablo,fabhi,DIMS(vel),1,-1,2400)
      call checkbound(fablo,fabhi,DIMS(velmac),0,dir,2400)

      call growntilebox(tilelo,tilehi,fablo,fabhi,growlo,growhi,0) 
      do i=growlo(1),growhi(1)
      do j=growlo(2),growhi(2)
      do k=growlo(3),growhi(3)
       call gridsten(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf)
       do dirloc=1,SDIM
        xsten_cell(dirloc)=xsten(0,dirloc)
       enddo
       velcomp=dir+1
       vel_in=vel(D_DECL(i,j,k),velcomp)*global_velocity_scale
       call vel_freestream( &
        xsten_cell, &
        dir,vel_in,time, &
        presbc_array, &
        outflow_velocity_buffer_size, &
        problo,probhi)
       vel(D_DECL(i,j,k),velcomp)=vel_in/global_velocity_scale
      enddo
      enddo
      enddo

      call growntileboxMAC(tilelo,tilehi,fablo,fabhi, &
         growlo,growhi,0,dir) 
      do i=growlo(1),growhi(1)
      do j=growlo(2),growhi(2)
      do k=growlo(3),growhi(3)
       call gridstenMAC(xsten,xlo,i,j,k,fablo,bfact,dx,nhalf,dir+1)
       do dirloc=1,SDIM
        xsten_cell(dirloc)=xsten(0,dirloc)
       enddo
       do velcomp=1,nsolveMM_FACE
        vel_in=velmac(D_DECL(i,j,k),velcomp)*global_velocity_scale
        call vel_freestream( &
         xsten_cell, &
         dir,vel_in,time, &
         presbc_array, &
         outflow_velocity_buffer_size, &
         problo,probhi)
        velmac(D_DECL(i,j,k),velcomp)=vel_in/global_velocity_scale
       enddo ! velcomp
      enddo
      enddo
      enddo

      return
      end subroutine FORT_FORCEVELOCITY

